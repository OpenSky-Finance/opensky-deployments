{
  "language": "Solidity",
  "sources": {
    "contracts/bespokemarket/interfaces/IOpenSkyBespokeDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport './IOpenSkyBespokeMarket.sol';\nimport '../libraries/BespokeTypes.sol';\n\ninterface IOpenSkyBespokeDataProvider {\n    struct LoanDataUI {\n        address tokenAddress;\n        uint256 tokenId;\n        uint256 tokenAmount; // 1 for ERC721, 1+ for ERC1155\n        address nftManager;\n        address borrower;\n        address lender;\n        uint256 amount;\n        uint128 borrowRate;\n        uint128 interestPerSecond;\n        address currency;\n        address lendAsset;\n        uint256 reserveFactor;\n        uint256 overdueLoanFeeFactor;\n        uint40 borrowDuration;\n        uint40 borrowBegin;\n        uint40 borrowOverdueTime;\n        uint40 liquidatableTime;\n        bool isProrated;\n        bool autoConvertWhenRepay;\n        BespokeTypes.LoanStatus status;\n        \n        // extra fields\n        uint256 loanId;\n        uint256 borrowBalance;\n        uint256 penalty;\n        uint256 borrowInterest;\n    }\n\n    function getLoanData(uint256 loanId) external view returns (LoanDataUI memory);\n}\n"
    },
    "contracts/bespokemarket/interfaces/IOpenSkyBespokeMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../libraries/BespokeTypes.sol';\n\ninterface IOpenSkyBespokeMarket {\n    event CancelAllOffers(address indexed sender, uint256 nonce);\n\n    event CancelMultipleOffers(address indexed sender, uint256[] nonces);\n\n    event TakeBorrowOffer(\n        bytes32 offerHash,\n        uint256 indexed loanId,\n        address indexed lender,\n        address indexed borrower,\n        uint256 nonce\n    );\n\n    event TakeLendOffer(\n        bytes32 offerHash,\n        uint256 indexed loanId,\n        address indexed lender,\n        address indexed borrower,\n        address onBehalfOf,\n        uint256 nonce,\n        uint256 nonceOrder\n    );\n\n    event Repay(uint256 indexed loanId, address indexed operator, address indexed receiver);\n\n    event Foreclose(uint256 indexed loanId, address indexed operator, address indexed receiver);\n\n    function takeBorrowOffer(\n        BespokeTypes.Offer memory offerData,\n        uint256 supplyAmount,\n        uint256 supplyDuration,\n        address lendAsset,\n        bool autoConvertWhenRepay\n    ) external returns (uint256);\n\n    function takeLendOffer(\n        BespokeTypes.Offer memory offerData,\n        uint256 tokenId,\n        uint256 borrowAmount,\n        uint256 borrowDuration,\n        address onBehalfOf,\n        bytes memory params\n    ) external returns (uint256);\n\n    function repay(uint256 loanId) external;\n\n    function foreclose(uint256 loanId) external;\n\n    function cancelAllBorrowOffersForSender(uint256 minNonce_) external;\n\n    function cancelMultipleBorrowOffers(uint256[] calldata offerNonces) external;\n\n    function isValidNonce(address account, uint256 nonce) external view returns (bool);\n\n    function getLoanData(uint256 loanId) external view returns (BespokeTypes.LoanData memory);\n\n    function getStatus(uint256 loanId) external view returns (BespokeTypes.LoanStatus);\n\n    function getBorrowInterest(uint256 loanId) external view returns (uint256);\n\n    function getBorrowBalance(uint256 loanId) external view returns (uint256);\n\n    function getPenalty(uint256 loanId) external view returns (uint256);\n}\n"
    },
    "contracts/bespokemarket/libraries/BespokeTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary BespokeTypes {\n    struct Offer {\n        bool isProrated; // whether to pay interest a fixed-time when repay early\n        bool autoConvertWhenRepay; // when currency!=lendAsset, whether to convert currency to lendAsset for lender when repay. Determined by lender.\n        OfferType offerType;\n        address tokenAddress;\n        uint256 tokenId;\n        uint256 tokenAmount; // 1 for ERC721, 1+ for ERC1155\n        address signer; //borrower or lender\n        uint256 borrowAmountMin;\n        uint256 borrowAmountMax;\n        uint40 borrowDurationMin;\n        uint40 borrowDurationMax;\n        uint128 borrowRate;\n        address currency;  // Asset to borrow or receive when loan created. Borrower should also use it for repay.\n        address lendAsset; // Using which token to lend. Determined by lender and should be zero address for borrow offer.\n        uint256 nonce;\n        uint256 nonceMaxTimes;// should be 1 for a borrow offer\n        uint256 deadline;\n        address strategy; // used for lend offer. should be zero address for borrow offer\n        bytes params;\n        uint8 v; // v: parameter (27 or 28)\n        bytes32 r; // r: parameter\n        bytes32 s; // s: parameter\n    }\n\n    struct LoanData {\n        address tokenAddress;\n        uint256 tokenId;\n        uint256 tokenAmount; // 1 for ERC721, 1+ for ERC1155\n        address nftManager;\n        address borrower;\n        address lender;\n        uint256 amount;\n        uint128 borrowRate;\n        uint128 interestPerSecond;\n        address currency;\n        address lendAsset;\n        uint256 reserveFactor;\n        uint256 overdueLoanFeeFactor;\n        uint40 borrowDuration;\n        uint40 borrowBegin;\n        uint40 borrowOverdueTime;\n        uint40 liquidatableTime;\n        bool isProrated;\n        bool autoConvertWhenRepay;\n        LoanStatus status;\n    }\n\n    enum OfferType {\n        BORROW, // borrow offer\n        LEND // lend offer\n    }\n\n    struct TakeBorrowInfo {\n        uint256 borrowAmount;\n        uint256 borrowDuration;\n        address lendAsset;\n        bool autoConvertWhenRepay;\n    }\n\n    struct TakeLendInfo {\n        uint256 borrowAmount;\n        uint256 borrowDuration;\n        uint256 tokenId;\n        address onBehalfOf;\n        bytes params;\n    }\n\n    // params for lend strategy\n    struct TakeLendInfoForStrategy {\n        address taker;\n        uint256 tokenId;\n        bytes params;\n    }\n\n    enum LoanStatus {\n        NONE,\n        BORROWING,\n        OVERDUE,\n        LIQUIDATABLE\n    }\n\n    struct WhitelistInfo {\n        bool enabled;\n        uint256 minBorrowDuration;\n        uint256 maxBorrowDuration;\n        uint256 overdueDuration;\n    }\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    struct NonceInfo {\n        bool invalid;\n        uint256 usedTimes;\n        bytes32 offerHash;\n    }\n}\n"
    },
    "contracts/bespokemarket/OpenSkyBespokeDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport './interfaces/IOpenSkyBespokeMarket.sol';\nimport './interfaces/IOpenSkyBespokeDataProvider.sol';\nimport './libraries/BespokeTypes.sol';\n\n/*\n *  a helper contract to aggregate data for front-end\n */\ncontract OpenSkyBespokeDataProvider is  IOpenSkyBespokeDataProvider{\n    IOpenSkyBespokeMarket public immutable MARKET;\n\n    constructor(IOpenSkyBespokeMarket MARKET_) {\n        MARKET = MARKET_;\n    }\n\n    function getLoanData(uint256 loanId) external view override returns (LoanDataUI memory) {\n        BespokeTypes.LoanData memory loan = MARKET.getLoanData(loanId);\n        return\n            LoanDataUI({\n                tokenAddress: loan.tokenAddress,\n                tokenId: loan.tokenId,\n                tokenAmount: loan.tokenAmount,\n                nftManager:loan.nftManager,\n                borrower: loan.borrower,\n                lender: loan.lender,\n                amount:loan.amount,\n                borrowRate: loan.borrowRate,\n                interestPerSecond: loan.interestPerSecond,\n                currency: loan.currency,\n                lendAsset:loan.lendAsset,\n                reserveFactor:loan.reserveFactor,\n                overdueLoanFeeFactor:loan.overdueLoanFeeFactor,\n                borrowDuration: loan.borrowDuration,\n                borrowBegin: loan.borrowBegin,\n                borrowOverdueTime: loan.borrowOverdueTime,\n                liquidatableTime: loan.liquidatableTime,\n                isProrated:loan.isProrated,\n                autoConvertWhenRepay:loan.autoConvertWhenRepay,\n                status: loan.status,\n                // extra\n                loanId: loanId,\n                borrowBalance: MARKET.getBorrowBalance(loanId),\n                penalty: MARKET.getPenalty(loanId),\n                borrowInterest:MARKET.getBorrowInterest(loanId)\n            });\n    }\n}\n"
    },
    "contracts/refinance/IOpenSkyRefinance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../bespokemarket/libraries/BespokeTypes.sol';\n\ninterface IOpenSkyRefinance {\n\n    function refinance(\n        address adapter,\n        address flashBorrowAssetAddress,\n        uint256 flashBorrowAmount,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/refinance/OpenSkyRefinance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport './interfaces/IAaveLendPoolAddressesProvider.sol';\nimport './interfaces/IAaveLendPool.sol';\n\nimport './IOpenSkyRefinance.sol';\n\ncontract OpenSkyRefinance is IOpenSkyRefinance {\n    IAaveLendPoolAddressesProvider public immutable AAVE2_ADDRESSES_PROVIDER;\n\n    constructor(IAaveLendPoolAddressesProvider provider) {\n        AAVE2_ADDRESSES_PROVIDER = provider;\n    }\n\n    function aavePool() public view returns (IAaveLendPool) {\n        return IAaveLendPool(AAVE2_ADDRESSES_PROVIDER.getLendingPool());\n    }\n\n    function refinance(\n        address adapter,\n        address flashBorrowAssetAddress,\n        uint256 flashBorrowAmount,\n        bytes calldata data\n    ) public override {\n        address[] memory assets = new address[](1);\n        assets[0] = flashBorrowAssetAddress;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = flashBorrowAmount;\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n        bytes memory params = abi.encode(data, msg.sender);\n        aavePool().flashLoan(adapter, assets, amounts, modes, address(0), params, 0);\n    }\n}\n"
    },
    "contracts/refinance/interfaces/IAaveLendPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\n/**\n * @title IAaveLendPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the aave protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Bend\n **/\n// aave-v2\ninterface IAaveLendPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n    \n}\n"
    },
    "contracts/refinance/interfaces/IAaveLendPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IAaveLendPool {\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n}\n"
    },
    "contracts/refinance/adapters/PoolToBespokeAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\n\nimport '../interfaces/IAaveFlashLoanReceiver.sol';\nimport '../interfaces/IAaveLendPoolAddressesProvider.sol';\nimport '../interfaces/IAaveLendPool.sol';\n\nimport '../../bespokemarket/interfaces/IOpenSkyBespokeMarket.sol';\nimport '../../bespokemarket/interfaces/IOpenSkyBespokeSettings.sol';\nimport '../../bespokemarket/libraries/BespokeTypes.sol';\n\nimport '../../interfaces/IOpenSkySettings.sol';\nimport '../../interfaces/IOpenSkyPool.sol';\nimport '../../interfaces/IOpenSkyLoan.sol';\n\ncontract PoolToBespokeAdapter is IAaveFlashLoanReceiver, ERC721Holder {\n    using SafeERC20 for IERC20;\n\n    IAaveLendPoolAddressesProvider public immutable AAVE2_ADDRESSES_PROVIDER;\n    IOpenSkySettings public immutable SETTINGS;\n    IOpenSkyBespokeSettings public immutable BESPOKE_SETTINGS;\n\n    event RefinancePoolToBespoke(address indexed asset, address indexed borrower, uint256 oldLoanId, uint256 newLoanId);\n\n    constructor(\n        IAaveLendPoolAddressesProvider provider,\n        IOpenSkyBespokeSettings bespokeSettings,\n        IOpenSkySettings poolSettings\n    ) {\n        AAVE2_ADDRESSES_PROVIDER = provider;\n        BESPOKE_SETTINGS = bespokeSettings;\n        SETTINGS = poolSettings;\n    }\n\n    function aavePool() public view returns (IAaveLendPool) {\n        return IAaveLendPool(AAVE2_ADDRESSES_PROVIDER.getLendingPool());\n    }\n\n    struct LocalVars {\n        uint256 loanId;\n        uint256 repayAmount;\n        address assetAddress;\n        uint256 borrowAmount;\n        uint256 borrowDuration;\n        address borrower;\n        uint256 needInput;\n        bytes params;\n        bytes params2;\n        BespokeTypes.Offer offer;\n        uint256 newLoanId;\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool) {\n        // TODO more check?\n        // [] check initiator == OpenSkyRefinance\n\n        require(\n            assets.length == 1 && amounts.length == 1 && premiums.length == 1,\n            'BM_FLASH_LOAN_MULTIPLE_ASSETS_NOT_SUPPORTED'\n        );\n        require(address(aavePool()) == msg.sender, 'BM_FLASH_LOAN_INVALID_CALLER');\n\n        LocalVars memory vars;\n\n        // decode\n        (vars.params, vars.borrower) = abi.decode(params, (bytes, address));\n        (vars.loanId, vars.borrowAmount, vars.borrowDuration, vars.params2) = abi.decode(\n            vars.params,\n            (uint256, uint256, uint256, bytes)\n        );\n        vars.offer = abi.decode(vars.params2, (BespokeTypes.Offer));\n\n        // logic\n        // repay\n        // OpenSkyLoan\n        IERC721(SETTINGS.loanAddress()).safeTransferFrom(vars.borrower, address(this), vars.loanId);\n\n        DataTypes.LoanData memory loan = IOpenSkyLoan(SETTINGS.loanAddress()).getLoanData(vars.loanId);\n\n        require(loan.nftAddress == vars.offer.tokenAddress, 'BM_FLASH_LOAN_CURRENCY_NOT_MATCH');\n\n        // repay loan\n        vars.repayAmount =\n            IOpenSkyLoan(SETTINGS.loanAddress()).getPenalty(vars.loanId) +\n            IOpenSkyLoan(SETTINGS.loanAddress()).getBorrowBalance(vars.loanId);\n        IERC20(assets[0]).approve(SETTINGS.poolAddress(), vars.repayAmount);\n        IOpenSkyPool(SETTINGS.poolAddress()).repay(vars.loanId);\n\n        // borrow again\n        IERC721(loan.nftAddress).approve(BESPOKE_SETTINGS.getNftTransferAdapter(loan.nftAddress), loan.tokenId);\n\n        // only support single or colletcion offer\n        vars.newLoanId = IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).takeLendOffer(\n            vars.offer,\n            loan.tokenId,\n            vars.borrowAmount,\n            vars.borrowDuration,\n            address(this),\n            ''\n        );\n        vars.needInput = vars.repayAmount + premiums[0];\n\n        // transfer erc20\n        if (vars.borrowAmount > vars.needInput) {\n            IERC20(assets[0]).safeTransfer(vars.borrower, vars.borrowAmount - vars.needInput);\n        } else if (vars.borrowAmount < vars.needInput) {\n            IERC20(assets[0]).safeTransferFrom(vars.borrower, address(this), vars.needInput - vars.borrowAmount);\n        }\n\n        // transfer OpenSkyBespokeBorrowNFT\n        IERC721(BESPOKE_SETTINGS.borrowLoanAddress()).safeTransferFrom(address(this), vars.borrower, vars.newLoanId);\n\n        //repay flashloan\n        IERC20(assets[0]).approve(address(aavePool()), amounts[0] + premiums[0]);\n\n        emit RefinancePoolToBespoke(assets[0], vars.borrower, vars.loanId, vars.newLoanId);\n\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/refinance/interfaces/IAaveFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @title IAaveFlashLoanReceiver interface\n * @notice Interface for the Aave fee IFlashLoanReceiver.\n * @author Bend\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n **/\ninterface IAaveFlashLoanReceiver {\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool);\n}\n"
    },
    "contracts/bespokemarket/interfaces/IOpenSkyBespokeSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '../libraries/BespokeTypes.sol';\n\ninterface IOpenSkyBespokeSettings {\n    event InitLoanAddress(address operator, address borrowLoanAddress, address lendLoanAddress);\n    event InitMarketAddress(address operator, address address_);\n\n    event SetReserveFactor(address operator, uint256 factor);\n    event SetOverdueLoanFeeFactor(address operator, uint256 factor);\n\n    event SetMinBorrowDuration(address operator, uint256 factor);\n    event SetMaxBorrowDuration(address operator, uint256 factor);\n    event SetOverdueDuration(address operator, uint256 factor);\n\n    // nft whitelist\n    event OpenWhitelist(address operator);\n    event CloseWhitelist(address operator);\n    event AddToWhitelist(address operator, address nft);\n    event RemoveFromWhitelist(address operator, address nft);\n\n    // currency whitelist\n    event AddCurrency(address operator, address currency);\n    event RemoveCurrency(address operator, address currency);\n\n    // strategy whitelist list\n    event AddStrategy(address operator, address address_);\n    event RemoveStrategy(address operator, address address_);\n\n    // setting for nft transfer adapter \n    event InitDefaultNftTransferAdapter(address ERC721DefaultTransferAdapter, address ERC1155DefaultTransferAdapter);\n    event AddNftTransferAdapter(address operator, address nftAddress, address adapterAddress);\n    event RemoveNftTransferAdapter(address operator, address nftAddress);\n\n    // settings for currency transfer adapter \n    event InitDefaultCurrencyTransferAdapter(address currencyDefaultTransferAdapter);\n    event AddCurrencyTransferAdapter(address operator, address currencyAddress, address adapterAddress);\n    event RemoveCurrencyTransferAdapter(address operator, address currencyAddress);\n\n    function marketAddress() external view returns (address);\n\n    function borrowLoanAddress() external view returns (address);\n\n    function lendLoanAddress() external view returns (address);\n\n    function minBorrowDuration() external view returns (uint256);\n\n    function maxBorrowDuration() external view returns (uint256);\n\n    function overdueDuration() external view returns (uint256);\n\n    function reserveFactor() external view returns (uint256);\n\n    function MAX_RESERVE_FACTOR() external view returns (uint256);\n\n    function overdueLoanFeeFactor() external view returns (uint256);\n\n    function isWhitelistOn() external view returns (bool);\n\n    function inWhitelist(address nft) external view returns (bool);\n\n    function getWhitelistDetail(address nft) external view returns (BespokeTypes.WhitelistInfo memory);\n\n    function getBorrowDurationConfig(address nftAddress)\n        external\n        view\n        returns (\n            uint256 minBorrowDuration,\n            uint256 maxBorrowDuration,\n            uint256 overdueDuration\n        );\n\n    function isCurrencyWhitelisted(address currency) external view returns (bool);\n\n    function getCurrencyTransferAdapter(address currency) external view returns (address adapter);\n\n    function getNftTransferAdapter(address nftAddress) external view returns (address);\n\n    function isStrategyWhitelisted(address address_) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOpenSkySettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '../libraries/types/DataTypes.sol';\n\ninterface IOpenSkySettings {\n    event InitPoolAddress(address operator, address address_);\n    event InitLoanAddress(address operator, address address_);\n    event InitVaultFactoryAddress(address operator, address address_);\n    event InitIncentiveControllerAddress(address operator, address address_);\n    event InitWETHGatewayAddress(address operator, address address_);\n    event InitPunkGatewayAddress(address operator, address address_);\n    event InitDaoVaultAddress(address operator, address address_);\n\n    event AddToWhitelist(address operator, uint256 reserveId, address nft);\n    event RemoveFromWhitelist(address operator, uint256 reserveId, address nft);\n    event SetReserveFactor(address operator, uint256 factor);\n    event SetPrepaymentFeeFactor(address operator, uint256 factor);\n    event SetOverdueLoanFeeFactor(address operator, uint256 factor);\n    event SetMoneyMarketAddress(address operator, address address_);\n    event SetTreasuryAddress(address operator, address address_);\n    event SetACLManagerAddress(address operator, address address_);\n    event SetLoanDescriptorAddress(address operator, address address_);\n    event SetNftPriceOracleAddress(address operator, address address_);\n    event SetInterestRateStrategyAddress(address operator, address address_);\n    event AddLiquidator(address operator, address address_);\n    event RemoveLiquidator(address operator, address address_);\n\n    function poolAddress() external view returns (address);\n\n    function loanAddress() external view returns (address);\n\n    function vaultFactoryAddress() external view returns (address);\n\n    function incentiveControllerAddress() external view returns (address);\n\n    function wethGatewayAddress() external view returns (address);\n\n    function punkGatewayAddress() external view returns (address);\n\n    function inWhitelist(uint256 reserveId, address nft) external view returns (bool);\n\n    function getWhitelistDetail(uint256 reserveId, address nft) external view returns (DataTypes.WhitelistInfo memory);\n\n    function reserveFactor() external view returns (uint256); // treasury ratio\n\n    function MAX_RESERVE_FACTOR() external view returns (uint256);\n\n    function prepaymentFeeFactor() external view returns (uint256);\n\n    function overdueLoanFeeFactor() external view returns (uint256);\n\n    function moneyMarketAddress() external view returns (address);\n\n    function treasuryAddress() external view returns (address);\n\n    function daoVaultAddress() external view returns (address);\n\n    function ACLManagerAddress() external view returns (address);\n\n    function loanDescriptorAddress() external view returns (address);\n\n    function nftPriceOracleAddress() external view returns (address);\n\n    function interestRateStrategyAddress() external view returns (address);\n    \n    function isLiquidator(address liquidator) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOpenSkyPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../libraries/types/DataTypes.sol';\n\n/**\n * @title IOpenSkyPool\n * @author OpenSky Labs\n * @notice Defines the basic interface for an OpenSky Pool.\n **/\n\ninterface IOpenSkyPool {\n    /*\n     * @dev Emitted on create()\n     * @param reserveId The ID of the reserve\n     * @param underlyingAsset The address of the underlying asset\n     * @param oTokenAddress The address of the oToken\n     * @param name The name to use for oToken\n     * @param symbol The symbol to use for oToken\n     * @param decimals The decimals of the oToken\n     */\n    event Create(\n        uint256 indexed reserveId,\n        address indexed underlyingAsset,\n        address indexed oTokenAddress,\n        string name,\n        string symbol,\n        uint8 decimals\n    );\n\n    /*\n     * @dev Emitted on setTreasuryFactor()\n     * @param reserveId The ID of the reserve\n     * @param factor The new treasury factor of the reserve\n     */\n    event SetTreasuryFactor(uint256 indexed reserveId, uint256 factor);\n\n    /*\n     * @dev Emitted on setInterestModelAddress()\n     * @param reserveId The ID of the reserve\n     * @param interestModelAddress The address of the interest model contract\n     */\n    event SetInterestModelAddress(uint256 indexed reserveId, address interestModelAddress);\n\n    /*\n     * @dev Emitted on openMoneyMarket()\n     * @param reserveId The ID of the reserve\n     */\n    event OpenMoneyMarket(uint256 reserveId);\n\n    /*\n     * @dev Emitted on closeMoneyMarket()\n     * @param reserveId The ID of the reserve\n     */\n    event CloseMoneyMarket(uint256 reserveId);\n\n    /*\n     * @dev Emitted on deposit()\n     * @param reserveId The ID of the reserve\n     * @param onBehalfOf The address that will receive the oTokens\n     * @param amount The amount of ETH to be deposited\n     * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n     * 0 if the action is executed directly by the user, without any intermediaries\n     */\n    event Deposit(uint256 indexed reserveId, address indexed onBehalfOf, uint256 amount, uint256 referralCode);\n\n    /*\n     * @dev Emitted on withdraw()\n     * @param reserveId The ID of the reserve\n     * @param onBehalfOf The address that will receive assets withdrawed\n     * @param amount The amount to be withdrawn\n     */\n    event Withdraw(uint256 indexed reserveId, address indexed onBehalfOf, uint256 amount);\n\n    /*\n     * @dev Emitted on borrow()\n     * @param reserveId The ID of the reserve\n     * @param user The address initiating the withdrawal(), owner of oTokens\n     * @param onBehalfOf The address that will receive the ETH and the loan NFT\n     * @param loanId The loan ID\n     */\n    event Borrow(\n        uint256 indexed reserveId,\n        address user,\n        address indexed onBehalfOf,\n        uint256 indexed loanId\n    );\n\n    /*\n     * @dev Emitted on repay()\n     * @param reserveId The ID of the reserve\n     * @param repayer The address initiating the repayment()\n     * @param onBehalfOf The address that will receive the pledged NFT\n     * @param loanId The ID of the loan\n     * @param repayAmount The borrow balance of the loan when it was repaid\n     * @param penalty The penalty of the loan for either early or overdue repayment\n     */\n    event Repay(\n        uint256 indexed reserveId,\n        address repayer,\n        address indexed onBehalfOf,\n        uint256 indexed loanId,\n        uint256 repayAmount,\n        uint256 penalty\n    );\n\n    /*\n     * @dev Emitted on extend()\n     * @param reserveId The ID of the reserve\n     * @param onBehalfOf The owner address of loan NFT\n     * @param oldLoanId The ID of the old loan\n     * @param newLoanId The ID of the new loan\n     */\n    event Extend(uint256 indexed reserveId, address indexed onBehalfOf, uint256 oldLoanId, uint256 newLoanId);\n\n    /*\n     * @dev Emitted on startLiquidation()\n     * @param reserveId The ID of the reserve\n     * @param loanId The ID of the loan\n     * @param nftAddress The address of the NFT used as collateral\n     * @param tokenId The ID of the NFT used as collateral\n     * @param operator The address initiating startLiquidation()\n     */\n    event StartLiquidation(\n        uint256 indexed reserveId,\n        uint256 indexed loanId,\n        address indexed nftAddress,\n        uint256 tokenId,\n        address operator\n    );\n\n    /*\n     * @dev Emitted on endLiquidation()\n     * @param reserveId The ID of the reserve\n     * @param loanId The ID of the loan\n     * @param nftAddress The address of the NFT used as collateral\n     * @param tokenId The ID of the NFT used as collateral\n     * @param operator\n     * @param repayAmount The amount used to repay, must be equal to or greater than the borrowBalance, excess part will be shared by all the lenders\n     * @param borrowBalance The borrow balance of the loan\n     */\n    event EndLiquidation(\n        uint256 indexed reserveId,\n        uint256 indexed loanId,\n        address indexed nftAddress,\n        uint256 tokenId,\n        address operator,\n        uint256 repayAmount,\n        uint256 borrowBalance\n    );\n\n    /**\n     * @notice Creates a reserve\n     * @dev Only callable by the pool admin role\n     * @param underlyingAsset The address of the underlying asset\n     * @param name The name of the oToken\n     * @param symbol The symbol for the oToken\n     * @param decimals The decimals of the oToken\n     **/\n    function create(\n        address underlyingAsset,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) external;\n\n    /**\n     * @notice Updates the treasury factor of a reserve\n     * @dev Only callable by the pool admin role\n     * @param reserveId The ID of the reserve\n     * @param factor The new treasury factor of the reserve\n     **/\n    function setTreasuryFactor(uint256 reserveId, uint256 factor) external;\n\n    /**\n     * @notice Updates the interest model address of a reserve\n     * @dev Only callable by the pool admin role\n     * @param reserveId The ID of the reserve\n     * @param interestModelAddress The new address of the interest model contract\n     **/\n    function setInterestModelAddress(uint256 reserveId, address interestModelAddress) external;\n\n    /**\n     * @notice Open the money market\n     * @dev Only callable by the emergency admin role\n     * @param reserveId The ID of the reserve\n     **/\n    function openMoneyMarket(uint256 reserveId) external;\n\n    /**\n     * @notice Close the money market\n     * @dev Only callable by the emergency admin role\n     * @param reserveId The ID of the reserve\n     **/\n    function closeMoneyMarket(uint256 reserveId) external;\n\n    /**\n     * @dev Deposits ETH into the reserve.\n     * @param reserveId The ID of the reserve\n     * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n     **/\n    function deposit(uint256 reserveId, uint256 amount, address onBehalfOf, uint256 referralCode) external;\n\n    /**\n     * @dev withdraws the ETH from reserve.\n     * @param reserveId The ID of the reserve\n     * @param amount amount of oETH to withdraw and receive native ETH\n     **/\n    function withdraw(uint256 reserveId, uint256 amount, address onBehalfOf) external;\n\n    /**\n     * @dev Borrows ETH from reserve using an NFT as collateral and will receive a loan NFT as receipt.\n     * @param reserveId The ID of the reserve\n     * @param amount amount of ETH user will borrow\n     * @param duration The desired duration of the loan\n     * @param nftAddress The collateral NFT address\n     * @param tokenId The ID of the NFT\n     * @param onBehalfOf address of the user who will receive ETH and loan NFT.\n     **/\n    function borrow(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        address nftAddress,\n        uint256 tokenId,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Repays a loan, as a result the corresponding loan NFT owner will receive the collateralized NFT.\n     * @param loanId The ID of the loan the user will repay\n     */\n    function repay(uint256 loanId) external returns (uint256);\n\n    /**\n     * @dev Extends creates a new loan and terminates the old loan.\n     * @param loanId The loan ID to extend\n     * @param amount The amount of ERC20 token the user will borrow in the new loan\n     * @param duration The selected duration the user will borrow in the new loan\n     * @param onBehalfOf The address will borrow in the new loan\n     **/\n    function extend(\n        uint256 loanId,\n        uint256 amount,\n        uint256 duration,\n        address onBehalfOf\n    ) external returns (uint256, uint256);\n\n    /**\n     * @dev Starts liquidation for a loan when it's in LIQUIDATABLE status\n     * @param loanId The ID of the loan which will be liquidated\n     */\n    function startLiquidation(uint256 loanId) external;\n\n    /**\n     * @dev Completes liquidation for a loan which will be repaid.\n     * @param loanId The ID of the liquidated loan that will be repaid.\n     * @param amount The amount of the token that will be repaid.\n     */\n    function endLiquidation(uint256 loanId, uint256 amount) external;\n\n    /**\n     * @dev Returns the state of the reserve\n     * @param reserveId The ID of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(uint256 reserveId) external view returns (DataTypes.ReserveData memory);\n\n    /**\n     * @dev Returns the normalized income of the reserve\n     * @param reserveId The ID of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(uint256 reserveId) external view returns (uint256);\n\n    /**\n     * @dev Returns the remaining liquidity of the reserve\n     * @param reserveId The ID of the reserve\n     * @return The reserve's withdrawable balance\n     */\n    function getAvailableLiquidity(uint256 reserveId) external view returns (uint256);\n\n    /**\n     * @dev Returns the instantaneous borrow limit value of a special NFT\n     * @param nftAddress The address of the NFT\n     * @param tokenId The ID of the NFT\n     * @return The NFT's borrow limit\n     */\n    function getBorrowLimitByOracle(\n        uint256 reserveId,\n        address nftAddress,\n        uint256 tokenId\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the sum of all users borrow balances include borrow interest accrued\n     * @param reserveId The ID of the reserve\n     * @return The total borrow balance of the reserve\n     */\n    function getTotalBorrowBalance(uint256 reserveId) external view returns (uint256);\n\n    /**\n     * @dev Returns TVL (total value locked) of the reserve.\n     * @param reserveId The ID of the reserve\n     * @return The reserve's TVL\n     */\n    function getTVL(uint256 reserveId) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOpenSkyLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '../libraries/types/DataTypes.sol';\n\n/**\n * @title IOpenSkyLoan\n * @author OpenSky Labs\n * @notice Defines the basic interface for OpenSkyLoan.  This loan NFT is composable and can be used in other DeFi protocols \n **/\ninterface IOpenSkyLoan is IERC721 {\n\n    /**\n     * @dev Emitted on mint()\n     * @param tokenId The ID of the loan\n     * @param recipient The address that will receive the loan NFT\n     **/\n    event Mint(uint256 indexed tokenId, address indexed recipient);\n\n    /**\n     * @dev Emitted on end()\n     * @param tokenId The ID of the loan\n     * @param onBehalfOf The address the repayer is repaying for\n     * @param repayer The address of the user initiating the repayment()\n     **/\n    event End(uint256 indexed tokenId, address indexed onBehalfOf, address indexed repayer);\n\n    /**\n     * @dev Emitted on startLiquidation()\n     * @param tokenId The ID of the loan\n     * @param liquidator The address of the liquidator\n     **/\n    event StartLiquidation(uint256 indexed tokenId, address indexed liquidator);\n\n    /**\n     * @dev Emitted on endLiquidation()\n     * @param tokenId The ID of the loan\n     * @param liquidator The address of the liquidator\n     **/\n    event EndLiquidation(uint256 indexed tokenId, address indexed liquidator);\n\n    /**\n     * @dev Emitted on updateStatus()\n     * @param tokenId The ID of the loan\n     * @param status The status of loan\n     **/\n    event UpdateStatus(uint256 indexed tokenId, DataTypes.LoanStatus indexed status);\n\n    /**\n     * @dev Emitted on flashClaim()\n     * @param receiver The address of the flash loan receiver contract\n     * @param sender The address that will receive tokens\n     * @param nftAddress The address of the collateralized NFT\n     * @param tokenId The ID of collateralized NFT\n     **/\n    event FlashClaim(address indexed receiver, address sender, address indexed nftAddress, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted on claimERC20Airdrop()\n     * @param token The address of the ERC20 token\n     * @param to The address that will receive the ERC20 tokens\n     * @param amount The amount of the tokens\n     **/\n    event ClaimERC20Airdrop(address indexed token, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on claimERC721Airdrop()\n     * @param token The address of ERC721 token\n     * @param to The address that will receive the eRC721 tokens\n     * @param ids The ID of the token\n     **/\n    event ClaimERC721Airdrop(address indexed token, address indexed to, uint256[] ids);\n\n    /**\n     * @dev Emitted on claimERC1155Airdrop()\n     * @param token The address of the ERC1155 token\n     * @param to The address that will receive the ERC1155 tokens\n     * @param ids The ID of the token\n     * @param amounts The amount of the tokens\n     * @param data packed params to pass to the receiver as extra information\n     **/\n    event ClaimERC1155Airdrop(address indexed token, address indexed to, uint256[] ids, uint256[] amounts, bytes data);\n\n    /**\n     * @notice Mints a loan NFT to user\n     * @param reserveId The ID of the reserve\n     * @param borrower The address of the borrower\n     * @param nftAddress The contract address of the collateralized NFT \n     * @param nftTokenId The ID of the collateralized NFT\n     * @param amount The amount of the loan\n     * @param duration The duration of the loan\n     * @param borrowRate The borrow rate of the loan\n     * @return loanId and loan data\n     **/\n    function mint(\n        uint256 reserveId,\n        address borrower,\n        address nftAddress,\n        uint256 nftTokenId,\n        uint256 amount,\n        uint256 duration,\n        uint256 borrowRate\n    ) external returns (uint256 loanId, DataTypes.LoanData memory loan);\n\n    /**\n     * @notice Starts liquidation of the loan in default\n     * @param tokenId The ID of the defaulted loan\n     **/\n    function startLiquidation(uint256 tokenId) external;\n\n    /**\n     * @notice Ends liquidation of a loan that is fully settled\n     * @param tokenId The ID of the loan\n     **/\n    function endLiquidation(uint256 tokenId) external;\n\n    /**\n     * @notice Terminates the loan\n     * @param tokenId The ID of the loan\n     * @param onBehalfOf The address the repayer is repaying for\n     * @param repayer The address of the repayer\n     **/\n    function end(uint256 tokenId, address onBehalfOf, address repayer) external;\n    \n    /**\n     * @notice Returns the loan data\n     * @param tokenId The ID of the loan\n     * @return The details of the loan\n     **/\n    function getLoanData(uint256 tokenId) external view returns (DataTypes.LoanData calldata);\n\n    /**\n     * @notice Returns the status of a loan\n     * @param tokenId The ID of the loan\n     * @return The status of the loan\n     **/\n    function getStatus(uint256 tokenId) external view returns (DataTypes.LoanStatus);\n\n    /**\n     * @notice Returns the borrow interest of the loan\n     * @param tokenId The ID of the loan\n     * @return The borrow interest of the loan\n     **/\n    function getBorrowInterest(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the borrow balance of a loan, including borrow interest\n     * @param tokenId The ID of the loan\n     * @return The borrow balance of the loan\n     **/\n    function getBorrowBalance(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the penalty fee of the loan\n     * @param tokenId The ID of the loan\n     * @return The penalty fee of the loan\n     **/\n    function getPenalty(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Returns the ID of the loan\n     * @param nftAddress The address of the collateralized NFT\n     * @param tokenId The ID of the collateralized NFT\n     * @return The ID of the loan\n     **/\n    function getLoanId(address nftAddress, uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @notice Allows smart contracts to access the collateralized NFT within one transaction,\n     * as long as the amount taken plus a fee is returned\n     * @dev IMPORTANT There are security concerns for developers of flash loan receiver contracts that must be carefully considered\n     * @param receiverAddress The address of the contract receiving the funds, implementing IOpenSkyFlashClaimReceiver interface\n     * @param loanIds The ID of loan being flash-borrowed\n     * @param params packed params to pass to the receiver as extra information\n     **/\n    function flashClaim(\n        address receiverAddress,\n        uint256[] calldata loanIds,\n        bytes calldata params\n    ) external;\n\n    /**\n     * @notice Claim the ERC20 token which has been airdropped to the loan contract\n     * @param token The address of the airdropped token\n     * @param to The address which will receive ERC20 token\n     * @param amount The amount of the ERC20 token\n     **/\n    function claimERC20Airdrop(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n\n    /**\n     * @notice Claim the ERC721 token which has been airdropped to the loan contract\n     * @param token The address of the airdropped token\n     * @param to The address which will receive the ERC721 token\n     * @param ids The ID of the ERC721 token\n     **/\n    function claimERC721Airdrop(\n        address token,\n        address to,\n        uint256[] calldata ids\n    ) external;\n\n    /**\n     * @notice Claim the ERC1155 token which has been airdropped to the loan contract\n     * @param token The address of the airdropped token\n     * @param to The address which will receive the ERC1155 tokens\n     * @param ids The ID of the ERC1155 token\n     * @param amounts The amount of the ERC1155 tokens\n     * @param data packed params to pass to the receiver as extra information\n     **/\n    function claimERC1155Airdrop(\n        address token,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary DataTypes {\n    struct ReserveData {\n        uint256 reserveId;\n        address underlyingAsset;\n        address oTokenAddress;\n        address moneyMarketAddress;\n        uint128 lastSupplyIndex;\n        uint256 borrowingInterestPerSecond;\n        uint256 lastMoneyMarketBalance;\n        uint40 lastUpdateTimestamp;\n        uint256 totalBorrows;\n        address interestModelAddress;\n        uint256 treasuryFactor;\n        bool isMoneyMarketOn;\n    }\n\n    struct LoanData {\n        uint256 reserveId;\n        address nftAddress;\n        uint256 tokenId;\n        address borrower;\n        uint256 amount;\n        uint128 borrowRate;\n        uint128 interestPerSecond;\n        uint40 borrowBegin;\n        uint40 borrowDuration;\n        uint40 borrowOverdueTime;\n        uint40 liquidatableTime;\n        uint40 extendableTime;\n        uint40 borrowEnd;\n        LoanStatus status;\n    }\n\n    enum LoanStatus {\n        NONE,\n        BORROWING,\n        EXTENDABLE,\n        OVERDUE,\n        LIQUIDATABLE,\n        LIQUIDATING\n    }\n\n    struct WhitelistInfo {\n        bool enabled;\n        string name;\n        string symbol;\n        uint256 LTV;\n        uint256 minBorrowDuration;\n        uint256 maxBorrowDuration;\n        uint256 extendableDuration;\n        uint256 overdueDuration;\n    }\n}\n"
    },
    "contracts/OpenSkyPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Counters.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nimport './interfaces/IOpenSkyCollateralPriceOracle.sol';\nimport './interfaces/IOpenSkyReserveVaultFactory.sol';\nimport './interfaces/IOpenSkyNFTDescriptor.sol';\nimport './interfaces/IOpenSkyLoan.sol';\nimport './interfaces/IOpenSkyPool.sol';\nimport './interfaces/IOpenSkySettings.sol';\nimport './interfaces/IACLManager.sol';\nimport './libraries/math/MathUtils.sol';\nimport './libraries/math/PercentageMath.sol';\nimport './libraries/helpers/Errors.sol';\nimport './libraries/types/DataTypes.sol';\nimport './libraries/ReserveLogic.sol';\n\n/**\n * @title OpenSkyPool contract\n * @author OpenSky Labs\n * @notice Main point of interaction with OpenSky protocol's pool\n * - Users can:\n *   # Deposit\n *   # Withdraw\n **/\ncontract OpenSkyPool is Context, Pausable, ReentrancyGuard, IOpenSkyPool {\n    using PercentageMath for uint256;\n    using Counters for Counters.Counter;\n    using ReserveLogic for DataTypes.ReserveData;\n\n    // Map of reserves and their data\n    mapping(uint256 => DataTypes.ReserveData) public reserves;\n\n    IOpenSkySettings public immutable SETTINGS;\n    Counters.Counter private _reserveIdTracker;\n\n    constructor(address SETTINGS_) Pausable() ReentrancyGuard() {\n        SETTINGS = IOpenSkySettings(SETTINGS_);\n    }\n\n    /**\n     * @dev Only pool admin can call functions marked by this modifier.\n     **/\n    modifier onlyPoolAdmin() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isPoolAdmin(_msgSender()), Errors.ACL_ONLY_POOL_ADMIN_CAN_CALL);\n        _;\n    }\n\n    /**\n     * @dev Only liquidator can call functions marked by this modifier.\n     **/\n    modifier onlyLiquidator() {\n        require(SETTINGS.isLiquidator(_msgSender()), Errors.ACL_ONLY_LIQUIDATOR_CAN_CALL);\n        _;\n    }\n\n    /**\n     * @dev Only emergency admin can call functions marked by this modifier.\n     **/\n    modifier onlyEmergencyAdmin() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isEmergencyAdmin(_msgSender()), Errors.ACL_ONLY_EMERGENCY_ADMIN_CAN_CALL);\n        _;\n    }\n\n    /**\n     * @dev functions marked by this modifier can be executed only when the specific reserve exists.\n     **/\n    modifier checkReserveExists(uint256 reserveId) {\n        require(_exists(reserveId), Errors.RESERVE_DOES_NOT_EXIST);\n        _;\n    }\n\n    /**\n     * @dev Pause pool for emergency case, can only be called by emergency admin.\n     **/\n    function pause() external onlyEmergencyAdmin {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause pool for emergency case, can only be called by emergency admin.\n     **/\n    function unpause() external onlyEmergencyAdmin {\n        _unpause();\n    }\n\n    /**\n     * @dev Check if specific reserve exists.\n     **/\n    function _exists(uint256 reserveId) internal view returns (bool) {\n        return reserves[reserveId].reserveId > 0;\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function create(\n        address underlyingAsset,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) external override onlyPoolAdmin {\n        _reserveIdTracker.increment();\n        uint256 reserveId = _reserveIdTracker.current();\n        address oTokenAddress = IOpenSkyReserveVaultFactory(SETTINGS.vaultFactoryAddress()).create(\n            reserveId,\n            name,\n            symbol,\n            decimals,\n            underlyingAsset\n        );\n        reserves[reserveId] = DataTypes.ReserveData({\n            reserveId: reserveId,\n            underlyingAsset: underlyingAsset,\n            oTokenAddress: oTokenAddress,\n            moneyMarketAddress: SETTINGS.moneyMarketAddress(),\n            lastSupplyIndex: uint128(WadRayMath.RAY),\n            borrowingInterestPerSecond: 0,\n            lastMoneyMarketBalance: 0,\n            lastUpdateTimestamp: 0,\n            totalBorrows: 0,\n            interestModelAddress: SETTINGS.interestRateStrategyAddress(),\n            treasuryFactor: SETTINGS.reserveFactor(),\n            isMoneyMarketOn: true\n        });\n        emit Create(reserveId, underlyingAsset, oTokenAddress, name, symbol, decimals);\n    }\n\n    function claimERC20Rewards(uint256 reserveId, address token) external onlyPoolAdmin {\n        IOpenSkyOToken(reserves[reserveId].oTokenAddress).claimERC20Rewards(token);\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function setTreasuryFactor(uint256 reserveId, uint256 factor)\n        external\n        override\n        checkReserveExists(reserveId)\n        onlyPoolAdmin\n    {\n        require(factor <= SETTINGS.MAX_RESERVE_FACTOR(), Errors.RESERVE_TREASURY_FACTOR_NOT_ALLOWED);\n        reserves[reserveId].treasuryFactor = factor;\n        emit SetTreasuryFactor(reserveId, factor);\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function setInterestModelAddress(uint256 reserveId, address interestModelAddress)\n        external\n        override\n        checkReserveExists(reserveId)\n        onlyPoolAdmin\n    {\n        reserves[reserveId].interestModelAddress = interestModelAddress;\n        emit SetInterestModelAddress(reserveId, interestModelAddress);\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function openMoneyMarket(uint256 reserveId) external override checkReserveExists(reserveId) onlyEmergencyAdmin {\n        require(!reserves[reserveId].isMoneyMarketOn, Errors.RESERVE_SWITCH_MONEY_MARKET_STATE_ERROR);\n        reserves[reserveId].openMoneyMarket();\n        emit OpenMoneyMarket(reserveId);\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function closeMoneyMarket(uint256 reserveId) external override checkReserveExists(reserveId) onlyEmergencyAdmin {\n        require(reserves[reserveId].isMoneyMarketOn, Errors.RESERVE_SWITCH_MONEY_MARKET_STATE_ERROR);\n        reserves[reserveId].closeMoneyMarket();\n        emit CloseMoneyMarket(reserveId);\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function deposit(uint256 reserveId, uint256 amount, address onBehalfOf, uint256 referralCode)\n        external\n        virtual\n        override\n        whenNotPaused\n        nonReentrant\n        checkReserveExists(reserveId)\n    {\n        require(amount > 0, Errors.DEPOSIT_AMOUNT_SHOULD_BE_BIGGER_THAN_ZERO);\n        reserves[reserveId].deposit(_msgSender(), amount, onBehalfOf);\n        emit Deposit(reserveId, onBehalfOf, amount, referralCode);\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function withdraw(uint256 reserveId, uint256 amount, address onBehalfOf)\n        external\n        virtual\n        override\n        whenNotPaused\n        nonReentrant\n        checkReserveExists(reserveId)\n    {\n        address oTokenAddress = reserves[reserveId].oTokenAddress;\n        uint256 userBalance = IOpenSkyOToken(oTokenAddress).balanceOf(_msgSender());\n\n        uint256 amountToWithdraw = amount;\n        if (amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n\n        require(amountToWithdraw > 0 && amountToWithdraw <= userBalance, Errors.WITHDRAW_AMOUNT_NOT_ALLOWED);\n        require(getAvailableLiquidity(reserveId) >= amountToWithdraw, Errors.WITHDRAW_LIQUIDITY_NOT_SUFFICIENT);\n\n        reserves[reserveId].withdraw(_msgSender(), amountToWithdraw, onBehalfOf);\n        emit Withdraw(reserveId, onBehalfOf, amountToWithdraw);\n    }\n\n    struct BorrowLocalParams {\n        uint256 borrowLimit;\n        uint256 availableLiquidity;\n        uint256 amountToBorrow;\n        uint256 borrowRate;\n        address loanAddress;\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function borrow(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        address nftAddress,\n        uint256 tokenId,\n        address onBehalfOf\n    ) external virtual override whenNotPaused nonReentrant checkReserveExists(reserveId) returns (uint256) {\n        _validateWhitelist(reserveId, nftAddress, duration);\n\n        BorrowLocalParams memory vars;\n        vars.borrowLimit = getBorrowLimitByOracle(reserveId, nftAddress, tokenId);\n        vars.availableLiquidity = getAvailableLiquidity(reserveId);\n\n        vars.amountToBorrow = amount;\n\n        if (amount == type(uint256).max) {\n            vars.amountToBorrow = (\n                vars.borrowLimit < vars.availableLiquidity ? vars.borrowLimit : vars.availableLiquidity\n            );\n        }\n\n        require(vars.borrowLimit >= vars.amountToBorrow, Errors.BORROW_AMOUNT_EXCEED_BORROW_LIMIT);\n        require(vars.availableLiquidity >= vars.amountToBorrow, Errors.RESERVE_LIQUIDITY_INSUFFICIENT);\n\n        vars.loanAddress = SETTINGS.loanAddress();\n        IERC721(nftAddress).safeTransferFrom(_msgSender(), vars.loanAddress, tokenId);\n\n        vars.borrowRate = reserves[reserveId].getBorrowRate(0, 0, vars.amountToBorrow, 0);\n        (uint256 loanId, DataTypes.LoanData memory loan) = IOpenSkyLoan(vars.loanAddress).mint(\n            reserveId,\n            onBehalfOf,\n            nftAddress,\n            tokenId,\n            vars.amountToBorrow,\n            duration,\n            vars.borrowRate\n        );\n        reserves[reserveId].borrow(loan);\n\n        emit Borrow(\n            reserveId,\n            _msgSender(),\n            onBehalfOf,\n            loanId\n        );\n\n        return loanId;\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function repay(uint256 loanId) external virtual override whenNotPaused nonReentrant returns (uint256 repayAmount) {\n        address loanAddress = SETTINGS.loanAddress();\n        address onBehalfOf = IERC721(loanAddress).ownerOf(loanId);\n\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(loanAddress);\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n\n        require(\n            loanData.status == DataTypes.LoanStatus.BORROWING ||\n                loanData.status == DataTypes.LoanStatus.EXTENDABLE ||\n                loanData.status == DataTypes.LoanStatus.OVERDUE,\n            Errors.REPAY_STATUS_ERROR\n        );\n\n        uint256 penalty = loanNFT.getPenalty(loanId);\n        uint256 borrowBalance = loanNFT.getBorrowBalance(loanId);\n        repayAmount = borrowBalance + penalty;\n\n        uint256 reserveId = loanData.reserveId;\n        require(_exists(reserveId), Errors.RESERVE_DOES_NOT_EXIST);\n\n        reserves[reserveId].repay(loanData, repayAmount, borrowBalance);\n\n        loanNFT.end(loanId, onBehalfOf, _msgSender());\n\n        address nftReceiver = SETTINGS.punkGatewayAddress() == _msgSender() ? _msgSender() : onBehalfOf;\n        IERC721(loanData.nftAddress).safeTransferFrom(address(loanNFT), nftReceiver, loanData.tokenId);\n\n        emit Repay(reserveId, _msgSender(), nftReceiver, loanId, repayAmount, penalty);\n    }\n\n    struct ExtendLocalParams {\n        uint256 borrowInterestOfOldLoan;\n        uint256 needInAmount;\n        uint256 needOutAmount;\n        uint256 penalty;\n        uint256 fee;\n        uint256 borrowLimit;\n        uint256 availableLiquidity;\n        uint256 amountToExtend;\n        uint256 newBorrowRate;\n        DataTypes.LoanData oldLoan;\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function extend(\n        uint256 oldLoanId,\n        uint256 amount,\n        uint256 duration,\n        address onBehalfOf\n    ) external override whenNotPaused nonReentrant returns (uint256, uint256) {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        if (_msgSender() == SETTINGS.wethGatewayAddress()) {\n            require(loanNFT.ownerOf(oldLoanId) == onBehalfOf, Errors.LOAN_CALLER_IS_NOT_OWNER);\n        } else {\n            require(loanNFT.ownerOf(oldLoanId) == _msgSender(), Errors.LOAN_CALLER_IS_NOT_OWNER);\n            onBehalfOf = _msgSender();\n        }\n\n        ExtendLocalParams memory vars;\n        vars.oldLoan = loanNFT.getLoanData(oldLoanId);\n\n        require(\n            vars.oldLoan.status == DataTypes.LoanStatus.EXTENDABLE || vars.oldLoan.status == DataTypes.LoanStatus.OVERDUE,\n            Errors.EXTEND_STATUS_ERROR\n        );\n\n        _validateWhitelist(vars.oldLoan.reserveId, vars.oldLoan.nftAddress, duration);\n\n        vars.borrowLimit = getBorrowLimitByOracle(vars.oldLoan.reserveId, vars.oldLoan.nftAddress, vars.oldLoan.tokenId);\n\n        vars.amountToExtend = amount;\n        if (amount == type(uint256).max) {\n            vars.amountToExtend = vars.borrowLimit; // no need to check availableLiquidity here\n        }\n\n        require(vars.borrowLimit >= vars.amountToExtend, Errors.BORROW_AMOUNT_EXCEED_BORROW_LIMIT);\n\n        // calculate needInAmount and needOutAmount \n        vars.borrowInterestOfOldLoan = loanNFT.getBorrowInterest(oldLoanId);\n        vars.penalty = loanNFT.getPenalty(oldLoanId);\n        vars.fee = vars.borrowInterestOfOldLoan + vars.penalty;\n        if (vars.oldLoan.amount <= vars.amountToExtend) {\n            uint256 extendAmount = vars.amountToExtend - vars.oldLoan.amount;\n            if (extendAmount < vars.fee) {\n                vars.needInAmount = vars.fee - extendAmount;\n            } else {\n                vars.needOutAmount = extendAmount - vars.fee;\n            }\n        } else {\n            vars.needInAmount = vars.oldLoan.amount - vars.amountToExtend + vars.fee;\n        }\n\n        // check availableLiquidity\n        if (vars.needOutAmount > 0) {\n            vars.availableLiquidity = getAvailableLiquidity(vars.oldLoan.reserveId);\n            require(vars.availableLiquidity >= vars.needOutAmount, Errors.RESERVE_LIQUIDITY_INSUFFICIENT);\n        }\n\n        // end old loan\n        loanNFT.end(oldLoanId, onBehalfOf, onBehalfOf);\n\n        vars.newBorrowRate = reserves[vars.oldLoan.reserveId].getBorrowRate(\n            vars.penalty,\n            0,\n            vars.amountToExtend,\n            vars.oldLoan.amount + vars.borrowInterestOfOldLoan\n        );\n\n        // create new loan\n        (uint256 loanId, DataTypes.LoanData memory newLoan) = loanNFT.mint(\n            vars.oldLoan.reserveId,\n            onBehalfOf,\n            vars.oldLoan.nftAddress,\n            vars.oldLoan.tokenId,\n            vars.amountToExtend,\n            duration,\n            vars.newBorrowRate\n        );\n\n        // update reserve state\n        reserves[vars.oldLoan.reserveId].extend(\n            vars.oldLoan,\n            newLoan,\n            vars.borrowInterestOfOldLoan,\n            vars.needInAmount,\n            vars.needOutAmount,\n            vars.penalty\n        );\n\n        emit Extend(vars.oldLoan.reserveId, onBehalfOf, oldLoanId, loanId);\n\n        return (vars.needInAmount, vars.needOutAmount);\n    }\n\n    function _validateWhitelist(uint256 reserveId, address nftAddress, uint256 duration) internal view {\n        require(SETTINGS.inWhitelist(reserveId, nftAddress), Errors.NFT_ADDRESS_IS_NOT_IN_WHITELIST);\n\n        DataTypes.WhitelistInfo memory whitelistInfo = SETTINGS.getWhitelistDetail(reserveId, nftAddress);\n        require(\n            duration >= whitelistInfo.minBorrowDuration && duration <= whitelistInfo.maxBorrowDuration,\n            Errors.BORROW_DURATION_NOT_ALLOWED\n        );\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function startLiquidation(uint256 loanId) external override whenNotPaused onlyLiquidator {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n        require(loanData.status == DataTypes.LoanStatus.LIQUIDATABLE, Errors.START_LIQUIDATION_STATUS_ERROR);\n\n        reserves[loanData.reserveId].startLiquidation(loanData);\n\n        IERC721(loanData.nftAddress).safeTransferFrom(address(loanNFT), _msgSender(), loanData.tokenId);\n        loanNFT.startLiquidation(loanId);\n\n        emit StartLiquidation(loanData.reserveId, loanId, loanData.nftAddress, loanData.tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function endLiquidation(uint256 loanId, uint256 amount) external override whenNotPaused onlyLiquidator {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n        require(loanData.status == DataTypes.LoanStatus.LIQUIDATING, Errors.END_LIQUIDATION_STATUS_ERROR);\n\n        // repay money\n        uint256 borrowBalance = loanNFT.getBorrowBalance(loanId);\n\n        require(amount >= borrowBalance, Errors.END_LIQUIDATION_AMOUNT_ERROR);\n        reserves[loanData.reserveId].endLiquidation(amount, borrowBalance);\n\n        loanNFT.endLiquidation(loanId);\n\n        emit EndLiquidation(\n            loanData.reserveId,\n            loanId,\n            loanData.nftAddress,\n            loanData.tokenId,\n            _msgSender(),\n            amount,\n            borrowBalance\n        );\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function getReserveData(uint256 reserveId)\n        external\n        view\n        override\n        checkReserveExists(reserveId)\n        returns (DataTypes.ReserveData memory)\n    {\n        return reserves[reserveId];\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function getReserveNormalizedIncome(uint256 reserveId)\n        external\n        view\n        virtual\n        override\n        checkReserveExists(reserveId)\n        returns (uint256)\n    {\n        return reserves[reserveId].getNormalizedIncome();\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function getAvailableLiquidity(uint256 reserveId)\n        public\n        view\n        override\n        checkReserveExists(reserveId)\n        returns (uint256)\n    {\n        return reserves[reserveId].getMoneyMarketBalance();\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function getBorrowLimitByOracle(\n        uint256 reserveId,\n        address nftAddress,\n        uint256 tokenId\n    ) public view virtual override returns (uint256) {\n        return\n            IOpenSkyCollateralPriceOracle(SETTINGS.nftPriceOracleAddress())\n                .getPrice(reserveId, nftAddress, tokenId)\n                .percentMul(SETTINGS.getWhitelistDetail(reserveId, nftAddress).LTV);\n    }\n    \n    /// @inheritdoc IOpenSkyPool\n    function getTotalBorrowBalance(uint256 reserveId) external view override returns (uint256) {\n        return reserves[reserveId].getTotalBorrowBalance();\n    }\n\n    /// @inheritdoc IOpenSkyPool\n    function getTVL(uint256 reserveId) external view override checkReserveExists(reserveId) returns (uint256) {\n        return reserves[reserveId].getTVL();\n    }\n\n    receive() external payable {\n        revert(Errors.RECEIVE_NOT_ALLOWED);\n    }\n\n    fallback() external payable {\n        revert(Errors.FALLBACK_NOT_ALLOWED);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyCollateralPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @title IOpenSkyPriceOracle\n * @author OpenSky Labs\n * @notice Defines the basic interface for a price oracle.\n **/\ninterface IOpenSkyCollateralPriceOracle {\n    /**\n     * @dev Emitted on setPriceAggregator()\n     * @param operator The address of the operator\n     * @param priceAggregator The new price aggregator address\n     **/\n    event SetPriceAggregator(address indexed operator, address priceAggregator);\n\n    /**\n     * @dev Emitted on setRoundInterval()\n     * @param operator The address of the operator\n     * @param roundInterval The round interval\n     **/\n    event SetRoundInterval(address indexed operator, uint256 roundInterval);\n\n    /**\n     * @dev Emitted on setTimeInterval()\n     * @param operator The address of the operator\n     * @param timeInterval The time interval\n     **/\n    event SetTimeInterval(address indexed operator, uint256 timeInterval);\n\n    /**\n     * @dev Emitted on updatePrice()\n     * @param nftAddress The address of the NFT\n     * @param price The price of the NFT\n     * @param timestamp The timestamp when the price happened\n     * @param roundId The round id\n     **/\n    event UpdatePrice(address indexed nftAddress, uint256 price, uint256 timestamp, uint256 roundId);\n\n    /**\n     * @notice Sets round interval that is used for calculating TWAP price\n     * @param roundInterval The round interval will be set\n     **/\n    function setRoundInterval(uint256 roundInterval) external;\n\n    /**\n     * @notice Sets time interval that is used for calculating TWAP price\n     * @param timeInterval The time interval will be set\n     **/\n    function setTimeInterval(uint256 timeInterval) external;\n\n    /**\n     * @notice Returns the NFT price in ETH\n     * @param reserveId The id of the reserve\n     * @param nftAddress The address of the NFT\n     * @param tokenId The id of the NFT\n     * @return The price of the NFT\n     **/\n    function getPrice(\n        uint256 reserveId,\n        address nftAddress,\n        uint256 tokenId\n    ) external view returns (uint256);\n\n    /**\n     * @notice Updates the floor price of the NFT collection\n     * @param nftAddress The address of the NFT\n     * @param price The price of the NFT\n     * @param timestamp The timestamp when the price happened\n     **/\n    function updatePrice(\n        address nftAddress,\n        uint256 price,\n        uint256 timestamp\n    ) external;\n}\n"
    },
    "contracts/interfaces/IOpenSkyReserveVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyReserveVaultFactory {\n    event Create(uint256 indexed reserveId, string name, string symbol, uint8 decimals, address indexed underlyingAsset);\n\n    function create(\n        uint256 reserveId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address underlyingAsset\n    ) external returns (address oTokenAddress);\n}\n"
    },
    "contracts/interfaces/IOpenSkyNFTDescriptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyNFTDescriptor {\n    function tokenURI(uint256 reserveId)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IACLManager {\n    function addEmergencyAdmin(address admin) external;\n    \n    function isEmergencyAdmin(address admin) external view returns (bool);\n    \n    function removeEmergencyAdmin(address admin) external;\n    \n    function addGovernance(address admin) external;\n    \n    function isGovernance(address admin) external view returns (bool);\n\n    function removeGovernance(address admin) external;\n\n    function addPoolAdmin(address admin) external;\n\n    function isPoolAdmin(address admin) external view returns (bool);\n\n    function removePoolAdmin(address admin) external;\n\n    function addLiquidationOperator(address address_) external;\n\n    function isLiquidationOperator(address address_) external view returns (bool);\n\n    function removeLiquidationOperator(address address_) external;\n\n    function addAirdropOperator(address address_) external;\n\n    function isAirdropOperator(address address_) external view returns (bool);\n\n    function removeAirdropOperator(address address_) external;\n}\n"
    },
    "contracts/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {WadRayMath} from './WadRayMath.sol';\n\nlibrary MathUtils {\n    using WadRayMath for uint256;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /**\n     * @dev Function to calculate the interest accumulated using a linear interest rate formula\n     * @param rate The interest rate, in ray\n     * @param lastUpdateTimestamp The timestamp of the last update of the interest\n     * @return The interest rate linearly accumulated during the timeDelta, in ray\n     **/\n\n    function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) external view returns (uint256) {\n        //solium-disable-next-line\n        uint256 timeDifference = block.timestamp - (uint256(lastUpdateTimestamp));\n\n        return (rate * timeDifference) / SECONDS_PER_YEAR + WadRayMath.ray();\n    }\n\n    function calculateBorrowInterest(\n        uint256 borrowRate,\n        uint256 amount,\n        uint256 duration\n    ) external pure returns (uint256) {\n        return amount.rayMul(borrowRate.rayMul(duration).rayDiv(SECONDS_PER_YEAR));\n    }\n\n    function calculateBorrowInterestPerSecond(uint256 borrowRate, uint256 amount) external pure returns (uint256) {\n        return amount.rayMul(borrowRate).rayDiv(SECONDS_PER_YEAR);\n    }\n\n    function calculateLoanSupplyRate(\n        uint256 availableLiquidity,\n        uint256 totalBorrows,\n        uint256 borrowRate\n    ) external pure returns (uint256 loanSupplyRate, uint256 utilizationRate) {\n        utilizationRate = (totalBorrows == 0 && availableLiquidity == 0)\n            ? 0\n            : totalBorrows.rayDiv(availableLiquidity + totalBorrows);\n        loanSupplyRate = utilizationRate.rayMul(borrowRate);\n    }\n}\n"
    },
    "contracts/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../helpers/Errors.sol';\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded half up\n **/\n\nlibrary PercentageMath {\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n  /**\n   * @dev Executes a percentage multiplication\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return The percentage of value\n   **/\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\n    if (value == 0 || percentage == 0) {\n      return 0;\n    }\n\n    require(\n      value <= (type(uint256).max - HALF_PERCENT) / percentage,\n      Errors.MATH_MULTIPLICATION_OVERFLOW\n    );\n\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\n  }\n\n  /**\n   * @dev Executes a percentage division\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return The value divided the percentage\n   **/\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\n    uint256 halfPercentage = percentage / 2;\n\n    require(\n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\n      Errors.MATH_MULTIPLICATION_OVERFLOW\n    );\n\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\n  }\n}\n"
    },
    "contracts/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary Errors {\n    // common\n    string public constant MATH_MULTIPLICATION_OVERFLOW = '100';\n    string public constant MATH_ADDITION_OVERFLOW = '101';\n    string public constant MATH_DIVISION_BY_ZERO = '102';\n\n    string public constant ETH_TRANSFER_FAILED = '110';\n    string public constant RECEIVE_NOT_ALLOWED = '111';\n    string public constant FALLBACK_NOT_ALLOWED = '112';\n    string public constant APPROVAL_FAILED = '113';\n\n    // setting/factor\n    string public constant SETTING_ZERO_ADDRESS_NOT_ALLOWED = '115';\n    string public constant SETTING_RESERVE_FACTOR_NOT_ALLOWED = '116';\n    string public constant SETTING_WHITELIST_INVALID_RESERVE_ID = '117';\n    string public constant SETTING_WHITELIST_NFT_ADDRESS_IS_ZERO = '118';\n    string public constant SETTING_WHITELIST_NFT_DURATION_OUT_OF_ORDER = '119';\n    string public constant SETTING_WHITELIST_NFT_NAME_EMPTY = '120';\n    string public constant SETTING_WHITELIST_NFT_SYMBOL_EMPTY = '121';\n    string public constant SETTING_WHITELIST_NFT_LTV_NOT_ALLOWED = '122';\n\n    // settings/acl\n    string public constant ACL_ONLY_GOVERNANCE_CAN_CALL = '200';\n    string public constant ACL_ONLY_EMERGENCY_ADMIN_CAN_CALL = '201';\n    string public constant ACL_ONLY_POOL_ADMIN_CAN_CALL = '202';\n    string public constant ACL_ONLY_LIQUIDATOR_CAN_CALL = '203';\n    string public constant ACL_ONLY_AIRDROP_OPERATOR_CAN_CALL = '204';\n    string public constant ACL_ONLY_POOL_CAN_CALL = '205';\n\n    // lending & borrowing\n    // reserve\n    string public constant RESERVE_DOES_NOT_EXIST = '300';\n    string public constant RESERVE_LIQUIDITY_INSUFFICIENT = '301';\n    string public constant RESERVE_INDEX_OVERFLOW = '302';\n    string public constant RESERVE_SWITCH_MONEY_MARKET_STATE_ERROR = '303';\n    string public constant RESERVE_TREASURY_FACTOR_NOT_ALLOWED = '304';\n    string public constant RESERVE_TOKEN_CAN_NOT_BE_CLAIMED = '305';\n\n    // token\n    string public constant AMOUNT_SCALED_IS_ZERO = '310';\n    string public constant AMOUNT_TRANSFER_OVERFLOW = '311';\n\n    //deposit\n    string public constant DEPOSIT_AMOUNT_SHOULD_BE_BIGGER_THAN_ZERO = '320';\n\n    // withdraw\n    string public constant WITHDRAW_AMOUNT_NOT_ALLOWED = '321';\n    string public constant WITHDRAW_LIQUIDITY_NOT_SUFFICIENT = '322';\n\n    // borrow\n    string public constant BORROW_DURATION_NOT_ALLOWED = '330';\n    string public constant BORROW_AMOUNT_EXCEED_BORROW_LIMIT = '331';\n    string public constant NFT_ADDRESS_IS_NOT_IN_WHITELIST = '332';\n\n    // repay\n    string public constant REPAY_STATUS_ERROR = '333';\n    string public constant REPAY_MSG_VALUE_ERROR = '334';\n\n    // extend\n    string public constant EXTEND_STATUS_ERROR = '335';\n    string public constant EXTEND_MSG_VALUE_ERROR = '336';\n\n    // liquidate\n    string public constant START_LIQUIDATION_STATUS_ERROR = '360';\n    string public constant END_LIQUIDATION_STATUS_ERROR = '361';\n    string public constant END_LIQUIDATION_AMOUNT_ERROR = '362';\n\n    // loan\n    string public constant LOAN_DOES_NOT_EXIST = '400';\n    string public constant LOAN_SET_STATUS_ERROR = '401';\n    string public constant LOAN_REPAYER_IS_NOT_OWNER = '402';\n    string public constant LOAN_LIQUIDATING_STATUS_CAN_NOT_BE_UPDATED = '403';\n    string public constant LOAN_CALLER_IS_NOT_OWNER = '404';\n    string public constant LOAN_COLLATERAL_NFT_CAN_NOT_BE_CLAIMED = '405';\n\n    string public constant FLASHCLAIM_EXECUTOR_ERROR = '410';\n    string public constant FLASHCLAIM_STATUS_ERROR = '411';\n\n    // money market\n    string public constant MONEY_MARKET_DEPOSIT_AMOUNT_NOT_ALLOWED = '500';\n    string public constant MONEY_MARKET_WITHDRAW_AMOUNT_NOT_ALLOWED = '501';\n    string public constant MONEY_MARKET_APPROVAL_FAILED = '502';\n    string public constant MONEY_MARKET_DELEGATE_CALL_ERROR = '503';\n    string public constant MONEY_MARKET_REQUIRE_DELEGATE_CALL = '504';\n    string public constant MONEY_MARKET_WITHDRAW_AMOUNT_NOT_MATCH = '505';\n\n    // price oracle\n    string public constant PRICE_ORACLE_HAS_NO_PRICE_FEED = '600';\n    string public constant PRICE_ORACLE_INCORRECT_TIMESTAMP = '601';\n    string public constant PRICE_ORACLE_PARAMS_ERROR = '602';\n}\n"
    },
    "contracts/libraries/ReserveLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport './types/DataTypes.sol';\nimport './helpers/Errors.sol';\nimport './math/WadRayMath.sol';\nimport './math/PercentageMath.sol';\n\nimport '../interfaces/IOpenSkyInterestRateStrategy.sol';\nimport '../interfaces/IOpenSkyOToken.sol';\nimport '../interfaces/IOpenSkyMoneyMarket.sol';\n\n/**\n * @title ReserveLogic library\n * @author OpenSky Labs\n * @notice Implements the logic to update the reserves state\n */\nlibrary ReserveLogic {\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Implements the deposit feature.\n     * @param sender The address that called deposit function\n     * @param amount The amount of deposit\n     * @param onBehalfOf The address that will receive otokens\n     **/\n    function deposit(\n        DataTypes.ReserveData storage reserve,\n        address sender,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        updateState(reserve, 0);\n\n        updateLastMoneyMarketBalance(reserve, amount, 0);\n\n        IOpenSkyOToken oToken = IOpenSkyOToken(reserve.oTokenAddress);\n        oToken.mint(onBehalfOf, amount, reserve.lastSupplyIndex);\n\n        IERC20(reserve.underlyingAsset).safeTransferFrom(sender, reserve.oTokenAddress, amount);\n        oToken.deposit(amount);\n    }\n\n    /**\n     * @dev Implements the withdrawal feature.\n     * @param sender The address that called withdraw function\n     * @param amount The withdrawal amount\n     * @param onBehalfOf The address that will receive token\n     **/\n    function withdraw(\n        DataTypes.ReserveData storage reserve,\n        address sender,\n        uint256 amount,\n        address onBehalfOf\n    ) external {\n        updateState(reserve, 0);\n\n        updateLastMoneyMarketBalance(reserve, 0, amount);\n\n        IOpenSkyOToken oToken = IOpenSkyOToken(reserve.oTokenAddress);\n        oToken.burn(sender, amount, reserve.lastSupplyIndex);\n        oToken.withdraw(amount, onBehalfOf);\n    }\n\n    /**\n     * @dev Implements the borrow feature.\n     * @param loan the loan data\n     **/\n    function borrow(DataTypes.ReserveData storage reserve, DataTypes.LoanData memory loan) external {\n        updateState(reserve, 0);\n        updateInterestPerSecond(reserve, loan.interestPerSecond, 0);\n        updateLastMoneyMarketBalance(reserve, 0, loan.amount);\n\n        IOpenSkyOToken oToken = IOpenSkyOToken(reserve.oTokenAddress);\n        oToken.withdraw(loan.amount, msg.sender);\n\n        reserve.totalBorrows = reserve.totalBorrows + loan.amount;\n    }\n\n    /**\n     * @dev Implements the repay function.\n     * @param loan The loan data\n     * @param amount The amount that will be repaid, including penalty\n     * @param borrowBalance The borrow balance\n     **/\n    function repay(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.LoanData memory loan,\n        uint256 amount,\n        uint256 borrowBalance\n    ) external {\n        updateState(reserve, amount - borrowBalance);\n        updateInterestPerSecond(reserve, 0, loan.interestPerSecond);\n        updateLastMoneyMarketBalance(reserve, amount, 0);\n\n        IOpenSkyOToken oToken = IOpenSkyOToken(reserve.oTokenAddress);\n\n        IERC20(reserve.underlyingAsset).safeTransferFrom(msg.sender, reserve.oTokenAddress, amount);\n        oToken.deposit(amount);\n\n        reserve.totalBorrows = reserve.totalBorrows > borrowBalance ? reserve.totalBorrows - borrowBalance : 0;\n    }\n\n    /**\n     * @dev Implements the extend feature.\n     * @param oldLoan The data of old loan\n     * @param newLoan The data of new loan\n     * @param borrowInterestOfOldLoan The borrow interest of old loan\n     * @param inAmount The amount of token that will be deposited\n     * @param outAmount The amount of token that will be withdrawn\n     * @param additionalIncome The additional income\n     **/\n    function extend(\n        DataTypes.ReserveData storage reserve,\n        DataTypes.LoanData memory oldLoan,\n        DataTypes.LoanData memory newLoan,\n        uint256 borrowInterestOfOldLoan,\n        uint256 inAmount,\n        uint256 outAmount,\n        uint256 additionalIncome\n    ) external {\n        updateState(reserve, additionalIncome);\n        updateInterestPerSecond(reserve, newLoan.interestPerSecond, oldLoan.interestPerSecond);\n        updateLastMoneyMarketBalance(reserve, inAmount, outAmount);\n\n        IOpenSkyOToken oToken = IOpenSkyOToken(reserve.oTokenAddress);\n        if (inAmount > 0) {\n            IERC20(reserve.underlyingAsset).safeTransferFrom(msg.sender, reserve.oTokenAddress, inAmount);\n            oToken.deposit(inAmount);\n        }\n        if (outAmount > 0) oToken.withdraw(outAmount, msg.sender);\n\n        uint256 sum1 = reserve.totalBorrows + newLoan.amount;\n        uint256 sum2 = oldLoan.amount + borrowInterestOfOldLoan;\n        reserve.totalBorrows = sum1 > sum2 ? sum1 - sum2 : 0;\n    }\n\n    /**\n     * @dev Implements start liquidation mechanism.\n     * @param loan Loan data\n     **/\n    function startLiquidation(DataTypes.ReserveData storage reserve, DataTypes.LoanData memory loan) external {\n        updateState(reserve, 0);\n        updateLastMoneyMarketBalance(reserve, 0, 0);\n        updateInterestPerSecond(reserve, 0, loan.interestPerSecond);\n    }\n\n    /**\n     * @dev Implements end liquidation mechanism.\n     * @param amount The amount of token paid\n     * @param borrowBalance The borrow balance of loan\n     **/\n    function endLiquidation(\n        DataTypes.ReserveData storage reserve,\n        uint256 amount,\n        uint256 borrowBalance\n    ) external {\n        updateState(reserve, amount - borrowBalance);\n        updateLastMoneyMarketBalance(reserve, amount, 0);\n\n        IERC20(reserve.underlyingAsset).safeTransferFrom(msg.sender, reserve.oTokenAddress, amount);\n        IOpenSkyOToken oToken = IOpenSkyOToken(reserve.oTokenAddress);\n        oToken.deposit(amount);\n\n        reserve.totalBorrows = reserve.totalBorrows > borrowBalance ? reserve.totalBorrows - borrowBalance : 0;\n    }\n\n    /**\n     * @dev Updates the liquidity cumulative index and total borrows\n     * @param reserve The reserve object\n     * @param additionalIncome The additional income\n     **/\n    function updateState(DataTypes.ReserveData storage reserve, uint256 additionalIncome) internal {\n        (\n            uint256 newIndex,\n            ,\n            uint256 treasuryIncome,\n            uint256 borrowingInterestDelta,\n\n        ) = calculateIncome(reserve, additionalIncome);\n\n        require(newIndex <= type(uint128).max, Errors.RESERVE_INDEX_OVERFLOW);\n        reserve.lastSupplyIndex = uint128(newIndex);\n\n        // treasury\n        treasuryIncome = treasuryIncome / WadRayMath.ray();\n        if (treasuryIncome > 0) {\n            IOpenSkyOToken(reserve.oTokenAddress).mintToTreasury(treasuryIncome, reserve.lastSupplyIndex);\n        }\n\n        reserve.totalBorrows = reserve.totalBorrows + borrowingInterestDelta / WadRayMath.ray();\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    /**\n     * @dev Updates the interest per second, when borrowing and repaying\n     * @param reserve The reserve object\n     * @param amountToAdd The amount to be added\n     * @param amountToRemove The amount to be subtracted\n     **/\n    function updateInterestPerSecond(\n        DataTypes.ReserveData storage reserve,\n        uint256 amountToAdd,\n        uint256 amountToRemove\n    ) internal {\n        reserve.borrowingInterestPerSecond = reserve.borrowingInterestPerSecond + amountToAdd - amountToRemove;\n    }\n\n    /**\n     * @dev Updates last money market balance, after updating the liquidity cumulative index.\n     * @param reserve The reserve object\n     * @param amountToAdd The amount to be added\n     * @param amountToRemove The amount to be subtracted\n     **/\n    function updateLastMoneyMarketBalance(\n        DataTypes.ReserveData storage reserve,\n        uint256 amountToAdd,\n        uint256 amountToRemove\n    ) internal {\n        uint256 moneyMarketBalance = getMoneyMarketBalance(reserve);\n        reserve.lastMoneyMarketBalance = moneyMarketBalance + amountToAdd - amountToRemove;\n    }\n\n    function openMoneyMarket(\n        DataTypes.ReserveData storage reserve\n    ) internal {\n        reserve.isMoneyMarketOn = true;\n\n        uint256 amount = IERC20(reserve.underlyingAsset).balanceOf(reserve.oTokenAddress);\n        IOpenSkyOToken(reserve.oTokenAddress).deposit(amount);\n    }\n\n    function closeMoneyMarket(\n        DataTypes.ReserveData storage reserve\n    ) internal {\n        address oTokenAddress = reserve.oTokenAddress;\n        uint256 amount = IOpenSkyMoneyMarket(reserve.moneyMarketAddress).getBalance(reserve.underlyingAsset, oTokenAddress);\n        IOpenSkyOToken(oTokenAddress).withdraw(amount, oTokenAddress);\n\n        reserve.isMoneyMarketOn = false;\n    }\n\n    /**\n     * @dev Updates last money market balance, after updating the liquidity cumulative index.\n     * @param reserve The reserve object\n     * @param additionalIncome The amount to be added\n     * @return newIndex The new liquidity cumulative index from the last update\n     * @return usersIncome The user's income from the last update\n     * @return treasuryIncome The treasury income from the last update\n     * @return borrowingInterestDelta The treasury income from the last update\n     * @return moneyMarketDelta The money market income from the last update\n     **/\n    function calculateIncome(DataTypes.ReserveData memory reserve, uint256 additionalIncome)\n        internal\n        view\n        returns (\n            uint256 newIndex,\n            uint256 usersIncome,\n            uint256 treasuryIncome,\n            uint256 borrowingInterestDelta,\n            uint256 moneyMarketDelta\n        )\n    {\n        moneyMarketDelta = getMoneyMarketDelta(reserve) * WadRayMath.ray();\n        borrowingInterestDelta = getBorrowingInterestDelta(reserve);\n        // ray\n        uint256 totalIncome = additionalIncome * WadRayMath.ray() + moneyMarketDelta + borrowingInterestDelta;\n        treasuryIncome = totalIncome.percentMul(reserve.treasuryFactor);\n        usersIncome = totalIncome - treasuryIncome;\n\n        // index\n        newIndex = reserve.lastSupplyIndex;\n        uint256 scaledTotalSupply = IOpenSkyOToken(reserve.oTokenAddress).scaledTotalSupply();\n        if (scaledTotalSupply > 0) {\n            newIndex = usersIncome / scaledTotalSupply + reserve.lastSupplyIndex;\n        }\n\n        return (newIndex, usersIncome, treasuryIncome, borrowingInterestDelta, moneyMarketDelta);\n    }\n\n    /**\n     * @dev Returns the ongoing normalized income for the reserve\n     * A value of 1e27 means there is no income. As time passes, the income is accrued\n     * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n     * @param reserve The reserve object\n     * @return The normalized income. expressed in ray\n     **/\n    function getNormalizedIncome(DataTypes.ReserveData storage reserve) external view returns (uint256) {\n        (uint256 newIndex, , , , ) = calculateIncome(reserve, 0);\n        return newIndex;\n    }\n\n    /**\n     * @dev Returns the available liquidity of the reserve\n     * @param reserve The reserve object\n     * @return The available liquidity\n     **/\n    function getMoneyMarketBalance(DataTypes.ReserveData memory reserve) internal view returns (uint256) {\n        if (reserve.isMoneyMarketOn) {\n            return IOpenSkyMoneyMarket(reserve.moneyMarketAddress).getBalance(reserve.underlyingAsset, reserve.oTokenAddress);\n        } else {\n            return IERC20(reserve.underlyingAsset).balanceOf(reserve.oTokenAddress);\n        }\n    }\n\n    /**\n     * @dev Returns the money market income of the reserve from the last update\n     * @param reserve The reserve object\n     * @return The income from money market\n     **/\n    function getMoneyMarketDelta(DataTypes.ReserveData memory reserve) internal view returns (uint256) {\n        uint256 timeDelta = block.timestamp - reserve.lastUpdateTimestamp;\n\n        if (timeDelta == 0) return 0;\n\n        if (reserve.lastMoneyMarketBalance == 0) return 0;\n\n        // get MoneyMarketBalance\n        uint256 currentMoneyMarketBalance = getMoneyMarketBalance(reserve);\n        if (currentMoneyMarketBalance < reserve.lastMoneyMarketBalance) return 0;\n\n        return currentMoneyMarketBalance - reserve.lastMoneyMarketBalance;\n    }\n\n    /**\n     * @dev Returns the borrow interest income of the reserve from the last update\n     * @param reserve The reserve object\n     * @return The income from the NFT loan\n     **/\n    function getBorrowingInterestDelta(DataTypes.ReserveData memory reserve) internal view returns (uint256) {\n        uint256 timeDelta = uint256(block.timestamp) - reserve.lastUpdateTimestamp;\n        if (timeDelta == 0) return 0;\n        return reserve.borrowingInterestPerSecond * timeDelta;\n    }\n\n    /**\n     * @dev Returns the total borrow balance of the reserve\n     * @param reserve The reserve object\n     * @return The total borrow balance\n     **/\n    function getTotalBorrowBalance(DataTypes.ReserveData memory reserve) public view returns (uint256) {\n        return reserve.totalBorrows + getBorrowingInterestDelta(reserve) / WadRayMath.ray();\n    }\n\n    /**\n     * @dev Returns the total value locked (TVL) of the reserve\n     * @param reserve The reserve object\n     * @return The total value locked (TVL)\n     **/\n    function getTVL(DataTypes.ReserveData memory reserve) external view returns (uint256) {\n        (, , uint256 treasuryIncome, , ) = calculateIncome(reserve, 0);\n        return treasuryIncome / WadRayMath.RAY + IOpenSkyOToken(reserve.oTokenAddress).totalSupply();\n    }\n\n    /**\n     * @dev Returns the borrow rate of the reserve\n     * @param reserve The reserve object\n     * @param liquidityAmountToAdd The liquidity amount will be added\n     * @param liquidityAmountToRemove The liquidity amount will be removed\n     * @param borrowAmountToAdd The borrow amount will be added\n     * @param borrowAmountToRemove The borrow amount will be removed\n     * @return The borrow rate\n     **/\n    function getBorrowRate(\n        DataTypes.ReserveData memory reserve,\n        uint256 liquidityAmountToAdd,\n        uint256 liquidityAmountToRemove,\n        uint256 borrowAmountToAdd,\n        uint256 borrowAmountToRemove\n    ) external view returns (uint256) {\n        uint256 liquidity = getMoneyMarketBalance(reserve);\n        uint256 totalBorrowBalance = getTotalBorrowBalance(reserve);\n        return\n            IOpenSkyInterestRateStrategy(reserve.interestModelAddress).getBorrowRate(\n                reserve.reserveId,\n                liquidity + totalBorrowBalance + liquidityAmountToAdd - liquidityAmountToRemove,\n                totalBorrowBalance + borrowAmountToAdd - borrowAmountToRemove\n            );\n    }\n}\n"
    },
    "contracts/libraries/math/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {Errors} from '../helpers/Errors.sol';\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n **/\n\nlibrary WadRayMath {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant halfWAD = WAD / 2;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant halfRAY = RAY / 2;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @return One ray, 1e27\n     **/\n    function ray() internal pure returns (uint256) {\n        return RAY;\n    }\n\n    /**\n     * @return One wad, 1e18\n     **/\n\n    function wad() internal pure returns (uint256) {\n        return WAD;\n    }\n\n    /**\n     * @return Half ray, 1e27/2\n     **/\n    function halfRay() internal pure returns (uint256) {\n        return halfRAY;\n    }\n\n    /**\n     * @return Half ray, 1e18/2\n     **/\n    function halfWad() internal pure returns (uint256) {\n        return halfWAD;\n    }\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @param a Wad\n     * @param b Wad\n     * @return The result of a*b, in wad\n     **/\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n\n        require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n        return (a * b + halfWAD) / WAD;\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @param a Wad\n     * @param b Wad\n     * @return The result of a/b, in wad\n     **/\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n        uint256 halfB = b / 2;\n\n        require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n        return (a * WAD + halfB) / b;\n    }\n\n    /**\n     * @dev Multiplies two ray, rounding half up to the nearest ray\n     * @param a Ray\n     * @param b Ray\n     * @return The result of a*b, in ray\n     **/\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n\n        require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n        return (a * b + halfRAY) / RAY;\n    }\n\n    /**\n     * @dev Multiplies two ray, truncating the mantissa\n     * @param a Ray\n     * @param b Ray\n     * @return The result of a*b, in ray\n     **/\n    function rayMulTruncate(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        return (a * b) / RAY;\n    }\n\n    /**\n     * @dev Divides two ray, rounding half up to the nearest ray\n     * @param a Ray\n     * @param b Ray\n     * @return The result of a/b, in ray\n     **/\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n        uint256 halfB = b / 2;\n\n        require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n        return (a * RAY + halfB) / b;\n    }\n\n    /**\n     * @dev Divides two ray, truncating the mantissa\n     * @param a Ray\n     * @param b Ray\n     * @return The result of a/b, in ray\n     **/\n    function rayDivTruncate(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n        return (a * RAY) / b;\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @param a Ray\n     * @return a casted to wad, rounded half up to the nearest wad\n     **/\n    function rayToWad(uint256 a) internal pure returns (uint256) {\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\n        uint256 result = halfRatio + a;\n        require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\n\n        return result / WAD_RAY_RATIO;\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @param a Wad\n     * @return a converted in ray\n     **/\n    function wadToRay(uint256 a) internal pure returns (uint256) {\n        uint256 result = a * WAD_RAY_RATIO;\n        require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @title IOpenSkyInterestRateStrategy\n * @author OpenSky Labs\n * @notice Interface for the calculation of the interest rates\n */\ninterface IOpenSkyInterestRateStrategy {\n    /**\n     * @dev Emitted on setBaseBorrowRate()\n     * @param reserveId The id of the reserve\n     * @param baseRate The base rate has been set\n     **/\n    event SetBaseBorrowRate(\n        uint256 indexed reserveId,\n        uint256 indexed baseRate\n    );\n\n    /**\n     * @notice Returns the borrow rate of a reserve\n     * @param reserveId The id of the reserve\n     * @param totalDeposits The total deposits amount of the reserve\n     * @param totalBorrows The total borrows amount of the reserve\n     * @return The borrow rate, expressed in ray\n     **/\n    function getBorrowRate(uint256 reserveId, uint256 totalDeposits, uint256 totalBorrows) external view returns (uint256); \n}\n"
    },
    "contracts/interfaces/IOpenSkyOToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IOpenSkyOToken is IERC20 {\n    event Mint(address indexed account, uint256 amount, uint256 index);\n    event Burn(address indexed account, uint256 amount, uint256 index);\n    event MintToTreasury(address treasury, uint256 amount, uint256 index);\n    event Deposit(uint256 amount);\n    event Withdraw(uint256 amount);\n\n    function mint(\n        address account,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    function burn(\n        address account,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    function mintToTreasury(uint256 amount, uint256 index) external;\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount, address to) external;\n\n    function scaledBalanceOf(address account) external view returns (uint256);\n\n    function principleBalanceOf(address account) external view returns (uint256);\n\n    function scaledTotalSupply() external view returns (uint256);\n\n    function principleTotalSupply() external view returns (uint256);\n\n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n    function claimERC20Rewards(address token) external;\n}\n"
    },
    "contracts/interfaces/IOpenSkyMoneyMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyMoneyMarket {\n\n    function depositCall(address asset, uint256 amount) external;\n\n    function withdrawCall(address asset, uint256 amount, address to) external;\n\n    function getMoneyMarketToken(address asset) external view returns (address);\n\n    function getBalance(address asset, address account) external view returns (uint256);\n\n    function getSupplyRate(address asset) external view returns (uint256);\n\n}\n"
    },
    "contracts/OpenSkyOToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\n\nimport './libraries/math/WadRayMath.sol';\n\nimport './interfaces/IOpenSkySettings.sol';\nimport './interfaces/IOpenSkyOToken.sol';\nimport './interfaces/IOpenSkyPool.sol';\nimport './interfaces/IOpenSkyIncentivesController.sol';\nimport './interfaces/IOpenSkyMoneyMarket.sol';\n\ncontract OpenSkyOToken is Context, ERC20Permit, ERC20Burnable, ERC721Holder, IOpenSkyOToken {\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IOpenSkySettings public immutable SETTINGS;\n\n    address internal immutable _pool;\n    uint256 internal immutable _reserveId;\n    address internal immutable _underlyingAsset;\n\n    uint8 private _decimals;\n\n    modifier onlyPool() {\n        require(_msgSender() == address(_pool), Errors.ACL_ONLY_POOL_CAN_CALL);\n        _;\n    }\n\n    constructor(\n        address pool,\n        uint256 reserveId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address underlyingAsset,\n        address settings\n    ) ERC20(name, symbol) ERC20Permit(symbol) {\n        _decimals = decimals;\n        _pool = pool;\n        _reserveId = reserveId;\n        _underlyingAsset = underlyingAsset;\n        SETTINGS = IOpenSkySettings(settings);\n    }\n\n    // The decimals of the token. Override ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    function _treasury() internal view returns (address) {\n        return SETTINGS.daoVaultAddress();\n    }\n\n    function mint(\n        address account,\n        uint256 amount,\n        uint256 index\n    ) external virtual override onlyPool {\n        uint256 amountScaled = amount.rayDiv(index);\n        require(amountScaled != 0, Errors.AMOUNT_SCALED_IS_ZERO);\n\n        _mint(account, amountScaled);\n        emit Mint(account, amount, index);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual override {\n        uint256 previousBalance = super.balanceOf(account);\n        uint256 previousTotalSupply = super.totalSupply();\n\n        super._mint(account, amount);\n\n        address incentiveControllerAddress = SETTINGS.incentiveControllerAddress();\n        if (incentiveControllerAddress != address(0)) {\n            IOpenSkyIncentivesController(incentiveControllerAddress).handleAction(\n                account,\n                previousBalance,\n                previousTotalSupply\n            );\n        }\n    }\n\n    function burn(\n        address account,\n        uint256 amount,\n        uint256 index\n    ) external virtual override onlyPool {\n        uint256 amountScaled = amount.rayDiv(index);\n        require(amountScaled != 0, Errors.AMOUNT_SCALED_IS_ZERO);\n\n        _burn(account, amountScaled);\n        emit Burn(account, amount, index);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual override {\n        uint256 previousBalance = super.balanceOf(account);\n        uint256 previousTotalSupply = super.totalSupply();\n\n        super._burn(account, amount);\n\n        address incentiveControllerAddress = SETTINGS.incentiveControllerAddress();\n        if (incentiveControllerAddress != address(0)) {\n            IOpenSkyIncentivesController(incentiveControllerAddress).handleAction(\n                account,\n                previousBalance,\n                previousTotalSupply\n            );\n        }\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        uint256 index = IOpenSkyPool(_pool).getReserveNormalizedIncome(_reserveId);\n\n        uint256 amountScaled = amount.rayDiv(index);\n        require(amountScaled != 0, Errors.AMOUNT_SCALED_IS_ZERO);\n        require(amountScaled <= type(uint128).max, Errors.AMOUNT_TRANSFER_OVERFLOW);\n\n        uint256 previousSenderBalance = super.balanceOf(sender);\n        uint256 previousRecipientBalance = super.balanceOf(recipient);\n\n        super._transfer(sender, recipient, amountScaled);\n\n        address incentiveControllerAddress = SETTINGS.incentiveControllerAddress();\n        if (incentiveControllerAddress != address(0)) {\n            uint256 currentTotalSupply = super.totalSupply();\n            IOpenSkyIncentivesController(incentiveControllerAddress).handleAction(\n                sender,\n                previousSenderBalance,\n                currentTotalSupply\n            );\n            if (sender != recipient) {\n                IOpenSkyIncentivesController(incentiveControllerAddress).handleAction(\n                    recipient,\n                    previousRecipientBalance,\n                    currentTotalSupply\n                );\n            }\n        }\n    }\n\n    function mintToTreasury(uint256 amount, uint256 index) external override onlyPool {\n        if (amount == 0) {\n            return;\n        }\n        _mint(_treasury(), amount.rayDiv(index));\n        emit MintToTreasury(_treasury(), amount, index);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    event Received(address, uint256);\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    // called only by pool\n    function deposit(uint256 amount) external override onlyPool {\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(_pool).getReserveData(_reserveId);\n\n        if (reserve.isMoneyMarketOn) {\n            (bool success, ) = address(reserve.moneyMarketAddress).delegatecall(\n                abi.encodeWithSignature('depositCall(address,uint256)', _underlyingAsset, amount)\n            );\n            require(success, Errors.MONEY_MARKET_DELEGATE_CALL_ERROR);\n        }\n        emit Deposit(amount);\n    }\n\n    function withdraw(uint256 amount, address to) external override onlyPool {\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(_pool).getReserveData(_reserveId);\n\n        if (reserve.isMoneyMarketOn) {\n            (bool success, ) = address(reserve.moneyMarketAddress).delegatecall(\n                abi.encodeWithSignature('withdrawCall(address,uint256,address)', _underlyingAsset, amount, to)\n            );\n            require(success, Errors.MONEY_MARKET_DELEGATE_CALL_ERROR);\n        } else {\n            IERC20(_underlyingAsset).safeTransfer(to, amount);\n        }\n        emit Withdraw(amount);\n    }\n\n    function balanceOf(address account) public view override(ERC20, IERC20) returns (uint256) {\n        uint256 index = IOpenSkyPool(_pool).getReserveNormalizedIncome(_reserveId);\n        return super.balanceOf(account).rayMul(index);\n    }\n\n    function scaledBalanceOf(address account) external view override returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    function principleBalanceOf(address account) external view override returns (uint256) {\n        uint256 currentBalanceScaled = super.balanceOf(account);\n        uint256 lastSupplyIndex = IOpenSkyPool(_pool).getReserveData(_reserveId).lastSupplyIndex;\n        return currentBalanceScaled.rayMul(lastSupplyIndex);\n    }\n\n    function totalSupply() public view override(ERC20, IERC20) returns (uint256) {\n        uint256 currentSupplyScaled = super.totalSupply();\n\n        if (currentSupplyScaled == 0) {\n            return 0;\n        }\n\n        return currentSupplyScaled.rayMul(IOpenSkyPool(_pool).getReserveNormalizedIncome(_reserveId));\n    }\n\n    function scaledTotalSupply() external view virtual override returns (uint256) {\n        return super.totalSupply();\n    }\n\n    function principleTotalSupply() external view virtual override returns (uint256) {\n        uint256 currentSupplyScaled = super.totalSupply();\n        uint256 lastSupplyIndex = IOpenSkyPool(_pool).getReserveData(_reserveId).lastSupplyIndex;\n        return currentSupplyScaled.rayMul(lastSupplyIndex);\n    }\n\n    /**\n     * @dev Returns the scaled balance of the user and the scaled total supply.\n     * @param user The address of the user\n     * @return The scaled balance of the user\n     * @return The scaled balance and the scaled total supply\n     **/\n    function getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n        return (super.balanceOf(user), super.totalSupply());\n    }\n\n    function claimERC20Rewards(address token) external override onlyPool {\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(_pool).getReserveData(_reserveId);\n        require(\n            token != IOpenSkyMoneyMarket(reserve.moneyMarketAddress).getMoneyMarketToken(_underlyingAsset) &&\n                token != _underlyingAsset,\n            Errors.RESERVE_TOKEN_CAN_NOT_BE_CLAIMED\n        );\n        IERC20(token).safeTransfer(_treasury(), IERC20(token).balanceOf(address(this)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\ninterface IOpenSkyIncentivesController {\n    function handleAction(\n        address account,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) external;\n\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to,\n        bool stake\n    ) external returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/OpenSkyReserveVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport './interfaces/IOpenSkySettings.sol';\nimport './interfaces/IOpenSkyReserveVaultFactory.sol';\nimport './OpenSkyOToken.sol';\nimport './libraries/helpers/Errors.sol';\n\ncontract OpenSkyReserveVaultFactory is IOpenSkyReserveVaultFactory {\n    IOpenSkySettings public immutable SETTINGS;\n\n    modifier onlyPool() {\n        require(msg.sender == SETTINGS.poolAddress(), Errors.ACL_ONLY_POOL_CAN_CALL);\n        _;\n    }\n\n    constructor(address _settings) {\n        SETTINGS = IOpenSkySettings(_settings);\n    }\n\n    function create(\n        uint256 reserveId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address underlyingAsset\n    ) external override onlyPool returns (address oTokenAddress) {\n        oTokenAddress = address(\n            new OpenSkyOToken(msg.sender, reserveId, name, symbol, decimals, underlyingAsset, address(SETTINGS))\n        );\n        emit Create(reserveId, name, symbol, decimals,underlyingAsset);\n    }\n}\n"
    },
    "contracts/OpenSkyCollateralPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './interfaces/IOpenSkyCollateralPriceOracle.sol';\nimport './interfaces/IOpenSkySettings.sol';\nimport './libraries/helpers/Errors.sol';\nimport './interfaces/IOpenSkyPriceAggregator.sol';\n\n/**\n * @title OpenSkyCollateralPriceOracle contract\n * @author OpenSky Labs\n * @dev Implements logics of the collateral price oracle for the OpenSky protocol\n **/\ncontract OpenSkyCollateralPriceOracle is Ownable, IOpenSkyCollateralPriceOracle {\n    IOpenSkySettings public immutable SETTINGS;\n\n    mapping(address => NFTPriceData[]) public nftPriceFeedMap;\n\n    IOpenSkyPriceAggregator private _priceAggregator;\n\n    uint256 internal _roundInterval;\n    uint256 internal _timeInterval;\n\n    struct NFTPriceData {\n        uint256 roundId;\n        uint256 price;\n        uint256 timestamp;\n        uint256 cumulativePrice;\n    }\n\n    constructor(IOpenSkySettings settings, IOpenSkyPriceAggregator priceAggregator) Ownable() {\n        SETTINGS = settings;\n        _priceAggregator = priceAggregator;\n    }\n\n    function setPriceAggregator(address priceAggregator) external onlyOwner {\n        _priceAggregator = IOpenSkyPriceAggregator(priceAggregator);\n        emit SetPriceAggregator(_msgSender(), priceAggregator);\n    }\n\n    /// @inheritdoc IOpenSkyCollateralPriceOracle\n    function updatePrice(\n        address nftAddress,\n        uint256 price,\n        uint256 timestamp\n    ) public override onlyOwner {\n        NFTPriceData[] storage prices = nftPriceFeedMap[nftAddress];\n        NFTPriceData memory latestPriceData = prices.length > 0\n            ? prices[prices.length - 1]\n            : NFTPriceData({roundId: 0, price: 0, timestamp: 0, cumulativePrice: 0});\n        require(timestamp > latestPriceData.timestamp, Errors.PRICE_ORACLE_INCORRECT_TIMESTAMP);\n        uint256 cumulativePrice = latestPriceData.timestamp > 0\n            ? latestPriceData.cumulativePrice + (timestamp - latestPriceData.timestamp) * latestPriceData.price\n            : 0;\n        uint256 roundId = latestPriceData.roundId + 1;\n        NFTPriceData memory data = NFTPriceData({\n            price: price,\n            timestamp: timestamp,\n            roundId: roundId,\n            cumulativePrice: cumulativePrice\n        });\n        prices.push(data);\n\n        emit UpdatePrice(nftAddress, price, timestamp, roundId);\n    }\n\n    /**\n     * @notice Updates floor prices of NFT collections\n     * @param nftAddresses Addresses of NFT collections\n     * @param prices Floor prices of NFT collections\n     * @param timestamp The timestamp when prices happened\n     **/\n    function updatePrices(\n        address[] memory nftAddresses,\n        uint256[] memory prices,\n        uint256 timestamp\n    ) external onlyOwner {\n        require(nftAddresses.length == prices.length, Errors.PRICE_ORACLE_PARAMS_ERROR);\n        for (uint256 i = 0; i < nftAddresses.length; i++) {\n            updatePrice(nftAddresses[i], prices[i], timestamp);\n        }\n    }\n\n    /// @inheritdoc IOpenSkyCollateralPriceOracle\n    function setRoundInterval(uint256 roundInterval) external override onlyOwner {\n        _roundInterval = roundInterval;\n        emit SetRoundInterval(_msgSender(), roundInterval);\n    }\n\n    /// @inheritdoc IOpenSkyCollateralPriceOracle\n    function setTimeInterval(uint256 timeInterval) external override onlyOwner {\n        _timeInterval = timeInterval;\n        emit SetTimeInterval(_msgSender(), timeInterval);\n    }\n\n    /// @inheritdoc IOpenSkyCollateralPriceOracle\n    function getPrice(\n        uint256 reserveId,\n        address nftAddress,\n        uint256 tokenId\n    ) external view override returns (uint256) {\n        if (!SETTINGS.inWhitelist(reserveId, nftAddress)) {\n            return 0;\n        }\n        if (address(_priceAggregator) == address(0)) {\n            return _getPrice(nftAddress);\n        } else {\n            uint256 price = _priceAggregator.getAssetPrice(nftAddress);\n            return price > 0 ? price : _getPrice(nftAddress);\n        }\n    }\n\n    function _getPrice(address nftAddress) internal view returns (uint256) {\n        if (_timeInterval > 0) {\n            return getTwapPriceByTimeInterval(nftAddress, _timeInterval);\n        } else {\n            return getTwapPriceByRoundInterval(nftAddress, _roundInterval);\n        }\n    }\n\n    /**\n     * @notice Returns the TWAP price of NFT during the particular round interval\n     * @param nftAddress The address of the NFT\n     * @param roundInterval The round interval\n     * @return The price of the NFT\n     **/\n    function getTwapPriceByRoundInterval(address nftAddress, uint256 roundInterval) public view returns (uint256) {\n        uint256 priceFeedLength = getPriceFeedLength(nftAddress);\n        if (priceFeedLength == 0) {\n            return 0;\n        }\n        uint256 currentRound = priceFeedLength - 1;\n        NFTPriceData memory currentPriceData = nftPriceFeedMap[nftAddress][currentRound];\n        if (roundInterval == 0 || priceFeedLength == 1) {\n            return currentPriceData.price;\n        }\n        uint256 previousRound = currentRound > roundInterval ? currentRound - roundInterval : 0;\n        NFTPriceData memory previousPriceData = nftPriceFeedMap[nftAddress][previousRound];\n        return\n            (currentPriceData.price *\n                (block.timestamp - currentPriceData.timestamp) +\n                currentPriceData.cumulativePrice -\n                previousPriceData.cumulativePrice) / (block.timestamp - previousPriceData.timestamp);\n    }\n\n    /**\n     * @notice Returns the TWAP price of NFT during the particular time interval\n     * @param nftAddress The address of the NFT\n     * @param timeInterval The time interval\n     * @return The price of the NFT\n     **/\n    function getTwapPriceByTimeInterval(address nftAddress, uint256 timeInterval) public view returns (uint256) {\n        uint256 priceFeedLength = getPriceFeedLength(nftAddress);\n        if (priceFeedLength == 0) {\n            return 0;\n        }\n\n        NFTPriceData memory currentPriceData = nftPriceFeedMap[nftAddress][priceFeedLength - 1];\n        uint256 baseTimestamp = block.timestamp - timeInterval;\n\n        if (currentPriceData.timestamp <= baseTimestamp) {\n            return currentPriceData.price;\n        }\n\n        NFTPriceData memory firstPriceData = nftPriceFeedMap[nftAddress][0];\n        if (firstPriceData.timestamp >= baseTimestamp) {\n            return\n                (currentPriceData.price *\n                    (block.timestamp - currentPriceData.timestamp) +\n                    (currentPriceData.cumulativePrice - firstPriceData.cumulativePrice)) /\n                (block.timestamp - firstPriceData.timestamp);\n        }\n\n        uint256 roundIndex = priceFeedLength - 1;\n        NFTPriceData storage basePriceData = nftPriceFeedMap[nftAddress][roundIndex];\n\n        while (roundIndex > 0 && basePriceData.timestamp > baseTimestamp) {\n            basePriceData = nftPriceFeedMap[nftAddress][--roundIndex];\n        }\n\n        uint256 cumulativePrice = currentPriceData.price *\n            (block.timestamp - currentPriceData.timestamp) +\n            (currentPriceData.cumulativePrice - basePriceData.cumulativePrice);\n        cumulativePrice -= basePriceData.price * (baseTimestamp - basePriceData.timestamp);\n        return cumulativePrice / timeInterval;\n    }\n\n    /**\n     * @notice Returns the data of the particular price feed\n     * @param nftAddress The address of the NFT\n     * @param index The index of the feed\n     * @return The data of the price feed\n     **/\n    function getPriceData(address nftAddress, uint256 index) external view returns (NFTPriceData memory) {\n        return nftPriceFeedMap[nftAddress][index];\n    }\n\n    /**\n     * @notice Returns the count of price feeds about the particular NFT\n     * @param nftAddress The address of the NFT\n     * @return length The count of price feeds\n     **/\n    function getPriceFeedLength(address nftAddress) public view returns (uint256 length) {\n        return nftPriceFeedMap[nftAddress].length;\n    }\n\n    /**\n     * @notice Returns the latest round id of the particular NFT\n     * @param nftAddress The address of the NFT\n     * @return The latest round id\n     **/\n    function getLatestRoundId(address nftAddress) external view returns (uint256) {\n        uint256 len = getPriceFeedLength(nftAddress);\n        if (len == 0) {\n            return 0;\n        }\n        return nftPriceFeedMap[nftAddress][len - 1].roundId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyPriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyPriceAggregator {\n    event SetAggregator(address indexed asset, address indexed aggregator);\n\n    function getAssetPrice(address nftAddress) external view returns (uint256);\n}\n"
    },
    "contracts/OpenSkyPriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport './interfaces/IOpenSkyPriceAggregator.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n}\n\n/**\n * @title OpenSkyPriceAggregator Contract\n * @author OpenSky Labs\n * @notice Proxy smart contract to get the price of a nft from a price aggregator, with Chainlink Aggregator\n *         smart contracts as primary option\n * - Owned by the OpenSky governance system, allowed to add aggregators for nfts, replace them\n **/\ncontract OpenSkyPriceAggregator is IOpenSkyPriceAggregator, Ownable {\n    mapping (address => AggregatorInterface) public aggregators;\n\n    constructor() Ownable() {}\n\n    /**\n     * @notice External function called by the OpenSky governance to set or replace price aggregators of assets\n     * @param assets The addresses of the assets\n     * @param _aggregators The address of the source of each asset\n     **/\n    function setAggregators(address[] memory assets, AggregatorInterface[] memory _aggregators) public onlyOwner {\n        require(assets.length == _aggregators.length, 'INCONSISTENT_PARAMS_LENGTH');\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(address(_aggregators[i]) != address(0), 'AGGREGATOR_CAN_NOT_BE_ZERO_ADDRESS');\n            _setAggregator(assets[i], _aggregators[i]);\n        }\n    }\n\n    /**\n     * @notice Internal function to set the sources for each asset\n     * @param asset The address of the nft collection address\n     * @param aggregator The address of the aggregator\n     **/\n    function _setAggregator(address asset, AggregatorInterface aggregator) internal {\n        aggregators[asset] = aggregator;\n        emit SetAggregator(asset, address(aggregator));\n    }\n\n    /**\n     * @notice Gets the nft floor price by address\n     * @param asset The nft collection address\n    **/\n    function getAssetPrice(address asset) external view override returns (uint256) {\n        if (address(aggregators[asset]) == address(0)) {\n            return 0;\n        }\n        return uint256(aggregators[asset].latestAnswer());\n    }\n}\n"
    },
    "contracts/OpenSkyInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './interfaces/IOpenSkyInterestRateStrategy.sol';\nimport './libraries/math/WadRayMath.sol';\nimport './libraries/math/PercentageMath.sol';\n\n/**\n * @title OpenSkyInterestRateStrategy contract\n * @author OpenSky Labs\n * @notice Implements the calculation of the interest rates depending on the reserve state\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE`\n * point of usage and another from that one to 100%.\n **/\ncontract OpenSkyInterestRateStrategy is IOpenSkyInterestRateStrategy, Ownable {\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n\n    uint256 public immutable OPTIMAL_UTILIZATION_RATE; \n    uint256 public immutable EXCESS_UTILIZATION_RATE; \n\n    // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 internal immutable _rateSlope1;\n\n    // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n    uint256 internal immutable _rateSlope2;\n\n    uint256 internal immutable _baseBorrowRate;\n\n    mapping(uint256 => uint256) internal _baseBorrowRates;\n    \n    constructor(\n        uint256 optimalUtilizationRate,\n        uint256 rateSlope1_,\n        uint256 rateSlope2_,\n        uint256 baseBorrowRate\n    ) Ownable() {\n        OPTIMAL_UTILIZATION_RATE = optimalUtilizationRate;\n        EXCESS_UTILIZATION_RATE = WadRayMath.ray() - optimalUtilizationRate;\n        _rateSlope1 = rateSlope1_;\n        _rateSlope2 = rateSlope2_;\n        _baseBorrowRate = baseBorrowRate;\n    }\n\n    function rateSlope1() external view returns (uint256) {\n        return _rateSlope1;\n    }\n\n    function rateSlope2() external view returns (uint256) {\n        return _rateSlope2;\n    }\n\n    /**\n     * @notice Sets the base borrow rate of a reserve\n     * @param reserveId The id of the reserve\n     * @param rate The rate to be set\n     **/\n    function setBaseBorrowRate(uint256 reserveId, uint256 rate) external onlyOwner {\n        _baseBorrowRates[reserveId] = rate;\n        emit SetBaseBorrowRate(reserveId, rate);\n    }\n\n    /**\n     * @notice Returns the base borrow rate of a reserve\n     * @param reserveId The id of the reserve\n     * @return The borrow rate, expressed in ray\n     **/\n    function getBaseBorrowRate(uint256 reserveId) public view returns (uint256) {\n        return _baseBorrowRates[reserveId] > 0 ? _baseBorrowRates[reserveId] : _baseBorrowRate;\n    }\n\n    /// @inheritdoc IOpenSkyInterestRateStrategy\n    function getBorrowRate(uint256 reserveId, uint256 totalDeposits, uint256 totalBorrows) external override view returns (uint256) {\n        uint256 utilizationRate = totalBorrows == 0 ? 0 : totalBorrows.rayDiv(totalDeposits);\n        uint256 currentBorrowRate = 0;\n        uint256 baseBorrowRate = getBaseBorrowRate(reserveId);\n        if (utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n            uint256 excessUtilizationRateRatio = (utilizationRate - OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE);\n            currentBorrowRate = baseBorrowRate + _rateSlope1 + _rateSlope2.rayMul(excessUtilizationRateRatio);\n        } else {\n            currentBorrowRate = baseBorrowRate + _rateSlope1.rayMul(utilizationRate).rayDiv(OPTIMAL_UTILIZATION_RATE);\n        }\n        return currentBorrowRate;\n    }\n}\n"
    },
    "contracts/OpenSkyLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\n\nimport '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Counters.sol';\nimport './interfaces/IOpenSkyFlashClaimReceiver.sol';\nimport './interfaces/IOpenSkyLoan.sol';\nimport './interfaces/IOpenSkySettings.sol';\nimport './interfaces/IACLManager.sol';\nimport './interfaces/IOpenSkyNFTDescriptor.sol';\nimport './libraries/types/DataTypes.sol';\nimport './libraries/math/WadRayMath.sol';\nimport './libraries/math/MathUtils.sol';\nimport './libraries/math/PercentageMath.sol';\nimport './libraries/helpers/Errors.sol';\nimport './interfaces/IOpenSkyIncentivesController.sol';\n\n/**\n * @title OpenSkyLoan contract\n * @author OpenSky Labs\n * @notice Implementation of the loan NFT for the OpenSky protocol\n * @dev The functions about handling loan are callable by the OpenSkyPool contract defined also in the OpenSkySettings\n **/\ncontract OpenSkyLoan is Context, ERC721Enumerable, Ownable, ERC721Holder, ERC1155Holder, ReentrancyGuard, IOpenSkyLoan {\n    using Counters for Counters.Counter;\n    using PercentageMath for uint256;\n    using SafeERC20 for IERC20;\n    using WadRayMath for uint128;\n\n\n    mapping(uint256 => DataTypes.LoanData) internal _loans;\n\n    /// @inheritdoc IOpenSkyLoan\n    mapping(address => mapping(uint256 => uint256)) public override getLoanId;\n\n    uint256 public totalBorrows;\n\n    mapping(address => uint256) public userBorrows;\n\n    Counters.Counter private _tokenIdTracker;\n    IOpenSkySettings public immutable SETTINGS;\n    \n    address internal _pool;\n\n    modifier onlyPool(){\n        require(_msgSender() == _pool, Errors.ACL_ONLY_POOL_CAN_CALL);\n        _;\n    }\n\n    modifier onlyAirdropOperator() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isAirdropOperator(_msgSender()), Errors.ACL_ONLY_AIRDROP_OPERATOR_CAN_CALL);\n        _;\n    }\n\n    modifier checkLoanExists(uint256 loanId) {\n        require(_exists(loanId), Errors.LOAN_DOES_NOT_EXIST);\n        _;\n    }\n    \n    /**\n     * @dev Constructor.\n     * @param name The name of OpenSkyLoan NFT\n     * @param symbol The symbol of OpenSkyLoan NFT\n     * @param _settings The address of the OpenSkySettings contract\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _settings,\n        address pool\n    ) Ownable() ERC721(name, symbol) ReentrancyGuard() {\n        SETTINGS = IOpenSkySettings(_settings);\n        _pool = pool;\n    }\n\n    struct BorrowLocalVars {\n        uint40 borrowBegin;\n        uint40 overdueTime;\n        uint40 liquidatableTime;\n        uint40 extendableTime;\n        uint256 interestPerSecond;\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function mint(\n        uint256 reserveId,\n        address borrower,\n        address nftAddress,\n        uint256 nftTokenId,\n        uint256 amount,\n        uint256 duration,\n        uint256 borrowRate\n    ) external override onlyPool returns (uint256 loanId, DataTypes.LoanData memory loan) {\n        DataTypes.WhitelistInfo memory whitelistInfo = SETTINGS.getWhitelistDetail(reserveId, nftAddress);\n        BorrowLocalVars memory vars;\n\n        vars.borrowBegin = uint40(block.timestamp);\n        vars.overdueTime = uint40(block.timestamp + duration);\n        vars.liquidatableTime = uint40(block.timestamp + duration + whitelistInfo.overdueDuration);\n        // add setting config\n        vars.extendableTime = uint40(block.timestamp + duration - whitelistInfo.extendableDuration);\n\n        vars.interestPerSecond = MathUtils.calculateBorrowInterestPerSecond(borrowRate, amount);\n\n        loan = DataTypes.LoanData({\n            reserveId: reserveId,\n            nftAddress: nftAddress,\n            tokenId: nftTokenId,\n            borrower: borrower,\n            amount: amount,\n            borrowBegin: vars.borrowBegin,\n            borrowDuration: uint40(duration),\n            borrowOverdueTime: vars.overdueTime,\n            liquidatableTime: vars.liquidatableTime,\n            borrowRate: uint128(borrowRate),\n            interestPerSecond: uint128(vars.interestPerSecond),\n            extendableTime: vars.extendableTime,\n            borrowEnd: 0,\n            status: DataTypes.LoanStatus.BORROWING\n        });\n        loanId = _mint(loan, borrower);\n        IERC721(loan.nftAddress).approve(_pool, loan.tokenId);\n\n        getLoanId[nftAddress][nftTokenId] = loanId;\n        emit Mint(loanId, borrower);\n    }\n\n    function _mint(DataTypes.LoanData memory loanData, address recipient) internal returns (uint256 tokenId) {\n        _tokenIdTracker.increment();\n        tokenId = _tokenIdTracker.current();\n        _safeMint(recipient, tokenId);\n        _loans[tokenId] = loanData;\n\n        _triggerIncentive(loanData.borrower);\n\n        totalBorrows = totalBorrows + loanData.amount;\n        userBorrows[loanData.borrower] = userBorrows[loanData.borrower] + loanData.amount;\n    }\n\n    function _triggerIncentive(address borrower) internal {\n        address incentiveControllerAddress = SETTINGS.incentiveControllerAddress();\n        if (incentiveControllerAddress != address(0)) {\n            IOpenSkyIncentivesController incentivesController = IOpenSkyIncentivesController(\n                incentiveControllerAddress\n            );\n            incentivesController.handleAction(borrower, userBorrows[borrower], totalBorrows);\n        }\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function startLiquidation(uint256 tokenId) external override onlyPool checkLoanExists(tokenId) {\n        _updateStatus(tokenId, DataTypes.LoanStatus.LIQUIDATING);\n        _loans[tokenId].borrowEnd = uint40(block.timestamp);\n\n        address owner = ownerOf(tokenId);\n        _triggerIncentive(owner);\n\n        userBorrows[owner] = userBorrows[owner] - _loans[tokenId].amount;\n        totalBorrows = totalBorrows - _loans[tokenId].amount;\n\n        emit StartLiquidation(tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function endLiquidation(uint256 tokenId) external override onlyPool checkLoanExists(tokenId) {\n        _burn(tokenId);\n\n        delete getLoanId[_loans[tokenId].nftAddress][_loans[tokenId].tokenId];\n        delete _loans[tokenId];\n\n        emit EndLiquidation(tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function end(\n        uint256 tokenId,\n        address onBehalfOf,\n        address repayer\n    ) external override onlyPool checkLoanExists(tokenId) {\n        require(ownerOf(tokenId) == onBehalfOf, Errors.LOAN_REPAYER_IS_NOT_OWNER);\n\n        if (_loans[tokenId].status != DataTypes.LoanStatus.LIQUIDATING) {\n            address owner = ownerOf(tokenId);\n            _triggerIncentive(owner);\n\n            userBorrows[owner] = userBorrows[owner] - _loans[tokenId].amount;\n            totalBorrows = totalBorrows - _loans[tokenId].amount;\n        }\n\n        _burn(tokenId);\n\n        delete getLoanId[_loans[tokenId].nftAddress][_loans[tokenId].tokenId];\n        delete _loans[tokenId];\n\n        emit End(tokenId, onBehalfOf, repayer);\n    }\n\n    /**\n     * @notice Updates the status of a loan.\n     * @param tokenId The id of the loan\n     * @param status The status of the loan will be set\n     **/\n    function _updateStatus(uint256 tokenId, DataTypes.LoanStatus status) internal {\n        DataTypes.LoanData storage loanData = _loans[tokenId];\n        require(loanData.status != DataTypes.LoanStatus.LIQUIDATING, Errors.LOAN_LIQUIDATING_STATUS_CAN_NOT_BE_UPDATED);\n        require(loanData.status != status, Errors.LOAN_SET_STATUS_ERROR);\n        loanData.status = status;\n        emit UpdateStatus(tokenId, status);\n    }\n\n    /**\n     * @notice Transfers the loan between two users. Calls the function of the incentives controller contract.\n     * @param from The source address\n     * @param to The destination address\n     * @param tokenId The id of the loan\n     **/\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._transfer(from, to, tokenId);\n\n        DataTypes.LoanStatus status = getStatus(tokenId);\n        if (status == DataTypes.LoanStatus.BORROWING || status == DataTypes.LoanStatus.EXTENDABLE) {\n            address incentiveControllerAddress = SETTINGS.incentiveControllerAddress();\n            DataTypes.LoanData memory loanData = _loans[tokenId];\n            if (incentiveControllerAddress != address(0)) {\n                IOpenSkyIncentivesController incentivesController = IOpenSkyIncentivesController(\n                    incentiveControllerAddress\n                );\n                incentivesController.handleAction(from, userBorrows[from], totalBorrows);\n                if (from != to) {\n                    incentivesController.handleAction(to, userBorrows[to], totalBorrows);\n                }\n            }\n            userBorrows[from] = userBorrows[from] - loanData.amount;\n            userBorrows[to] = userBorrows[to] + loanData.amount;\n        }\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function getLoanData(uint256 tokenId) external view override checkLoanExists(tokenId) returns (DataTypes.LoanData memory) {\n        DataTypes.LoanData memory loan = _loans[tokenId];\n        loan.status = getStatus(tokenId);\n        return loan;\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function getBorrowInterest(uint256 tokenId) public view override checkLoanExists(tokenId) returns (uint256) {\n        DataTypes.LoanData memory loan = _loans[tokenId];\n        uint256 endTime = loan.borrowEnd > 0 ? loan.borrowEnd : block.timestamp;\n        return loan.interestPerSecond.rayMul(endTime - loan.borrowBegin);\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function getStatus(uint256 tokenId) public view override checkLoanExists(tokenId) returns (DataTypes.LoanStatus) {\n        DataTypes.LoanData memory loan = _loans[tokenId];\n        DataTypes.LoanStatus status = _loans[tokenId].status;\n        if (status == DataTypes.LoanStatus.BORROWING) {\n            if (loan.liquidatableTime < block.timestamp) {\n                status = DataTypes.LoanStatus.LIQUIDATABLE;\n            } else if (loan.borrowOverdueTime < block.timestamp) {\n                status = DataTypes.LoanStatus.OVERDUE;\n            } else if (loan.extendableTime < block.timestamp) {\n                status = DataTypes.LoanStatus.EXTENDABLE;\n            }\n        }\n        return status;\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function getBorrowBalance(uint256 tokenId) external view override checkLoanExists(tokenId) returns (uint256) {\n        return _loans[tokenId].amount + getBorrowInterest(tokenId);\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function getPenalty(uint256 tokenId) external view override checkLoanExists(tokenId) returns (uint256) {\n        DataTypes.LoanStatus status = getStatus(tokenId);\n        DataTypes.LoanData memory loan = _loans[tokenId];\n        uint256 penalty = 0;\n        if (status == DataTypes.LoanStatus.BORROWING) {\n            penalty = loan.amount.percentMul(SETTINGS.prepaymentFeeFactor());\n        } else if (status == DataTypes.LoanStatus.OVERDUE) {\n            penalty = loan.amount.percentMul(SETTINGS.overdueLoanFeeFactor());\n        }\n        return penalty;\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function flashClaim(\n        address receiverAddress,\n        uint256[] calldata loanIds,\n        bytes calldata params\n    ) external override nonReentrant {\n        uint256 i;\n        IOpenSkyFlashClaimReceiver receiver = IOpenSkyFlashClaimReceiver(receiverAddress);\n        // !!!CAUTION: receiver contract may reentry mint, burn, flashclaim again\n\n        // only loan owner can do flashclaim\n        address[] memory nftAddresses = new address[](loanIds.length);\n        uint256[] memory tokenIds = new uint256[](loanIds.length);\n        for (i = 0; i < loanIds.length; i++) {\n            require(ownerOf(loanIds[i]) == _msgSender(), Errors.LOAN_CALLER_IS_NOT_OWNER);\n            DataTypes.LoanStatus status = getStatus(loanIds[i]);\n            require(\n                status != DataTypes.LoanStatus.LIQUIDATABLE && status != DataTypes.LoanStatus.LIQUIDATING,\n                Errors.FLASHCLAIM_STATUS_ERROR\n            );\n            DataTypes.LoanData memory loan = _loans[loanIds[i]];\n            nftAddresses[i] = loan.nftAddress;\n            tokenIds[i] = loan.tokenId;\n        }\n\n        // step 1: moving underlying asset forward to receiver contract\n        for (i = 0; i < loanIds.length; i++) {\n            IERC721(nftAddresses[i]).safeTransferFrom(address(this), receiverAddress, tokenIds[i]);\n        }\n\n        // setup 2: execute receiver contract, doing something like airdrop\n        require(\n            receiver.executeOperation(nftAddresses, tokenIds, _msgSender(), address(this), params),\n            Errors.FLASHCLAIM_EXECUTOR_ERROR\n        );\n\n        // setup 3: moving underlying asset backward from receiver contract\n        for (i = 0; i < loanIds.length; i++) {\n            IERC721(nftAddresses[i]).safeTransferFrom(receiverAddress, address(this), tokenIds[i]);\n            emit FlashClaim(receiverAddress, _msgSender(), nftAddresses[i], tokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function claimERC20Airdrop(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyAirdropOperator {\n        // make sure that params are checked in admin contract\n        IERC20(token).safeTransfer(to, amount);\n        emit ClaimERC20Airdrop(token, to, amount);\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function claimERC721Airdrop(\n        address token,\n        address to,\n        uint256[] calldata ids\n    ) external override onlyAirdropOperator {\n        // make sure that params are checked in admin contract\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(getLoanId[token][ids[i]] == 0, Errors.LOAN_COLLATERAL_NFT_CAN_NOT_BE_CLAIMED);\n            IERC721(token).safeTransferFrom(address(this), to, ids[i]);\n        }\n        emit ClaimERC721Airdrop(token, to, ids);\n    }\n\n    /// @inheritdoc IOpenSkyLoan\n    function claimERC1155Airdrop(\n        address token,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override onlyAirdropOperator {\n        // make sure that params are checked in admin contract\n        IERC1155(token).safeBatchTransferFrom(address(this), to, ids, amounts, data);\n        emit ClaimERC1155Airdrop(token, to, ids, amounts, data);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Receiver, IERC165, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (SETTINGS.loanDescriptorAddress() != address(0)) {\n            return IOpenSkyNFTDescriptor(SETTINGS.loanDescriptorAddress()).tokenURI(tokenId);\n        } else {\n            return '';\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyFlashClaimReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyFlashClaimReceiver {\n    function executeOperation(\n        address[] calldata nftAddresses,\n        uint256[] calldata tokenIds,\n        address initiator,\n        address operator,\n        bytes calldata params\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/misc/OpenSkyDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\nimport '../interfaces/IOpenSkySettings.sol';\nimport '../interfaces/IOpenSkyMoneyMarket.sol';\nimport '../interfaces/IOpenSkyDataProvider.sol';\nimport '../interfaces/IOpenSkyPool.sol';\nimport '../interfaces/IOpenSkyOToken.sol';\nimport '../interfaces/IOpenSkyLoan.sol';\nimport '../interfaces/IOpenSkyInterestRateStrategy.sol';\n\nimport '../libraries/math/WadRayMath.sol';\nimport '../libraries/math/MathUtils.sol';\nimport '../libraries/types/DataTypes.sol';\n\ncontract OpenSkyDataProvider is IOpenSkyDataProvider {\n    using WadRayMath for uint256;\n\n    IOpenSkySettings public immutable SETTINGS;\n\n    constructor(IOpenSkySettings settings) {\n        SETTINGS = settings;\n    }\n\n    function getReserveData(uint256 reserveId) external view override returns (ReserveData memory) {\n        IOpenSkyPool pool = IOpenSkyPool(SETTINGS.poolAddress());\n        DataTypes.ReserveData memory reserve = pool.getReserveData(reserveId);\n        IERC20 oToken = IERC20(reserve.oTokenAddress);\n        return\n            ReserveData({\n                reserveId: reserveId,\n                underlyingAsset: reserve.underlyingAsset,\n                oTokenAddress: reserve.oTokenAddress,\n                TVL: pool.getTVL(reserveId),\n                totalDeposits: oToken.totalSupply(),\n                totalBorrowsBalance: pool.getTotalBorrowBalance(reserveId),\n                supplyRate: getSupplyRate(reserveId),\n                borrowRate: getBorrowRate(reserveId, 0, 0, 0, 0),\n                availableLiquidity: pool.getAvailableLiquidity(reserveId)\n            });\n    }\n\n    function getTVL(uint256 reserveId) external view override returns (uint256) {\n        return IOpenSkyPool(SETTINGS.poolAddress()).getTVL(reserveId);\n    }\n\n    function getTotalBorrowBalance(uint256 reserveId) external view override returns (uint256) {\n        return IOpenSkyPool(SETTINGS.poolAddress()).getTotalBorrowBalance(reserveId);\n    }\n\n    function getAvailableLiquidity(uint256 reserveId) external view override returns (uint256) {\n        return IOpenSkyPool(SETTINGS.poolAddress()).getAvailableLiquidity(reserveId);\n    }\n\n    function getSupplyRate(uint256 reserveId) public view override returns (uint256) {\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId);\n\n        uint256 tvl = IOpenSkyOToken(reserve.oTokenAddress).principleTotalSupply();\n\n        (, uint256 utilizationRate) = MathUtils.calculateLoanSupplyRate(\n            tvl,\n            reserve.totalBorrows,\n            getBorrowRate(reserveId, 0, 0, 0, 0)\n        );\n\n        return\n            getLoanSupplyRate(reserveId) + ((WadRayMath.ray() - utilizationRate).rayMul(getMoneyMarketSupplyRateInstant(reserveId)));\n    }\n\n    function getLoanSupplyRate(uint256 reserveId) public view override returns (uint256) {\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId);\n        uint256 tvl = IOpenSkyOToken(reserve.oTokenAddress).principleTotalSupply();\n        (uint256 loanSupplyRate, ) = MathUtils.calculateLoanSupplyRate(\n            tvl,\n            reserve.totalBorrows,\n            getBorrowRate(reserveId, 0, 0, 0, 0)\n        );\n        return loanSupplyRate;\n    }\n\n    function getMoneyMarketSupplyRateInstant(uint256 reserveId) public view override returns (uint256) {\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId);\n        if (reserve.isMoneyMarketOn) {\n            return IOpenSkyMoneyMarket(reserve.moneyMarketAddress).getSupplyRate(reserve.underlyingAsset);\n        } else {\n            return 0;\n        }\n    }\n\n    function getBorrowRate(\n        uint256 reserveId,\n        uint256 liquidityAmountToAdd,\n        uint256 liquidityAmountToRemove,\n        uint256 borrowAmountToAdd,\n        uint256 borrowAmountToRemove\n    ) public view override returns (uint256) {\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId);\n        return\n            IOpenSkyInterestRateStrategy(reserve.interestModelAddress).getBorrowRate(\n                reserveId,\n                IOpenSkyOToken(reserve.oTokenAddress).totalSupply() + liquidityAmountToAdd - liquidityAmountToRemove,\n                reserve.totalBorrows + borrowAmountToAdd - borrowAmountToRemove\n            );\n    }\n\n    function getSupplyBalance(uint256 reserveId, address account) external view override returns (uint256) {\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId);\n        return IERC20(reserve.oTokenAddress).balanceOf(account);\n    }\n\n    function getLoanData(uint256 loanId) external view override returns (LoanData memory) {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loan = loanNFT.getLoanData(loanId);\n        return\n            LoanData({\n                loanId: loanId,\n                totalBorrows: loan.amount,\n                borrowBalance: loanNFT.getBorrowBalance(loanId),\n                borrowBegin: loan.borrowBegin,\n                borrowDuration: loan.borrowDuration,\n                borrowOverdueTime: loan.borrowOverdueTime,\n                liquidatableTime: loan.liquidatableTime,\n                extendableTime: loan.extendableTime,\n                borrowRate: loan.borrowRate,\n                interestPerSecond: loan.interestPerSecond,\n                penalty: loanNFT.getPenalty(loanId),\n                status: loan.status\n            });\n    }\n\n    function getLoansByUser(address account) external view override returns (uint256[] memory) {\n        IERC721Enumerable loanNFT = IERC721Enumerable(SETTINGS.loanAddress());\n        uint256 amount = loanNFT.balanceOf(account);\n        uint256[] memory ids = new uint256[](amount > 0 ? amount : 0);\n        for (uint256 i = 0; i < amount; ++i) {\n            ids[i] = loanNFT.tokenOfOwnerByIndex(account, i);\n        }\n        return ids;\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../libraries/types/DataTypes.sol';\n\ninterface IOpenSkyDataProvider {\n    struct ReserveData {\n        uint256 reserveId;\n        address underlyingAsset;\n        address oTokenAddress;\n        uint256 TVL;\n        uint256 totalDeposits;\n        uint256 totalBorrowsBalance;\n        uint256 supplyRate;\n        uint256 borrowRate;\n        uint256 availableLiquidity;\n    }\n\n    struct LoanData {\n        uint256 loanId;\n        uint256 totalBorrows;\n        uint256 borrowBalance;\n        uint40 borrowBegin;\n        uint40 borrowDuration;\n        uint40 borrowOverdueTime;\n        uint40 liquidatableTime;\n        uint40 extendableTime;\n        uint128 borrowRate;\n        uint128 interestPerSecond;\n        uint256 penalty;\n        DataTypes.LoanStatus status;\n    }\n\n    function getReserveData(uint256 reserveId) external view returns (ReserveData memory);\n\n    function getTVL(uint256 reserveId) external view returns (uint256);\n\n    function getTotalBorrowBalance(uint256 reserveId) external view returns (uint256);\n\n    function getAvailableLiquidity(uint256 reserveId) external view returns (uint256);\n\n    function getSupplyRate(uint256 reserveId) external view returns (uint256);\n\n    function getLoanSupplyRate(uint256 reserveId) external view returns (uint256);\n\n    function getBorrowRate(\n        uint256 reserveId,\n        uint256 liquidityAmountToAdd,\n        uint256 liquidityAmountToRemove,\n        uint256 borrowAmountToAdd,\n        uint256 borrowAmountToRemove\n    ) external view returns (uint256);\n\n    function getMoneyMarketSupplyRateInstant(uint256 reserveId) external view returns (uint256);\n\n    function getSupplyBalance(uint256 reserveId, address account) external view returns (uint256);\n\n    function getLoanData(uint256 loanId) external view returns (LoanData memory);\n\n    function getLoansByUser(address account) external view returns (uint256[] memory arr);\n}\n"
    },
    "contracts/misc/OpenSkyPunkGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../dependencies/cryptopunk/ICryptoPunk.sol';\nimport '../dependencies/cryptopunk/IWrappedPunk.sol';\nimport '../dependencies/weth/IWETH.sol';\n\nimport '../libraries/types/DataTypes.sol';\nimport '../interfaces/IOpenSkySettings.sol';\nimport '../interfaces/IOpenSkyPool.sol';\nimport '../interfaces/IOpenSkyLoan.sol';\nimport '../interfaces/IOpenSkyPunkGateway.sol';\n\ncontract OpenSkyPunkGateway is Context, ERC721Holder, IOpenSkyPunkGateway {\n    using SafeERC20 for IERC20;\n\n    IOpenSkySettings public immutable SETTINGS;\n    ICryptoPunk public immutable PUNK;\n    IWrappedPunk public immutable WPUNK;\n    IWETH public immutable WETH;\n\n    address public immutable WPUNK_PROXY_ADDRESS;\n\n    constructor(\n        address SETTINGS_,\n        address PUNK_,\n        address WPUNK_,\n        address WETH_\n    ) {\n        SETTINGS = IOpenSkySettings(SETTINGS_);\n        PUNK = ICryptoPunk(PUNK_);\n        WPUNK = IWrappedPunk(WPUNK_);\n        WETH = IWETH(WETH_);\n\n        WPUNK.registerProxy();\n        WPUNK_PROXY_ADDRESS = WPUNK.proxyInfo(address(this));\n\n        IERC721(address(WPUNK)).setApprovalForAll(SETTINGS.poolAddress(), true);\n    }\n\n    function borrow(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        uint256 punkIndex\n    ) external override {\n        address underlyingAsset = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId).underlyingAsset;\n\n        uint256 loanId = _borrow(reserveId, amount, duration, punkIndex);\n        IERC20(underlyingAsset).safeTransfer(_msgSender(), amount);\n\n        emit Borrow(reserveId, _msgSender(), amount, duration, punkIndex, loanId);\n    }\n\n    function borrowETH(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        uint256 punkIndex\n    ) external {\n        address underlyingAsset = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId).underlyingAsset;\n        require(underlyingAsset == address(WETH), 'BORROW_ETH_RESERVE_ASSET_NOT_MATCH');\n\n        uint256 loanId = _borrow(reserveId, amount, duration, punkIndex);\n\n        WETH.withdraw(amount);\n        _safeTransferETH(_msgSender(), amount);\n\n        emit BorrowETH(reserveId, _msgSender(), amount, duration, punkIndex, loanId);\n    }\n\n    /// @notice Only loan NFT owner can repay\n    function repay(uint256 loanId) external override {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n        address underlyingAsset = IOpenSkyPool(SETTINGS.poolAddress())\n            .getReserveData(loanData.reserveId)\n            .underlyingAsset;\n        uint256 borrowBalance = loanNFT.getBorrowBalance(loanId);\n        uint256 penalty = loanNFT.getPenalty(loanId);\n        uint256 repayAmount = borrowBalance + penalty;\n\n        IERC20(underlyingAsset).safeTransferFrom(_msgSender(), address(this), repayAmount);\n\n        _repay(loanId, loanData, underlyingAsset, repayAmount);\n\n        emit Repay(loanData.reserveId, _msgSender(), loanData.tokenId, loanId);\n    }\n\n    function repayETH(uint256 loanId) external payable {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n\n        address underlyingAsset = IOpenSkyPool(SETTINGS.poolAddress())\n            .getReserveData(loanData.reserveId)\n            .underlyingAsset;\n        require(underlyingAsset == address(WETH), 'REPAY_ETH_RESERVE_ASSET_NOT_MATCH');\n\n        uint256 borrowBalance = loanNFT.getBorrowBalance(loanId);\n        uint256 penalty = loanNFT.getPenalty(loanId);\n        uint256 repayAmount = borrowBalance + penalty;\n\n        require(msg.value >= repayAmount, 'REPAY_ETH_NOT_ENOUGH');\n\n        // prepare weth\n        WETH.deposit{value: repayAmount}();\n\n        _repay(loanId, loanData, underlyingAsset, repayAmount);\n\n        if (msg.value > repayAmount) {\n            _safeTransferETH(_msgSender(), msg.value - repayAmount);\n        }\n\n        emit RepayETH(loanData.reserveId, _msgSender(), loanData.tokenId, loanId);\n    }\n\n    function _borrow(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        uint256 punkIndex\n    ) internal returns (uint256) {\n        address owner = PUNK.punkIndexToAddress(punkIndex);\n        require(owner == _msgSender(), 'BORROW_NOT_OWNER_OF_PUNK');\n\n        // deposit punk\n        PUNK.buyPunk(punkIndex);\n        PUNK.transferPunk(WPUNK_PROXY_ADDRESS, punkIndex);\n        WPUNK.mint(punkIndex);\n\n        // borrow\n        uint256 loanId = IOpenSkyPool(SETTINGS.poolAddress()).borrow(\n            reserveId,\n            amount,\n            duration,\n            address(WPUNK),\n            punkIndex,\n            _msgSender()\n        );\n        return loanId;\n    }\n\n    function _repay(\n        uint256 loanId,\n        DataTypes.LoanData memory loanData,\n        address underlyingAsset,\n        uint256 repayAmount\n    ) internal {\n        address owner = IERC721(SETTINGS.loanAddress()).ownerOf(loanId);\n\n        // approve underlyingAsset\n        IERC20(underlyingAsset).safeApprove(SETTINGS.poolAddress(), repayAmount);\n\n        uint256 repaid = IOpenSkyPool(SETTINGS.poolAddress()).repay(loanId);\n        require(repaid == repayAmount, 'REPAY_AMOUNT_NOT_MATCH');\n\n        // withdrawPunk\n        WPUNK.burn(loanData.tokenId);\n        PUNK.transferPunk(owner, loanData.tokenId);\n    }\n\n    function _safeTransferETH(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}('');\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n\n    event Received(address, uint256);\n\n    receive() external payable {\n        emit Received(_msgSender(), msg.value);\n    }\n}\n"
    },
    "contracts/dependencies/cryptopunk/ICryptoPunk.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\ninterface ICryptoPunk {\n    function balanceOf(address account) external view returns (uint256);\n    function punkIndexToAddress(uint256 punkIndex) external view returns (address);\n    function punksOfferedForSale(uint256 punkIndex) external view returns (bool, uint256, address, uint256, address);\n    function buyPunk(uint punkIndex) external payable;\n    function transferPunk(address to, uint punkIndex) external;\n}\n"
    },
    "contracts/dependencies/cryptopunk/IWrappedPunk.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IWrappedPunk is IERC721 {\n    function punkContract() external view returns (address);\n    function mint(uint256 punkIndex) external;\n    function burn(uint256 punkIndex) external;\n    function registerProxy() external;\n    function proxyInfo(address user) external returns (address proxy);\n}\n"
    },
    "contracts/dependencies/weth/IWETH.sol": {
      "content": "pragma solidity 0.8.10;\n\ninterface IWETH {\n    function balanceOf(address) external view returns (uint256);\n\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IOpenSkyPunkGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyPunkGateway {\n    event Borrow(\n        uint256 indexed reserveId,\n        address indexed user,\n        uint256 amount,\n        uint256 duration,\n        uint256 punkIndex,\n        uint256 loanId\n    );\n    event Repay(uint256 indexed reserveId, address indexed user, uint256 punkIndex, uint256 loanId);\n\n    event BorrowETH(\n        uint256 indexed reserveId,\n        address indexed user,\n        uint256 amount,\n        uint256 duration,\n        uint256 punkIndex,\n        uint256 loanId\n    );\n    event RepayETH(uint256 indexed reserveId, address indexed user, uint256 punkIndex, uint256 loanId);\n\n    function borrow(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        uint256 punkIndex\n    ) external;\n\n    function repay(uint256 loanId) external;\n\n    function borrowETH(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        uint256 punkIndex\n    ) external;\n\n    function repayETH(uint256 loanId) external payable;\n}\n"
    },
    "contracts/refinance/adapters/BespokeToPoolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\n\nimport '../interfaces/IAaveFlashLoanReceiver.sol';\nimport '../interfaces/IAaveLendPoolAddressesProvider.sol';\nimport '../interfaces/IAaveLendPool.sol';\n\nimport '../../bespokemarket/interfaces/IOpenSkyBespokeSettings.sol';\nimport '../../bespokemarket/interfaces/IOpenSkyBespokeMarket.sol';\nimport '../../bespokemarket/libraries/BespokeTypes.sol';\n\nimport '../../interfaces/IOpenSkySettings.sol';\nimport '../../interfaces/IOpenSkyPool.sol';\n\ncontract BespokeToPoolAdapter is IAaveFlashLoanReceiver, ERC721Holder {\n    using SafeERC20 for IERC20;\n\n    IAaveLendPoolAddressesProvider public immutable AAVE2_ADDRESSES_PROVIDER;\n    IOpenSkySettings public immutable SETTINGS;\n    IOpenSkyBespokeSettings public immutable BESPOKE_SETTINGS;\n\n    event RefinanceBespokeToPool(address indexed asset, address indexed borrower, uint256 oldLoanId, uint256 newLoanId);\n\n    constructor(\n        IAaveLendPoolAddressesProvider provider,\n        IOpenSkyBespokeSettings bespokeSettings,\n        IOpenSkySettings poolSettings\n    ) {\n        AAVE2_ADDRESSES_PROVIDER = provider;\n        BESPOKE_SETTINGS = bespokeSettings;\n        SETTINGS = poolSettings;\n    }\n\n    function aavePool() public view returns (IAaveLendPool) {\n        return IAaveLendPool(AAVE2_ADDRESSES_PROVIDER.getLendingPool());\n    }\n\n    struct LocalVars {\n        uint256 loanId;\n        uint256 repayAmount;\n        address assetAddress;\n        uint256 reserveId;\n        uint256 borrowAmount;\n        uint256 borrowDuration;\n        address onBehalfOf;\n        address borrower;\n        uint256 needInput;\n        bytes params;\n        uint256 newLoanId;\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool) {\n        require(\n            assets.length == 1 && amounts.length == 1 && premiums.length == 1,\n            'BM_FLASH_LOAN_MULTIPLE_ASSETS_NOT_SUPPORTED'\n        );\n        require(address(aavePool()) == msg.sender, 'BM_FLASH_LOAN_INVALID_CALLER');\n\n        LocalVars memory vars;\n\n        (vars.params, vars.borrower) = abi.decode(params, (bytes, address));\n\n        (vars.loanId, vars.reserveId, vars.borrowAmount, vars.borrowDuration, vars.onBehalfOf) = abi.decode(\n            vars.params,\n            (uint256, uint256, uint256, uint256, address)\n        );\n\n        // get loan info before repay\n        BespokeTypes.LoanData memory loan = IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).getLoanData(\n            vars.loanId\n        );\n\n        // repay bespoke\n        // OpenSkyBespokeBorrowNFT\n        vars.repayAmount =\n            IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).getPenalty(vars.loanId) +\n            IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).getBorrowBalance(vars.loanId);\n\n        IERC721(BESPOKE_SETTINGS.borrowLoanAddress()).safeTransferFrom(vars.borrower, address(this), vars.loanId);\n\n        IERC20(assets[0]).approve(BESPOKE_SETTINGS.marketAddress(), vars.repayAmount);\n        IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).repay(vars.loanId);\n\n        // borrow again\n        IERC721(loan.tokenAddress).approve(SETTINGS.poolAddress(), loan.tokenId);\n\n        vars.newLoanId = IOpenSkyPool(SETTINGS.poolAddress()).borrow(\n            vars.reserveId,\n            vars.borrowAmount,\n            vars.borrowDuration,\n            loan.tokenAddress,\n            loan.tokenId,\n            vars.onBehalfOf // can  get loan nft\n        );\n\n        vars.needInput = vars.repayAmount + premiums[0];\n\n        // transfer erc20\n        if (vars.borrowAmount > vars.needInput) {\n            // TODO check: transfer extra money to borrower or onBehalfOf?\n            IERC20(assets[0]).safeTransfer(vars.borrower, vars.borrowAmount - vars.needInput);\n        } else if (vars.borrowAmount < vars.needInput) {\n            IERC20(assets[0]).safeTransferFrom(vars.borrower, address(this), vars.needInput - vars.borrowAmount);\n        }\n\n        // no need to transfer  loan nft\n\n        //repay flashloan\n        IERC20(assets[0]).approve(address(aavePool()), amounts[0] + premiums[0]);\n\n        emit RefinanceBespokeToPool(assets[0], vars.borrower, vars.loanId, vars.newLoanId);\n        return true;\n    }\n}\n"
    },
    "contracts/vault/OpenSkyDaoVaultUniswapV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\n\nimport '../dependencies/uniswap-v2/IUniswapV2Router02.sol';\nimport '../interfaces/IOpenSkySettings.sol';\nimport '../interfaces/IACLManager.sol';\n\nimport '../interfaces/IOpenSkyDaoVaultUniswapV2Adapter.sol';\n\n/**\n * @dev Provide swap services for OpenSkyDaoVault contract.\n * - OpenSkyDaoVault should approve 'amount' of 'token' to this contract first\n * - Receiver of swap is always OpenSkyDaoVault\n * - Only callable by governance\n */\ncontract OpenSkyDaoVaultUniswapV2Adapter is Context, IOpenSkyDaoVaultUniswapV2Adapter {\n    using SafeERC20 for IERC20;\n\n    IOpenSkySettings public immutable SETTINGS;\n    address public immutable WETH_ADDRESS;\n    address public immutable DAO_VAULT_ADDRESS;\n    IUniswapV2Router02 public immutable UNISWAP_ROUTER;\n\n    modifier onlyGovernance() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isGovernance(_msgSender()), 'ACL_ONLY_GOVERNANCE_CAN_CALL');\n        _;\n    }\n\n    constructor(\n        address settingsAddress,\n        address daoVaultAddress,\n        address uniswapRouterAddress,\n        address wethAddress\n    ) {\n        SETTINGS = IOpenSkySettings(settingsAddress);\n        DAO_VAULT_ADDRESS = daoVaultAddress;\n        UNISWAP_ROUTER = IUniswapV2Router02(uniswapRouterAddress);\n        WETH_ADDRESS = wethAddress;\n    }\n\n    function pullERC20FromDaoVault(address token, uint256 amount) public onlyGovernance {\n        IERC20(token).safeTransferFrom(DAO_VAULT_ADDRESS, address(this), amount);\n    }\n\n    function swapExactTokensForTokens(\n        address assetToSwapFrom,\n        address assetToSwapTo,\n        uint256 amountToSwap,\n        uint256 minAmountOut,\n        bool useEthPath\n    ) external onlyGovernance returns (uint256) {\n        // step1: pull asset\n        pullERC20FromDaoVault(assetToSwapFrom, amountToSwap);\n\n        // step2: approve\n        IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0);\n        IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), amountToSwap);\n\n        // step3: swap\n        address[] memory path;\n        if (useEthPath) {\n            path = new address[](3);\n            path[0] = assetToSwapFrom;\n            path[1] = WETH_ADDRESS;\n            path[2] = assetToSwapTo;\n        } else {\n            path = new address[](2);\n            path[0] = assetToSwapFrom;\n            path[1] = assetToSwapTo;\n        }\n\n        uint256[] memory amounts = UNISWAP_ROUTER.swapExactTokensForTokens(\n            amountToSwap,\n            minAmountOut,\n            path,\n            DAO_VAULT_ADDRESS,\n            block.timestamp\n        );\n\n        emit Swapped(assetToSwapFrom, assetToSwapTo, amounts[0], amounts[amounts.length - 1]);\n\n        return amounts[amounts.length - 1];\n    }\n\n    function swapTokensForExactTokens(\n        address assetToSwapFrom,\n        address assetToSwapTo,\n        uint256 maxAmountToSwap,\n        uint256 amountToReceive,\n        bool useEthPath\n    ) external onlyGovernance returns (uint256) {\n        // step1 pull asset\n        pullERC20FromDaoVault(assetToSwapFrom, maxAmountToSwap);\n\n        // step2: approve\n        IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0);\n        IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), maxAmountToSwap);\n\n        // step3: swap\n        address[] memory path;\n        if (useEthPath) {\n            path = new address[](3);\n            path[0] = assetToSwapFrom;\n            path[1] = WETH_ADDRESS;\n            path[2] = assetToSwapTo;\n        } else {\n            path = new address[](2);\n            path[0] = assetToSwapFrom;\n            path[1] = assetToSwapTo;\n        }\n\n        uint256[] memory amounts = UNISWAP_ROUTER.swapTokensForExactTokens(\n            amountToReceive,\n            maxAmountToSwap,\n            path,\n            DAO_VAULT_ADDRESS,\n            block.timestamp\n        );\n\n        emit Swapped(assetToSwapFrom, assetToSwapTo, amounts[0], amounts[amounts.length - 1]);\n\n        return amounts[0];\n    }\n\n    /**\n     * @dev Emergency rescue for token stuck on this contract, as failsafe mechanism\n     * - Funds should never remain in this contract more time than during transactions\n     * - Only callable by governance\n     **/\n    function rescueTokens(IERC20 token) external onlyGovernance {\n        token.safeTransfer(DAO_VAULT_ADDRESS, token.balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/dependencies/uniswap-v2/IUniswapV2Router02.sol": {
      "content": "pragma solidity 0.8.10;\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/interfaces/IOpenSkyDaoVaultUniswapV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyDaoVaultUniswapV2Adapter {\n    event Swapped(address fromAsset, address toAsset, uint256 fromAmount, uint256 receivedAmount);\n\n    function pullERC20FromDaoVault(address token, uint256 amount) external;\n\n    function swapExactTokensForTokens(\n        address assetToSwapFrom,\n        address assetToSwapTo,\n        uint256 amountToSwap,\n        uint256 minAmountOut,\n        bool useEthPath\n    ) external returns (uint256);\n\n    function swapTokensForExactTokens(\n        address assetToSwapFrom,\n        address assetToSwapTo,\n        uint256 maxAmountToSwap,\n        uint256 amountToReceive,\n        bool useEthPath\n    ) external returns (uint256);\n}\n"
    },
    "contracts/vault/OpenSkyDaoVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\nimport '../dependencies/weth/IWETH.sol';\nimport '../interfaces/IOpenSkySettings.sol';\nimport '../interfaces/IACLManager.sol';\nimport '../interfaces/IOpenSkyDaoVault.sol';\nimport '../interfaces/IOpenSkyFlashClaimReceiver.sol';\n\n/**\n * @title OpenSkyDaoVault contract\n * @author OpenSky Labs\n * @notice Implementation of vault for OpenSky Dao\n **/\ncontract OpenSkyDaoVault is Context, ERC165, ReentrancyGuard, IERC721Receiver, IERC1155Receiver, IOpenSkyDaoVault {\n    using SafeERC20 for IERC20;\n\n    IOpenSkySettings public immutable SETTINGS;\n    IWETH public immutable WETH;\n\n    modifier onlyGovernance() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isGovernance(_msgSender()), 'ACL_ONLY_GOVERNANCE_CAN_CALL');\n        _;\n    }\n\n    constructor(address SETTINGS_, address WETH_) ReentrancyGuard() {\n        SETTINGS = IOpenSkySettings(SETTINGS_);\n        WETH = IWETH(WETH_);\n    }\n\n    function approveERC20(\n        address token,\n        address spender,\n        uint256 amount\n    ) external override onlyGovernance {\n        IERC20(token).safeApprove(spender, amount);\n        emit ApproveERC20(token, spender, amount);\n    }\n\n    function withdrawETH(uint256 amount, address to) external override onlyGovernance {\n        require(amount > 0, 'WITHDRAW_AMOUNT_NOT_ALLOWED');\n        require(address(this).balance >= amount,'WITHDRAW_AMOUNT_BIGGER_THAN_BALANCE');\n\n        _safeTransferETH(to, amount);\n        emit WithdrawETH(amount, to);\n    }\n\n    function withdrawERC20(\n        address token,\n        uint256 amount,\n        address to\n    ) external override onlyGovernance {\n        IERC20(token).safeTransfer(to, amount);\n        emit WithdrawERC20(token, amount, to);\n    }\n\n    function approveERC721(\n        address token,\n        address spender,\n        uint256 tokenId\n    ) external override onlyGovernance {\n        IERC721(token).approve(spender, tokenId);\n        emit ApproveERC721(token, spender, tokenId);\n    }\n\n    function approveERC721ForAll(\n        address token,\n        address spender,\n        bool approved\n    ) external override onlyGovernance {\n        IERC721(token).setApprovalForAll(spender, approved);\n        emit ApproveERC721ForAll(token, spender, approved);\n    }\n\n    function withdrawERC721(\n        address token,\n        uint256 tokenId,\n        address to\n    ) external override onlyGovernance {\n        IERC721(token).safeTransferFrom(address(this), to, tokenId);\n        emit WithdrawERC721(token, tokenId, to);\n    }\n\n    function approveERC1155ForAll(\n        address token,\n        address spender,\n        bool approved\n    ) external override onlyGovernance {\n        IERC1155(token).setApprovalForAll(spender, approved);\n        emit ApproveERC1155ForAll(token, spender, approved);\n    }\n\n    function withdrawERC1155(\n        address to,\n        address token,\n        uint256 tokenId,\n        uint256 amount\n    ) external override onlyGovernance {\n        IERC1155(token).safeTransferFrom(address(this), to, tokenId, amount, '0');\n        emit WithdrawERC1155(token, tokenId, amount, to);\n    }\n\n    function convertETHToWETH(uint256 amount) external override onlyGovernance {\n        WETH.deposit{value: amount}();\n        emit ConvertETHToWETH(amount);\n    }\n\n    function onERC721Received(\n        address,\n        address from,\n        uint256 id,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(\n        address,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721Receiver).interfaceId ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _safeTransferETH(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}('');\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n\n    function flashClaim(\n        address receiverAddress,\n        address[] calldata tokens,\n        uint256[] calldata tokenIds,\n        bytes calldata params\n    ) external override nonReentrant {\n        require(tokens.length == tokenIds.length, 'DV_FLASH_CLAIM_PARAMS_ERROR');\n        uint256 i;\n        IOpenSkyFlashClaimReceiver receiver = IOpenSkyFlashClaimReceiver(receiverAddress);\n\n        // step 1: moving underlying asset forward to receiver contract\n        for (i = 0; i < tokenIds.length; i++) {\n            require(IERC721(tokens[i]).ownerOf(tokenIds[i]) == address(this), 'DV_DOES_NOT_OWN_THE_NFT');\n            IERC721(tokens[i]).safeTransferFrom(address(this), receiverAddress, tokenIds[i]);\n        }\n\n        // setup 2: execute receiver contract, doing something like airdrop\n        require(\n            receiver.executeOperation(tokens, tokenIds, address(this), address(this), params),\n            'DV_FLASHCLAIM_EXECUTOR_ERROR'\n        );\n\n        // setup 3: moving underlying asset backward from receiver contract\n        for (i = 0; i < tokenIds.length; i++) {\n            IERC721(tokens[i]).safeTransferFrom(receiverAddress, address(this), tokenIds[i]);\n            emit FlashClaim(receiverAddress, _msgSender(), tokens[i], tokenIds[i]);\n        }\n    }\n\n    receive() external payable {\n        emit DepositETH(msg.value, msg.sender);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyDaoVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyDaoVault {\n    event ApproveERC20(address token, address spender, uint256 amount);\n    event ApproveERC721(address token, address spender, uint256 tokenId);\n    event ApproveERC721ForAll(address token, address spender, bool approved);\n    event ApproveERC1155ForAll(address token, address spender, bool approved);\n    event ConvertETHToWETH(uint256 amount);\n\n    event DepositETH(uint256 amount, address indexed from);\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n\n    event WithdrawETH(uint256 amount, address to);\n    event WithdrawERC20(address indexed token, uint256 amount, address to);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n\n    event FlashClaim(address indexed receiver, address sender, address indexed nftAddress, uint256 indexed tokenId);\n\n    function approveERC20(\n        address token,\n        address spender,\n        uint256 amount\n    ) external;\n\n    function withdrawETH(uint256 amount, address to) external;\n\n    function withdrawERC20(\n        address token,\n        uint256 amount,\n        address to\n    ) external;\n\n    function approveERC721(\n        address token,\n        address spender,\n        uint256 tokenId\n    ) external;\n\n    function approveERC721ForAll(\n        address token,\n        address spender,\n        bool approved\n    ) external;\n\n    function withdrawERC721(\n        address token,\n        uint256 tokenId,\n        address to\n    ) external;\n\n    function approveERC1155ForAll(\n        address token,\n        address spender,\n        bool approved\n    ) external;\n\n    function withdrawERC1155(\n        address to,\n        address token,\n        uint256 tokenId,\n        uint256 amount\n    ) external;\n\n    function convertETHToWETH(uint256 amount) external;\n\n    function flashClaim(\n        address receiverAddress,\n        address[] calldata tokens,\n        uint256[] calldata tokenIds,\n        bytes calldata params\n    ) external;\n}\n"
    },
    "contracts/mocks/flash-loan/ApeCoinFlashLoanMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '../../interfaces/IOpenSkyFlashClaimReceiver.sol';\nimport './ApeCoinMock.sol';\n\ncontract ApeCoinFlashLoanMock is IOpenSkyFlashClaimReceiver, ERC721Holder {\n    address public immutable apeCoinAirdropAddress;\n\n    constructor(address _apeCoinAirdropAddress) {\n        apeCoinAirdropAddress = _apeCoinAirdropAddress;\n    }\n\n    function executeOperation(\n        address[] calldata nftAddresses,\n        uint256[] calldata tokenIds,\n        address initiator,\n        address operator,\n        bytes calldata params\n    ) external override returns (bool) {\n        params;\n\n        require(nftAddresses.length != 0 && nftAddresses.length == tokenIds.length, 'PARAMS_ERROR');\n        require(initiator != address(0));\n        require(operator != address(0));\n\n        for (uint256 i = 0; i < nftAddresses.length; i++) {\n            IAirdrop(apeCoinAirdropAddress).claimRewards(tokenIds[i], initiator);\n\n            IERC721(nftAddresses[i]).approve(operator, tokenIds[i]);\n        }\n\n        return true;\n    }\n\n}"
    },
    "contracts/mocks/flash-loan/ApeCoinMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ninterface IAirdrop {\n    function claimRewards(uint256 tokenId, address to) external;\n}\n\ncontract ApeCoinMock is ERC20, IAirdrop {\n    address public immutable nftAddress;\n\n    constructor(address _nftAddress) ERC20('Ape Coin', 'APE') {\n        nftAddress = _nftAddress;\n    }\n\n    function claimRewards(uint256 tokenId, address to) external override {\n        require(IERC721(nftAddress).ownerOf(tokenId) == _msgSender(), '');\n\n        _mint(to, 10 ether);\n    }\n}"
    },
    "contracts/mocks/token/OpenSkyERC721Mock.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';\nimport '@openzeppelin/contracts/utils/Counters.sol';\n\ncontract OpenSkyERC721Mock is ERC721, ERC721Enumerable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    event Minted(uint256 indexed itemId, address indexed owner);\n\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    function awardItem(address player) public returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 newItemId = _tokenIds.current();\n        _mint(player, newItemId);\n\n        emit Minted(newItemId, player);\n\n        return newItemId;\n    }\n\n    function currentValue() public view returns (uint256) {\n        return _tokenIds.current();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/refinance/adapters/BespokeToBespokeAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\nimport '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\n\nimport '../interfaces/IAaveFlashLoanReceiver.sol';\nimport '../interfaces/IAaveLendPoolAddressesProvider.sol';\nimport '../interfaces/IAaveLendPool.sol';\n\nimport '../../bespokemarket/interfaces/IOpenSkyBespokeSettings.sol';\nimport '../../bespokemarket/interfaces/IOpenSkyBespokeMarket.sol';\nimport '../../bespokemarket/libraries/BespokeTypes.sol';\n\ncontract BespokeToBespokeAdapter is IAaveFlashLoanReceiver, ERC721Holder, ERC1155Holder {\n    using SafeERC20 for IERC20;\n\n    IAaveLendPoolAddressesProvider public immutable AAVE2_ADDRESSES_PROVIDER;\n    IOpenSkyBespokeSettings public immutable BESPOKE_SETTINGS;\n\n    event RefinanceBespokeToBespoke(\n        address indexed asset,\n        address indexed borrower,\n        uint256 oldLoanId,\n        uint256 newLoanId\n    );\n\n    constructor(IAaveLendPoolAddressesProvider provider, IOpenSkyBespokeSettings bespokeSettings) {\n        AAVE2_ADDRESSES_PROVIDER = provider;\n        BESPOKE_SETTINGS = bespokeSettings;\n    }\n\n    function aavePool() public view returns (IAaveLendPool) {\n        return IAaveLendPool(AAVE2_ADDRESSES_PROVIDER.getLendingPool());\n    }\n\n    struct LocalVars {\n        uint256 loanId;\n        uint256 repayAmount;\n        address assetAddress;\n        uint256 borrowAmount;\n        uint256 borrowDuration;\n        address borrower;\n        uint256 needInput;\n        bytes params;\n        bytes params2;\n        BespokeTypes.Offer offer;\n        uint256 newLoanId;\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool) {\n        require(\n            assets.length == 1 && amounts.length == 1 && premiums.length == 1,\n            'BM_FLASH_LOAN_MULTIPLE_ASSETS_NOT_SUPPORTED'\n        );\n        require(address(aavePool()) == msg.sender, 'BM_FLASH_LOAN_INVALID_CALLER');\n\n        LocalVars memory vars;\n\n        // decode\n        (vars.params, vars.borrower) = abi.decode(params, (bytes, address));\n        (vars.loanId, vars.borrowAmount, vars.borrowDuration, vars.params2) = abi.decode(\n            vars.params,\n            (uint256, uint256, uint256, bytes)\n        );\n        vars.offer = abi.decode(vars.params2, (BespokeTypes.Offer));\n\n        // get loan data before repay\n        BespokeTypes.LoanData memory loan = IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).getLoanData(\n            vars.loanId\n        );\n\n        require(loan.currency == vars.offer.currency, 'BM_FLASH_LOAN_CURRENCY_NOT_MATCH');\n        require(loan.tokenAddress == vars.offer.tokenAddress, 'BM_FLASH_LOAN_TOKEN_ADDRESS_MATCH');\n\n        // OpenSkyBespokeBorrowNFT\n        IERC721(BESPOKE_SETTINGS.borrowLoanAddress()).safeTransferFrom(vars.borrower, address(this), vars.loanId);\n\n        // repay loan\n        vars.repayAmount =\n            IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).getPenalty(vars.loanId) +\n            IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).getBorrowBalance(vars.loanId);\n\n        require(vars.repayAmount <= amounts[0], 'BP_FLASH_LOAN_RECEIVE_MONEY_NOT_ENOUGH');\n\n        IERC20(assets[0]).approve(BESPOKE_SETTINGS.marketAddress(), vars.repayAmount);\n        IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).repay(vars.loanId);\n\n        // borrow again\n        // TODO: Need to support erc1155?\n        IERC721(loan.tokenAddress).approve(BESPOKE_SETTINGS.getNftTransferAdapter(loan.tokenAddress), loan.tokenId);\n\n        // only support single or colletcion offer\n        vars.newLoanId = IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).takeLendOffer(\n            vars.offer,\n            loan.tokenId,\n            vars.borrowAmount,\n            vars.borrowDuration,\n            address(this),\n            ''\n        );\n\n        vars.needInput = vars.repayAmount + premiums[0];\n\n        // transfer erc20\n        if (vars.borrowAmount > vars.needInput) {\n            IERC20(assets[0]).safeTransfer(vars.borrower, vars.borrowAmount - vars.needInput);\n        } else if (vars.borrowAmount < vars.needInput) {\n            IERC20(assets[0]).safeTransferFrom(vars.borrower, address(this), vars.needInput - vars.borrowAmount);\n        }\n\n        // transfer OpenSkyBespokeBorrowNFT\n        IERC721(BESPOKE_SETTINGS.borrowLoanAddress()).safeTransferFrom(address(this), vars.borrower, vars.newLoanId);\n\n        //repay flashloan\n        IERC20(assets[0]).approve(address(aavePool()), amounts[0] + premiums[0]);\n\n        emit RefinanceBespokeToBespoke(assets[0], vars.borrower, vars.loanId, vars.newLoanId);\n        return true;\n    }\n}\n"
    },
    "contracts/bespokemarket/transferAdaptersCollateral/TransferAdapterCollateralBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\n//import '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\nimport '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../libraries/BespokeTypes.sol';\nimport '../../interfaces/IOpenSkySettings.sol';\nimport '../../interfaces/IACLManager.sol';\nimport '../../interfaces/IOpenSkyFlashClaimReceiver.sol';\n\nimport '../interfaces/IOpenSkyBespokeSettings.sol';\nimport '../interfaces/IOpenSkyBespokeMarket.sol';\n\nimport '../interfaces/ITransferAdapterCollateralBase.sol';\nimport '../interfaces/ITransferAdapterNFT.sol';\n\nabstract contract TransferAdapterCollateralBase is\n    Context,\n    ReentrancyGuard,\n    ERC721Holder,\n    ERC1155Holder,\n    ITransferAdapterCollateralBase,\n    ITransferAdapterNFT\n{\n    using SafeERC20 for IERC20;\n\n    IOpenSkySettings public immutable SETTINGS;\n    IOpenSkyBespokeSettings public immutable BESPOKE_SETTINGS;\n\n    // Add a protective layer to prevent collateral be claimed as airdrop\n    // nftAddress=>amount\n    mapping(address => uint256) public nftBorrowStat;\n\n    constructor(address SETTINGS_, address BESPOKE_SETTINGS_) ReentrancyGuard() {\n        SETTINGS = IOpenSkySettings(SETTINGS_);\n        BESPOKE_SETTINGS = IOpenSkyBespokeSettings(BESPOKE_SETTINGS_);\n    }\n\n    modifier onlyMarket() {\n        require(_msgSender() == BESPOKE_SETTINGS.marketAddress(), 'BM_ACL_ONLY_BESPOKR_MARKET_CAN_CALL');\n        _;\n    }\n\n    /// @dev Only emergency admin can call functions marked by this modifier.\n    modifier onlyEmergencyAdmin() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isEmergencyAdmin(_msgSender()), 'BM_ACL_ONLY_EMERGENCY_ADMIN_CAN_CALL');\n        _;\n    }\n\n    modifier onlyAirdropOperator() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isAirdropOperator(_msgSender()), 'BM_ACL_ONLY_AIRDROP_OPERATOR_CAN_CALL');\n        _;\n    }\n    \n    /// @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n    /// direct transfers to the contract address.\n    /// @param token token to transfer\n    /// @param to recipient of the transfer\n    /// @param amount amount to send\n    function emergencyTokenTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyEmergencyAdmin {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    function flashClaim(\n        address receiverAddress,\n        uint256[] calldata loanIds,\n        bytes calldata params\n    ) external override {\n        uint256 i;\n        IOpenSkyFlashClaimReceiver receiver = IOpenSkyFlashClaimReceiver(receiverAddress);\n        // !!!CAUTION: receiver contract may reentry mint, burn, flashClaim again\n\n        // only loan owner can do flashClaim\n        address[] memory nftAddresses = new address[](loanIds.length);\n        uint256[] memory tokenIds = new uint256[](loanIds.length);\n        for (i = 0; i < loanIds.length; i++) {\n            require(\n                IERC721(BESPOKE_SETTINGS.borrowLoanAddress()).ownerOf(loanIds[i]) == _msgSender(),\n                'BM_FLASHCLAIM_CALLER_IS_NOT_OWNER'\n            );\n            BespokeTypes.LoanData memory loanData = IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).getLoanData(\n                loanIds[i]\n            );\n            require(loanData.status != BespokeTypes.LoanStatus.LIQUIDATABLE, 'BM_FLASHCLAIM_STATUS_ERROR');\n            nftAddresses[i] = loanData.tokenAddress;\n            tokenIds[i] = loanData.tokenId;\n        }\n\n        // step 1: moving underlying asset forward to receiver contract\n        for (i = 0; i < loanIds.length; i++) {\n            IERC721(nftAddresses[i]).safeTransferFrom(address(this), receiverAddress, tokenIds[i]);\n        }\n\n        // setup 2: execute receiver contract, doing something like aidrop\n        require(\n            receiver.executeOperation(nftAddresses, tokenIds, _msgSender(), address(this), params),\n            'BM_FLASHCLAIM_EXECUTOR_ERROR'\n        );\n\n        // setup 3: moving underlying asset backword from receiver contract\n        for (i = 0; i < loanIds.length; i++) {\n            IERC721(nftAddresses[i]).safeTransferFrom(receiverAddress, address(this), tokenIds[i]);\n            emit FlashClaim(receiverAddress, _msgSender(), nftAddresses[i], tokenIds[i]);\n        }\n    }\n\n    function claimERC20Airdrop(\n        address token,\n        address to,\n        uint256 amount\n    ) external override nonReentrant onlyAirdropOperator {\n        IERC20(token).safeTransfer(to, amount);\n        emit ClaimERC20Airdrop(token, to, amount);\n    }\n\n    function claimERC721Airdrop(\n        address token,\n        address to,\n        uint256[] calldata ids\n    ) external override nonReentrant onlyAirdropOperator {\n        require(nftBorrowStat[token] == 0, 'BM_CLAIM_ERC721_AIRDROP_NOT_SUPPORTED');\n        for (uint256 i = 0; i < ids.length; i++) {\n            IERC721(token).safeTransferFrom(address(this), to, ids[i]);\n        }\n        emit ClaimERC721Airdrop(token, to, ids);\n    }\n\n    function claimERC1155Airdrop(\n        address token,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override nonReentrant onlyAirdropOperator {\n        require(nftBorrowStat[token] == 0, 'BM_CLAIM_ERC1155_AIRDROP_NOT_SUPPORTED');\n        IERC1155(token).safeBatchTransferFrom(address(this), to, ids, amounts, data);\n        emit ClaimERC1155Airdrop(token, to, ids, amounts, data);\n    }\n\n    function transferCollateralIn(\n        address collection,\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) external override nonReentrant onlyMarket {\n        nftBorrowStat[collection] += 1;\n        _transferCollateralIn(collection, from, tokenId, amount);\n    }\n\n    function transferCollateralOut(\n        address collection,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) external override nonReentrant onlyMarket {\n        nftBorrowStat[collection] -= 1;\n        _transferCollateralOut(collection, to, tokenId, amount);\n    }\n\n    function transferCollateralOutOnForeclose(\n        address collection,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) public override nonReentrant onlyMarket {\n        nftBorrowStat[collection] -= 1;\n        _transferCollateralOutOnForeclose(collection, to, tokenId, amount);\n    }\n\n    function _transferCollateralIn(\n        address collection,\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) internal virtual;\n\n    function _transferCollateralOut(\n        address collection,\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) internal virtual;\n\n    function _transferCollateralOutOnForeclose(\n        address collection,\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) internal virtual;\n}\n"
    },
    "contracts/bespokemarket/interfaces/ITransferAdapterCollateralBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface ITransferAdapterCollateralBase {\n    event FlashClaim(address indexed receiver, address sender, address indexed nftAddress, uint256 indexed tokenId);\n    event ClaimERC20Airdrop(address indexed token, address indexed to, uint256 amount);\n    event ClaimERC721Airdrop(address indexed token, address indexed to, uint256[] ids);\n    event ClaimERC1155Airdrop(address indexed token, address indexed to, uint256[] ids, uint256[] amounts, bytes data);\n\n\n    /**\n * @notice Allows smart contracts to access the collateralized NFT within one transaction,\n     * as long as the amount taken plus a fee is returned\n     * @dev IMPORTANT There are security concerns for developers of flash loan receiver contracts that must be carefully considered\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashClaimReceiver interface\n     * @param loanIds The ID of loan being flash-borrowed\n     * @param params packed params to pass to the receiver as extra information\n     **/\n    function flashClaim(\n        address receiverAddress,\n        uint256[] calldata loanIds,\n        bytes calldata params\n    ) external;\n\n    /**\n     * @notice Claim the ERC20 token which has been airdropped to the loan contract\n     * @param token The address of the airdropped token\n     * @param to The address which will receive ERC20 token\n     * @param amount The amount of the ERC20 token\n     **/\n    function claimERC20Airdrop(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n\n    /**\n     * @notice Claim the ERC721 token which has been airdropped to the loan contract\n     * @param token The address of the airdropped token\n     * @param to The address which will receive the ERC721 token\n     * @param ids The ID of the ERC721 token\n     **/\n    function claimERC721Airdrop(\n        address token,\n        address to,\n        uint256[] calldata ids\n    ) external;\n\n    /**\n     * @notice Claim the ERC1155 token which has been airdropped to the loan contract\n     * @param token The address of the airdropped token\n     * @param to The address which will receive the ERC1155 tokens\n     * @param ids The ID of the ERC1155 token\n     * @param amounts The amount of the ERC1155 tokens\n     * @param data packed params to pass to the receiver as extra information\n     **/\n    function claimERC1155Airdrop(\n        address token,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/bespokemarket/interfaces/ITransferAdapterNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface ITransferAdapterNFT {\n    function transferCollateralIn(\n        address collection,\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) external;\n\n    function transferCollateralOut(\n        address collection,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) external;\n\n    function transferCollateralOutOnForeclose(\n        address collection,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) external;\n}\n"
    },
    "contracts/bespokemarket/transferAdaptersCollateral/TransferAdapterERC721Default.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport './TransferAdapterCollateralBase.sol';\n\ncontract TransferAdapterERC721Default is TransferAdapterCollateralBase {\n    constructor(address settings_, address bespoke_settings_)\n        TransferAdapterCollateralBase(settings_, bespoke_settings_)\n    {}\n\n    function _transferCollateralIn(\n        address collection,\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) internal override {\n        IERC721(collection).safeTransferFrom(from, address(this), tokenId);\n    }\n\n    function _transferCollateralOut(\n        address collection,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal override {\n        IERC721(collection).safeTransferFrom(address(this), to, tokenId);\n    }\n\n    function _transferCollateralOutOnForeclose(\n        address collection,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal override {\n        IERC721(collection).safeTransferFrom(address(this), to, tokenId);\n    }\n}\n"
    },
    "contracts/bespokemarket/transferAdaptersCollateral/TransferAdapterERC1155Default.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport './TransferAdapterCollateralBase.sol';\n\ncontract TransferAdapterERC1155Default is TransferAdapterCollateralBase {\n    constructor(address settings_, address bespoke_settings_)\n        TransferAdapterCollateralBase(settings_, bespoke_settings_)\n    {}\n\n    function _transferCollateralIn(\n        address collection,\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) internal override {\n        IERC1155(collection).safeTransferFrom(from, address(this), tokenId, amount, '');\n    }\n\n    function _transferCollateralOut(\n        address collection,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal override {\n        IERC1155(collection).safeTransferFrom(address(this), to, tokenId, amount, '');\n    }\n\n    function _transferCollateralOutOnForeclose(\n        address collection,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal override {\n        IERC1155(collection).safeTransferFrom(address(this), to, tokenId, amount, '');\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][account] = accountBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n}\n"
    },
    "contracts/mocks/governance/TimelockController.sol": {
      "content": "import \"@openzeppelin/contracts/governance/TimelockController.sol\";\n"
    },
    "contracts/mocks/cryptopunk/WrappedPunkMock.sol": {
      "content": "// File: contracts\\cryptopunk\\wrapped-punk\\WrappedPunk.sol\n\n//pragma solidity ^0.5.0;\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\n\nimport './UserProxy.sol';\nimport '../../dependencies/cryptopunk/ICryptoPunk.sol';\n\n\ncontract WrappedPunk is Ownable, ERC721, Pausable {\n\n    event ProxyRegistered(address user, address proxy);\n\n    // Instance of cryptopunk smart contract\n    ICryptoPunk private _punkContract;\n\n    // Mapping from user address to proxy address\n    mapping(address => address) private _proxies;\n\n    /**\n     * @dev Initializes the contract settings\n     */\n    constructor(address punkContract)\n    public\n    ERC721(\"Wrapped Cryptopunks\", \"WPUNKS\")\n    {\n        _punkContract = ICryptoPunk(punkContract);\n    }\n\n    /**\n     * @dev Gets address of cryptopunk smart contract\n     */\n    function punkContract()\n    public\n    view\n    returns (address)\n    {\n        return address(_punkContract);\n    }\n\n    /**\n     * @dev Sets the base URI for all token\n     */\n//    function setBaseURI(string memory baseUri)\n//    public\n//    onlyOwner\n//    {\n//        _setBaseURI(baseUri);\n//    }\n\n    /**\n     * @dev Triggers smart contract to stopped state\n     */\n    function pause()\n    public\n    onlyOwner\n    {\n        _pause();\n    }\n\n    /**\n     * @dev Returns smart contract to normal state\n     */\n    function unpause()\n    public\n    onlyOwner\n    {\n        _unpause();\n    }\n\n    /**\n     * @dev Registers proxy\n     */\n    function registerProxy()\n    public\n    {\n        address sender = _msgSender();\n\n        require(_proxies[sender] == address(0), \"PunkWrapper: caller has registered the proxy\");\n\n        address proxy = address(new UserProxy());\n\n        _proxies[sender] = proxy;\n\n        emit ProxyRegistered(sender, proxy);\n    }\n\n    /**\n     * @dev Gets proxy address\n     */\n    function proxyInfo(address user)\n    public\n    view\n    returns (address)\n    {\n        return _proxies[user];\n    }\n\n    /**\n     * @dev Mints a wrapped punk\n     */\n    function mint(uint256 punkIndex)\n    public\n    whenNotPaused\n    {\n        address sender = _msgSender();\n\n        UserProxy proxy = UserProxy(_proxies[sender]);\n        \n        require(proxy.transfer(address(_punkContract), punkIndex), \"PunkWrapper: transfer fail\");\n\n        _mint(sender, punkIndex);\n    }\n\n    /**\n     * @dev Burns a specific wrapped punk\n     */\n    function burn(uint256 punkIndex)\n    public\n    whenNotPaused\n    {\n        address sender = _msgSender();\n\n        require(_isApprovedOrOwner(sender, punkIndex), \"PunkWrapper: caller is not owner nor approved\");\n\n        _burn(punkIndex);\n\n        // Transfers ownership of punk on original cryptopunk smart contract to caller\n        _punkContract.transferPunk(sender, punkIndex);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given punk index to another address\n     */\n    function _transferFrom(address from, address to, uint256 punkIndex)\n    internal\n    whenNotPaused\n    {\n        // super._transferFrom(from, to, punkIndex);\n        super.safeTransferFrom(from, to, punkIndex);\n\n    }\n\n}\n"
    },
    "contracts/mocks/cryptopunk/UserProxy.sol": {
      "content": "// File: contracts\\cryptopunk\\wrapped-punk\\UserProxy.sol\n\n//pragma solidity ^0.5.0;\npragma solidity 0.8.10;\n\n\ncontract UserProxy {\n\n    address private _owner;\n\n    /**\n     * @dev Initializes the contract settings\n     */\n    constructor()\n    public\n    {\n        _owner = msg.sender;\n    }\n\n    /**\n     * @dev Transfers punk to the smart contract owner\n     */\n    function transfer(address punkContract, uint256 punkIndex)\n    external\n    returns (bool)\n    {\n        if (_owner != msg.sender) {\n            return false;\n        }\n\n        (bool result,) = punkContract.call(abi.encodeWithSignature(\"transferPunk(address,uint256)\", _owner, punkIndex));\n\n        return result;\n    }\n\n}\n"
    },
    "contracts/mocks/compound/CEther.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\n\ninterface ICEther is IERC20 {\n    function mint() external payable;\n\n    function mint(address to) external payable;\n\n    function redeemUnderlying(uint256 amount) external returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n}\n\ncontract CEther is Context, ERC20Burnable, ICEther {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function mint() external payable override {\n        _mint(_msgSender(), msg.value);\n    }\n\n    function mint(address to) external payable override {\n        _mint(to, msg.value);\n    }\n\n    function redeemUnderlying(uint256 amount) external override returns (uint256) {\n        _burn(_msgSender(), amount);\n\n        payable(_msgSender()).transfer(amount);\n    }\n\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return 94339312732;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function exchangeRateStored() external view override returns (uint256) {\n        return 1e18;\n    }\n}\n"
    },
    "contracts/liquidation/OpenSkyDaoLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\n\nimport '../interfaces/IOpenSkySettings.sol';\nimport '../interfaces/IOpenSkyLoan.sol';\nimport '../interfaces/IOpenSkyPool.sol';\nimport '../interfaces/IACLManager.sol';\nimport '../interfaces/IOpenSkyDaoLiquidator.sol';\nimport '../libraries/types/DataTypes.sol';\n\ncontract OpenSkyDaoLiquidator is Context, ERC721Holder, IOpenSkyDaoLiquidator {\n    using SafeERC20 for IERC20;\n    IOpenSkySettings public immutable SETTINGS;\n\n    modifier onlyLiquidationOperator() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isLiquidationOperator(_msgSender()), 'LIQUIDATION_ONLY_OPERATOR_CAN_CALL');\n        _;\n    }\n\n    constructor(address settings) {\n        SETTINGS = IOpenSkySettings(settings);\n    }\n\n    function startLiquidate(uint256 loanId) external override onlyLiquidationOperator {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n\n        IOpenSkyPool pool = IOpenSkyPool(SETTINGS.poolAddress());\n        pool.startLiquidation(loanId);\n\n        uint256 borrowBalance = loanNFT.getBorrowBalance(loanId);\n\n        // withdraw erc20 token from dao vault\n        IERC20 token = IERC20(pool.getReserveData(loanData.reserveId).underlyingAsset);\n        token.safeTransferFrom(SETTINGS.daoVaultAddress(), address(this), borrowBalance);\n        token.safeApprove(address(pool), borrowBalance);\n\n        pool.endLiquidation(loanId, borrowBalance);\n\n        // transfer NFT to dao vault\n        IERC721(loanData.nftAddress).safeTransferFrom(address(this), SETTINGS.daoVaultAddress(), loanData.tokenId);\n\n        emit Liquidate(loanId, loanData.nftAddress, loanData.tokenId, _msgSender());\n    }\n\n    function withdrawERC721ToDaoVault(address token, uint256 tokenId) external onlyLiquidationOperator {\n        IERC721(token).safeTransferFrom(address(this), SETTINGS.daoVaultAddress(), tokenId);\n        emit WithdrawERC721(token, tokenId, SETTINGS.daoVaultAddress());\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/IOpenSkyDaoLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyDaoLiquidator {\n    event Liquidate(uint256 indexed loanId, address indexed nftAddress, uint256 tokenId, address operator);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n\n    function startLiquidate(uint256 loanId) external;\n}\n"
    },
    "contracts/misc/OpenSkyWETHGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../dependencies/weth/IWETH.sol';\nimport '../interfaces/IOpenSkyWETHGateway.sol';\nimport '../interfaces/IOpenSkySettings.sol';\nimport '../interfaces/IOpenSkyPool.sol';\nimport '../interfaces/IOpenSkyOToken.sol';\nimport '../libraries/helpers/Errors.sol';\n\ncontract OpenSkyWETHGateway is IOpenSkyWETHGateway, Ownable, ERC721Holder {\n    using SafeERC20 for IERC20;\n\n    IWETH public immutable WETH;\n    IOpenSkySettings public immutable SETTINGS;\n\n    /**\n     * @dev Sets the WETH address and the OpenSkySettings address.\n     * @param weth Address of the Wrapped Ether contract\n     **/\n    constructor(IWETH weth, IOpenSkySettings settings) {\n        WETH = weth;\n        SETTINGS = settings;\n    }\n\n    /**\n     * @notice Infinite weth approves OpenSkyPool contract.\n     * @dev Only callable by the owner\n     **/\n    function authorizeLendingPoolWETH() external override onlyOwner {\n        address lendingPool = SETTINGS.poolAddress();\n        require(WETH.approve(lendingPool, type(uint256).max),Errors.APPROVAL_FAILED);\n        emit AuthorizeLendingPoolWETH(_msgSender());\n    }\n\n    /**\n     * @notice Infinite NFT approves OpenSkyPool contract.\n     * @dev Only callable by the owner\n     * @param nftAssets addresses of nft assets\n     **/\n    function authorizeLendingPoolNFT(address[] calldata nftAssets) external override onlyOwner {\n        address lendingPool = SETTINGS.poolAddress();\n        for (uint256 i = 0; i < nftAssets.length; i++) {\n            IERC721(nftAssets[i]).setApprovalForAll(lendingPool, true);\n        }\n        emit AuthorizeLendingPoolNFT(_msgSender(), nftAssets);\n    }\n\n    /**\n     * @dev deposits WETH into the reserve, using native ETH. A corresponding amount of the overlying asset (aTokens)\n     * is minted.\n     * @param reserveId address of the targeted underlying lending pool\n     * @param onBehalfOf address of the user who will receive the aTokens representing the deposit\n     * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n     **/\n    function deposit(\n        uint256 reserveId,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external payable override {\n        WETH.deposit{value: msg.value}();\n        IOpenSkyPool(SETTINGS.poolAddress()).deposit(reserveId, msg.value, onBehalfOf, referralCode);\n\n        emit Deposit(reserveId, onBehalfOf, msg.value);\n    }\n\n    /**\n     * @dev withdraws the WETH _reserves of msg.sender.\n     * @param reserveId address of the targeted underlying lending pool\n     * @param amount amount of aWETH to withdraw and receive native ETH\n     * @param onBehalfOf address of the user who will receive native ETH\n     */\n    function withdraw(\n        uint256 reserveId,\n        uint256 amount,\n        address onBehalfOf\n    ) external override {\n        IOpenSkyPool lendingPool = IOpenSkyPool(SETTINGS.poolAddress());\n        IERC20 oWETH = IERC20(lendingPool.getReserveData(reserveId).oTokenAddress);\n        uint256 userBalance = oWETH.balanceOf(msg.sender);\n        uint256 amountToWithdraw = amount;\n\n        // if amount is equal to uint256 max, the user wants to redeem everything\n        if (amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n        oWETH.safeTransferFrom(msg.sender, address(this), amountToWithdraw);\n        lendingPool.withdraw(reserveId, amountToWithdraw, address(this));\n        WETH.withdraw(amountToWithdraw);\n        _safeTransferETH(onBehalfOf, amountToWithdraw);\n\n        emit Withdraw(reserveId, onBehalfOf, amountToWithdraw);\n    }\n\n    /**\n     * @dev Borrows ETH from reserve using an NFT as collateral and will receive a loan NFT as receipt.\n     * @param reserveId The ID of the reserve\n     * @param amount amount of ETH user will borrow\n     * @param duration The desired duration of the loan\n     * @param nftAddress The collateral NFT address\n     * @param tokenId The ID of the NFT\n     * @param onBehalfOf address of the user who will receive ETH and loan NFT.\n     */\n    function borrow(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        address nftAddress,\n        uint256 tokenId,\n        address onBehalfOf\n    ) external override {\n        IERC721(nftAddress).safeTransferFrom(msg.sender, address(this), tokenId);\n        IOpenSkyPool lendingPool = IOpenSkyPool(SETTINGS.poolAddress());\n        uint256 loanId = lendingPool.borrow(reserveId, amount, duration, nftAddress, tokenId, onBehalfOf);\n        WETH.withdraw(amount);\n        _safeTransferETH(onBehalfOf, amount);\n\n        emit Borrow(reserveId, onBehalfOf, loanId);\n    }\n\n    /**\n     * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n     * @param loanId the id of reserve\n     */\n    function repay(uint256 loanId) external payable override {\n        WETH.deposit{value: msg.value}();\n\n        IOpenSkyPool lendingPool = IOpenSkyPool(SETTINGS.poolAddress());\n        uint256 repayAmount = lendingPool.repay(loanId);\n\n        require(msg.value >= repayAmount, Errors.REPAY_MSG_VALUE_ERROR);\n\n        // refund remaining dust eth\n        if (msg.value > repayAmount) {\n            uint256 refundAmount = msg.value - repayAmount;\n            WETH.withdraw(refundAmount);\n            _safeTransferETH(msg.sender, refundAmount);\n        }\n        emit Repay(loanId);\n    }\n\n    function extend(\n        uint256 loanId,\n        uint256 amount,\n        uint256 duration\n    ) external payable {\n        WETH.deposit{value: msg.value}();\n\n        IOpenSkyPool lendingPool = IOpenSkyPool(SETTINGS.poolAddress());\n        (uint256 inAmount, uint256 outAmount) = lendingPool.extend(loanId, amount, duration, _msgSender());\n\n        require(msg.value >= inAmount, Errors.EXTEND_MSG_VALUE_ERROR);\n\n        // refund eth\n        uint256 refundAmount;\n        if (msg.value > inAmount) {\n            refundAmount += msg.value - inAmount;\n        }\n        if (outAmount > 0) {\n            refundAmount += outAmount;\n        }\n        if (refundAmount > 0) {\n            WETH.withdraw(refundAmount);\n            _safeTransferETH(msg.sender, refundAmount);\n        }\n\n        emit Extend(loanId);\n    }\n\n    /**\n     * @dev transfer ETH to an address, revert if it fails.\n     * @param to recipient of the transfer\n     * @param value the amount to send\n     */\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, Errors.ETH_TRANSFER_FAILED);\n    }\n\n    /**\n     * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n     * direct transfers to the contract address.\n     * @param token token to transfer\n     * @param to recipient of the transfer\n     * @param amount amount to send\n     */\n    function emergencyTokenTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n        emit EmergencyTokenTransfer(_msgSender(), token, to, amount);\n    }\n\n    /**\n     * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n     * due selfdestructs or transfer ether to pre-computed contract address before deployment.\n     * @param to recipient of the transfer\n     * @param amount amount to send\n     */\n    function emergencyEtherTransfer(address to, uint256 amount) external override onlyOwner {\n        _safeTransferETH(to, amount);\n        emit EmergencyEtherTransfer(_msgSender(), to, amount);\n    }\n\n    /**\n     * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n     */\n    receive() external payable {\n        require(msg.sender == address(WETH), Errors.RECEIVE_NOT_ALLOWED);\n        emit Received(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Revert fallback calls\n     */\n    fallback() external payable {\n        revert(Errors.FALLBACK_NOT_ALLOWED);\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyWETHGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyWETHGateway {\n    event AuthorizeLendingPoolWETH(address indexed operator);\n    event AuthorizeLendingPoolNFT(address indexed operator, address[] nftAssets);\n    event EmergencyTokenTransfer(address indexed operator, address indexed token, address indexed to, uint256 amount);\n    event EmergencyEtherTransfer(address indexed operator, address indexed to, uint256 amount);\n\n    event Deposit(uint256 indexed reserveId, address indexed onBehalfOf, uint256 amount);\n    event Withdraw(uint256 indexed reserveId, address indexed onBehalfOf, uint256 amount);\n    event Borrow(uint256 indexed reserveId, address indexed onBehalfOf, uint256 indexed loanId);\n    event Repay(uint256 indexed loanId);\n    event Extend(uint256 indexed loanId);\n\n    event Received(address, uint256);\n\n    function authorizeLendingPoolWETH() external;\n\n    function authorizeLendingPoolNFT(address[] calldata nftAssets) external;\n\n    function deposit(\n        uint256 reserveId,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external payable;\n\n    function withdraw(\n        uint256 reserveId,\n        uint256 amount,\n        address onBehalfOf\n    ) external;\n\n    function borrow(\n        uint256 reserveId,\n        uint256 amount,\n        uint256 duration,\n        address nftAddress,\n        uint256 tokenId,\n        address onBehalfOf\n    ) external;\n\n    function repay(uint256 loanId) external payable;\n\n    function extend(\n        uint256 loanId,\n        uint256 amount,\n        uint256 duration\n    ) external payable;\n\n    function emergencyTokenTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n\n    function emergencyEtherTransfer(address to, uint256 amount) external;\n}\n"
    },
    "contracts/moneymarkets/AaveV3MoneyMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '../interfaces/IOpenSkyMoneyMarket.sol';\n\nimport '../dependencies/aave-v3/IPool.sol';\n\nimport '../libraries/helpers/Errors.sol';\n\ncontract AaveV3MoneyMarket is IOpenSkyMoneyMarket {\n    address private immutable original;\n\n    IPool public immutable aave;\n\n    constructor(IPool aave_) {\n        aave = aave_;\n        original = address(this);\n    }\n\n    function _requireDelegateCall() private view {\n        require(address(this) != original, Errors.MONEY_MARKET_REQUIRE_DELEGATE_CALL);\n    }\n\n    modifier requireDelegateCall() {\n        _requireDelegateCall();\n        _;\n    }\n\n    function depositCall(address asset, uint256 amount) external override requireDelegateCall {\n        require(amount > 0, Errors.MONEY_MARKET_DEPOSIT_AMOUNT_NOT_ALLOWED);\n        _approveToken(asset, amount);\n        aave.deposit(asset, amount, address(this), uint16(0));\n    }\n\n    function _approveToken(address asset, uint256 amount) internal virtual {\n        require(IERC20(asset).approve(address(aave), amount), Errors.MONEY_MARKET_APPROVAL_FAILED);\n    }\n\n    function withdrawCall(address asset, uint256 amount, address to) external override requireDelegateCall {\n        require(amount > 0, Errors.MONEY_MARKET_WITHDRAW_AMOUNT_NOT_ALLOWED);\n\n        _approveAToken(asset, amount);\n        uint256 withdrawn = aave.withdraw(asset, amount, to);\n        require(withdrawn == amount, Errors.MONEY_MARKET_WITHDRAW_AMOUNT_NOT_MATCH);\n    }\n\n    function _approveAToken(address asset, uint256 amount) internal virtual {\n        address aToken = getMoneyMarketToken(asset);\n        require(IERC20(aToken).approve(address(aave), amount), Errors.MONEY_MARKET_APPROVAL_FAILED);\n    }\n\n    function getMoneyMarketToken(address asset) public view override virtual returns (address) {\n        address aToken = aave.getReserveData(asset).aTokenAddress;\n\n        return aToken;\n    }\n\n    function getBalance(address asset, address account) external view override returns (uint256) {\n        address aToken = getMoneyMarketToken(asset);\n        return IERC20(aToken).balanceOf(account);\n    }\n\n    function getSupplyRate(address asset) external view override returns (uint256) {\n        return aave.getReserveData(asset).currentLiquidityRate;\n    }\n\n    receive() external payable {\n        revert('RECEIVE_NOT_ALLOWED');\n    }\n\n    fallback() external payable {\n        revert('FALLBACK_NOT_ALLOWED');\n    }\n}\n"
    },
    "contracts/dependencies/aave-v3/IPool.sol": {
      "content": "pragma solidity 0.8.10;\n\ninterface IPool {\n    struct ReserveConfigurationMap {\n        uint256 data;\n    }\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        //timestamp of last update\n        uint40 lastUpdateTimestamp;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint16 id;\n        //aToken address\n        address aTokenAddress;\n        //stableDebtToken address\n        address stableDebtTokenAddress;\n        //variableDebtToken address\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the current treasury balance, scaled\n        uint128 accruedToTreasury;\n        //the outstanding unbacked aTokens minted through the bridging feature\n        uint128 unbacked;\n        //the outstanding debt borrowed against this asset in isolation mode\n        uint128 isolationModeTotalDebt;\n    }\n\n    function getReserveData(address asset) external view returns (ReserveData memory);\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/AaveV2MoneyMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '../interfaces/IOpenSkyMoneyMarket.sol';\n\nimport '../dependencies/aave/ILendingPool.sol';\n\nimport '../libraries/helpers/Errors.sol';\n\ncontract AaveV2MoneyMarket is IOpenSkyMoneyMarket {\n    address private immutable original;\n\n    ILendingPool public immutable aave;\n\n    constructor(ILendingPool aave_) {\n        aave = aave_;\n        original = address(this);\n    }\n\n    function _requireDelegateCall() private view {\n        require(address(this) != original, Errors.MONEY_MARKET_REQUIRE_DELEGATE_CALL);\n    }\n\n    modifier requireDelegateCall() {\n        _requireDelegateCall();\n        _;\n    }\n\n    function depositCall(address asset, uint256 amount) external override requireDelegateCall {\n        require(amount > 0, Errors.MONEY_MARKET_DEPOSIT_AMOUNT_NOT_ALLOWED);\n        _approveToken(asset, amount);\n        aave.deposit(asset, amount, address(this), uint16(0));\n    }\n\n    function _approveToken(address asset, uint256 amount) internal virtual {\n        require(IERC20(asset).approve(address(aave), amount), Errors.MONEY_MARKET_APPROVAL_FAILED);\n    }\n\n    function withdrawCall(address asset, uint256 amount, address to) external override requireDelegateCall {\n        require(amount > 0, Errors.MONEY_MARKET_WITHDRAW_AMOUNT_NOT_ALLOWED);\n\n        _approveAToken(asset, amount);\n        uint256 withdrawn = aave.withdraw(asset, amount, to);\n        require(withdrawn == amount, Errors.MONEY_MARKET_WITHDRAW_AMOUNT_NOT_MATCH);\n    }\n\n    function _approveAToken(address asset, uint256 amount) internal virtual {\n        address aToken = getMoneyMarketToken(asset);\n        require(IERC20(aToken).approve(address(aave), amount), Errors.MONEY_MARKET_APPROVAL_FAILED);\n    }\n\n    function getMoneyMarketToken(address asset) public view override virtual returns (address) {\n        address aToken = aave.getReserveData(asset).aTokenAddress;\n\n        return aToken;\n    }\n\n    function getBalance(address asset, address account) external view override returns (uint256) {\n        address aToken = getMoneyMarketToken(asset);\n        return IERC20(aToken).balanceOf(account);\n    }\n\n    function getSupplyRate(address asset) external view override returns (uint256) {\n        return aave.getReserveData(asset).currentLiquidityRate;\n    }\n\n    receive() external payable {\n        revert('RECEIVE_NOT_ALLOWED');\n    }\n\n    fallback() external payable {\n        revert('FALLBACK_NOT_ALLOWED');\n    }\n}\n"
    },
    "contracts/dependencies/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface ILendingPool {\n    struct ReserveConfigurationMap {\n        uint256 data;\n    }\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (ReserveData memory);\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n"
    },
    "contracts/misc/OpenSkyLoanDelegator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../dependencies/weth/IWETH.sol\";\nimport \"../interfaces/IOpenSkySettings.sol\";\nimport \"../interfaces/IOpenSkyPool.sol\";\nimport \"../interfaces/IOpenSkyLoan.sol\";\n\ncontract OpenSkyLoanDelegator is ERC721Holder {\n    using SafeERC20 for IERC20;\n\n    IWETH public WETH;\n    IOpenSkySettings public SETTINGS;\n\n    mapping(address => mapping(address => mapping(uint256 => address))) public delegators;\n    mapping(address => mapping(uint256 => address)) public loanOwners;\n\n    event Delegate(address indexed sender, address indexed delegator, uint256 indexed loanId);\n    event ExtendETH(address indexed sender, uint256 indexed loanId, uint256 amount, uint256 duration);\n    event Extend(\n        address indexed sender,\n        uint256 indexed loanId,\n        address indexed underlyingAsset,\n        uint256 amount,\n        uint256 duration\n    );\n    event RepayETH(address indexed sender, uint256 indexed loanId, uint256 amount);\n    event Repay(address indexed sender, uint256 indexed loanId, address indexed underlyingAsset, uint256 amount);\n    event ClaimNFT(address indexed sender, address indexed nftAddress, uint256 indexed tokenId);\n    event SetDelegatorForAll(address indexed sender, address indexed delegator, bool isDelegated);\n\n    event Received(address indexed sender, uint256 amount);\n\n    constructor(IWETH weth, IOpenSkySettings settings) {\n        WETH = weth;\n        SETTINGS = settings;\n    }\n\n    function delegate(address delegator, uint256 loanId) external {\n        if (delegator != address(0)) {\n            _delegate(delegator, loanId);\n        } else {\n            _undelegate(loanId);\n        }\n        emit Delegate(msg.sender, delegator, loanId);\n    }\n\n    function _delegate(address delegator, uint256 loanId) internal {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loan = loanNFT.getLoanData(loanId);\n        require(loanNFT.ownerOf(loanId) == msg.sender || getLoanOwner(loan.nftAddress, loan.tokenId) == msg.sender, \"ONLY_OWNER\");\n        address owner = msg.sender;\n\n        if (loanOwners[loan.nftAddress][loan.tokenId] != owner) {\n            loanOwners[loan.nftAddress][loan.tokenId] = owner;\n        }\n\n        if (loanNFT.ownerOf(loanId) != address(this)) {\n            loanNFT.safeTransferFrom(owner, address(this), loanId);\n        }\n\n        delegators[owner][loan.nftAddress][loan.tokenId] = delegator;\n    }\n\n    function _undelegate(uint256 loanId) internal {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loan = loanNFT.getLoanData(loanId);\n        address owner = getLoanOwner(loan.nftAddress, loan.tokenId);\n        require(owner == msg.sender, \"ONLY_OWNER\");\n\n        loanNFT.safeTransferFrom(address(this), owner, loanId);\n\n        delete delegators[owner][loan.nftAddress][loan.tokenId];\n        delete loanOwners[loan.nftAddress][loan.tokenId];\n    }\n\n    function getDelegator(address owner, address nftAddress, uint256 tokenId) public view returns (address) {\n        return delegators[owner][nftAddress][tokenId];\n    }\n\n    function getLoanOwner(address nftAddress, uint256 tokenId) public view returns (address) {\n        return loanOwners[nftAddress][tokenId];\n    }\n\n    function extendETH(\n        uint256 loanId,\n        uint256 amount,\n        uint256 duration\n    ) external payable {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loan = loanNFT.getLoanData(loanId);\n\n        require(_isDelegatorOrOwner(msg.sender, loan.nftAddress, loan.tokenId), \"ONLY_OWNER_OR_DELEGATOR\");\n\n        WETH.deposit{value: msg.value}();\n\n        IOpenSkyPool lendingPool = IOpenSkyPool(SETTINGS.poolAddress());\n        IERC20(address(WETH)).approve(SETTINGS.poolAddress(), msg.value);\n        (uint256 inAmount, uint256 outAmount) = lendingPool.extend(loanId, amount, duration, address(this));\n\n        require(msg.value >= inAmount, \"EXTEND_MSG_VALUE_ERROR\");\n\n        if (msg.value > inAmount) {\n            uint256 refundAmount = msg.value - inAmount;\n            WETH.withdraw(refundAmount);\n            _safeTransferETH(msg.sender, refundAmount);\n        }\n        if (outAmount > 0) {\n            WETH.withdraw(outAmount);\n            _safeTransferETH(getLoanOwner(loan.nftAddress, loan.tokenId), outAmount);\n        }\n\n        emit ExtendETH(msg.sender, loanId, amount, duration);\n    }\n\n    function extend(\n        uint256 loanId,\n        uint256 extendAmount,\n        uint256 duration,\n        uint256 amount\n    ) external {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loan = loanNFT.getLoanData(loanId);\n\n        require(_isDelegatorOrOwner(msg.sender, loan.nftAddress, loan.tokenId), \"ONLY_OWNER_OR_DELEGATOR\");\n\n        IOpenSkyPool lendingPool = IOpenSkyPool(SETTINGS.poolAddress());\n        DataTypes.ReserveData memory reserve = lendingPool.getReserveData(loan.reserveId);\n\n        if (amount > 0) {\n            IERC20(reserve.underlyingAsset).safeTransferFrom(msg.sender, address(this), amount);\n            IERC20(reserve.underlyingAsset).approve(SETTINGS.poolAddress(), amount);\n        }\n\n        (uint256 inAmount, uint256 outAmount) = lendingPool.extend(loanId, extendAmount, duration, address(this));\n\n        if (amount > inAmount) {\n            uint256 refundAmount = amount - inAmount;\n            IERC20(reserve.underlyingAsset).safeTransfer(msg.sender, refundAmount);\n        }\n        if (outAmount > 0) {\n            IERC20(reserve.underlyingAsset).safeTransfer(getLoanOwner(loan.nftAddress, loan.tokenId), outAmount);\n        }\n\n        emit Extend(msg.sender, loanId, reserve.underlyingAsset, amount, duration);\n    }\n\n    function repayETH(uint256 loanId) external payable {\n        DataTypes.LoanData memory loan = IOpenSkyLoan(SETTINGS.loanAddress()).getLoanData(loanId);\n        require(_hasDelegator(loan.nftAddress, loan.tokenId), \"NO_DELEGATOR\");\n\n        WETH.deposit{value: msg.value}();\n\n        IOpenSkyPool lendingPool = IOpenSkyPool(SETTINGS.poolAddress());\n\n        IERC20(address(WETH)).approve(SETTINGS.poolAddress(), msg.value);\n        uint256 repayAmount = lendingPool.repay(loanId);\n\n        require(msg.value >= repayAmount, \"REPAY_MSG_VALUE_ERROR\");\n\n        address owner = getLoanOwner(loan.nftAddress, loan.tokenId);\n        IERC721(loan.nftAddress).safeTransferFrom(address(this), owner, loan.tokenId);\n\n        if (msg.value > repayAmount) {\n            uint256 refundAmount = msg.value - repayAmount;\n            WETH.withdraw(refundAmount);\n            _safeTransferETH(msg.sender, refundAmount);\n        }\n\n        delete delegators[owner][loan.nftAddress][loan.tokenId];\n        delete loanOwners[loan.nftAddress][loan.tokenId];\n\n        emit RepayETH(msg.sender, loanId, repayAmount);\n    }\n\n    function repay(uint256 loanId, uint256 amount) external {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        DataTypes.LoanData memory loan = loanNFT.getLoanData(loanId);\n        require(_hasDelegator(loan.nftAddress, loan.tokenId), \"NO_DELEGATOR\");\n\n        IOpenSkyPool lendingPool = IOpenSkyPool(SETTINGS.poolAddress());\n        DataTypes.ReserveData memory reserve = lendingPool.getReserveData(loan.reserveId);\n\n        IERC20(reserve.underlyingAsset).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(reserve.underlyingAsset).approve(SETTINGS.poolAddress(), amount);\n\n        uint256 repayAmount = lendingPool.repay(loanId);\n\n        require(amount >= repayAmount, \"REPAY_MSG_VALUE_ERROR\");\n\n        address owner = getLoanOwner(loan.nftAddress, loan.tokenId);\n        IERC721(loan.nftAddress).safeTransferFrom(address(this), owner, loan.tokenId);\n\n        if (amount > repayAmount) {\n            uint256 refundAmount = amount - repayAmount;\n            IERC20(reserve.underlyingAsset).safeTransfer(msg.sender, refundAmount);\n        }\n\n        delete delegators[owner][loan.nftAddress][loan.tokenId];\n        delete loanOwners[loan.nftAddress][loan.tokenId];\n\n        emit Repay(msg.sender, loanId, reserve.underlyingAsset, repayAmount);\n    }\n\n    function claimNFT(address nftAddress, uint256 tokenId) external {\n        require(_isDelegatorOrOwner(msg.sender, nftAddress, tokenId), \"ONLY_OWNER_OR_DELEGATOR\");\n\n        address owner = getLoanOwner(nftAddress, tokenId);\n        IERC721(nftAddress).safeTransferFrom(address(this), owner, tokenId);\n\n        delete delegators[owner][nftAddress][tokenId];\n        delete loanOwners[nftAddress][tokenId];\n\n        emit ClaimNFT(msg.sender, nftAddress, tokenId);\n    }\n\n    function _isDelegatorOrOwner(address sender, address nftAddress, uint256 tokenId) internal view returns (bool) {\n        address owner = getLoanOwner(nftAddress, tokenId);\n        return owner == sender || getDelegator(owner, nftAddress, tokenId) == sender;\n    }\n\n    function _hasDelegator(address nftAddress, uint256 tokenId) internal view returns (bool) {\n        address owner = getLoanOwner(nftAddress, tokenId);\n        return delegators[owner][nftAddress][tokenId] != address(0);\n    }\n\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    receive() external payable {\n        require(msg.sender == address(WETH), \"RECEIVE_NOT_ALLOWED\");\n        emit Received(msg.sender, msg.value);\n    }\n}\n"
    },
    "contracts/liquidation/OpenSkyDutchAuctionLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"../interfaces/IOpenSkySettings.sol\";\nimport \"../interfaces/IOpenSkyLoan.sol\";\nimport \"../interfaces/IOpenSkyPool.sol\";\nimport \"../interfaces/IACLManager.sol\";\nimport \"../interfaces/IOpenSkyDutchAuctionPriceOracle.sol\";\nimport \"../dependencies/weth/IWETH.sol\";\nimport \"../libraries/math/WadRayMath.sol\";\nimport \"../libraries/types/DataTypes.sol\";\n\ncontract OpenSkyDutchAuctionLiquidator is ERC721Holder {\n    using SafeERC20 for IERC20;\n    using WadRayMath for uint128;\n\n    event Liquidate(address indexed sender, uint256 indexed loanId, uint256 price, address nftAddress, uint256 tokenId);\n\n    IOpenSkySettings public immutable SETTINGS;\n    IWETH public immutable WETH;\n    IOpenSkyDutchAuctionPriceOracle public priceOracle;\n\n    modifier onlyGovernance() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isGovernance(msg.sender), \"ONLY_GOVERNANCE\");\n        _;\n    }\n\n    constructor(address settings, address weth, address _priceOracle) {\n        SETTINGS = IOpenSkySettings(settings);\n        WETH = IWETH(weth);\n        priceOracle = IOpenSkyDutchAuctionPriceOracle(_priceOracle);\n    }\n\n    function setPriceOracle(address _priceOracle) external onlyGovernance {\n        priceOracle = IOpenSkyDutchAuctionPriceOracle(_priceOracle);\n    }\n\n    function liquidateETH(uint256 loanId) external payable {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n\n        uint256 price = getPrice(loanId);\n        uint256 borrowBalance = loanNFT.getBorrowBalance(loanId);\n        require(msg.value >= price, \"INSUFFICIENT_AMOUNT\");\n        require(price > borrowBalance, \"PRICE_ERROR\");\n\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n\n        // start liquidation\n        IOpenSkyPool(SETTINGS.poolAddress()).startLiquidation(loanId);\n        \n        WETH.deposit{value: borrowBalance}();\n\n        // end liquidation\n        WETH.approve(SETTINGS.poolAddress(), borrowBalance);\n        IOpenSkyPool(SETTINGS.poolAddress()).endLiquidation(loanId, borrowBalance);\n\n        IERC721(loanData.nftAddress).safeTransferFrom(\n            address(this),\n            msg.sender,\n            loanData.tokenId\n        );\n\n        _safeTransferETH(SETTINGS.treasuryAddress(), price - borrowBalance);\n\n        if (msg.value > price) {\n            _safeTransferETH(msg.sender, msg.value - price);\n        }\n    }\n\n    function liquidate(uint256 loanId) public {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n        uint256 price = getPrice(loanId);\n        uint256 borrowBalance = loanNFT.getBorrowBalance(loanId);\n        require(price > borrowBalance, \"PRICE_ERROR\");\n\n        // start liquidation\n        IOpenSkyPool(SETTINGS.poolAddress()).startLiquidation(loanId);\n\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n        DataTypes.ReserveData memory reserveData = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(loanData.reserveId);\n\n        IERC20(reserveData.underlyingAsset).safeTransferFrom(msg.sender, address(this), price);\n\n        // end liquidation\n        IERC20(reserveData.underlyingAsset).safeApprove(SETTINGS.poolAddress(), borrowBalance);\n        IOpenSkyPool(SETTINGS.poolAddress()).endLiquidation(loanId, borrowBalance);\n\n        // transfer rewards to treasury\n        IERC20(reserveData.underlyingAsset).safeTransfer(SETTINGS.treasuryAddress(), price - borrowBalance);\n\n        IERC721(loanData.nftAddress).safeTransferFrom(\n            address(this),\n            msg.sender,\n            loanData.tokenId\n        );\n        \n        emit Liquidate(msg.sender, loanId, price, loanData.nftAddress, loanData.tokenId);\n    }\n\n    function getPrice(uint256 loanId) public view returns (uint256) {\n        IOpenSkyLoan loanNFT = IOpenSkyLoan(SETTINGS.loanAddress());\n\n        require(loanNFT.getStatus(loanId) == DataTypes.LoanStatus.LIQUIDATABLE, \"LOAN_STATUS_ERROR\");\n\n        DataTypes.LoanData memory loanData = loanNFT.getLoanData(loanId);\n        uint256 borrowBalance = loanNFT.getBorrowBalance(loanId);\n\n        return priceOracle.getPrice(borrowBalance, loanData.liquidatableTime);\n    }\n\n    function _safeTransferETH(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/interfaces/IOpenSkyDutchAuctionPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IOpenSkyDutchAuctionPriceOracle {\n    function getPrice(uint256 loanAmount, uint256 startTime) external view returns (uint256);\n}\n"
    },
    "contracts/bespokemarket/libraries/BespokeLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\nimport '../../libraries/math/MathUtils.sol';\nimport '../../libraries/math/WadRayMath.sol';\nimport '../../libraries/math/PercentageMath.sol';\n\nimport '../interfaces/IOpenSkyBespokeSettings.sol';\nimport '../interfaces/IOpenSkyBespokeLoanNFT.sol';\nimport './BespokeTypes.sol';\nimport './SignatureChecker.sol';\n\nlibrary BespokeLogic {\n    using PercentageMath for uint256;\n    using WadRayMath for uint256;\n\n    // keccak256(\"Offer(bool isProrated,bool autoConvertWhenRepay,uint8 offerType,address tokenAddress,uint256 tokenId,uint256 tokenAmount,address signer,uint256 borrowAmountMin,uint256 borrowAmountMax,uint40 borrowDurationMin,uint40 borrowDurationMax,uint128 borrowRate,address currency,address lendAsset,uint256 nonce,uint256 nonceMaxTimes,uint256 deadline,address strategy,bytes params)\")\n    bytes32 internal constant OFFER_HASH = 0x5898afb02f4982fe09fa9b4daac8eb8efd917a7c9412c0671717c798ae97aa99;\n\n    function hashOffer(BespokeTypes.Offer memory offerData) public pure returns (bytes32) {\n        return\n            keccak256(\n                bytes.concat(\n                    abi.encode(\n                        OFFER_HASH,\n                        offerData.isProrated,\n                        offerData.autoConvertWhenRepay,\n                        offerData.offerType,\n                        offerData.tokenAddress,\n                        offerData.tokenId,\n                        offerData.tokenAmount,\n                        offerData.signer,\n                        offerData.borrowAmountMin,\n                        offerData.borrowAmountMax,\n                        offerData.borrowDurationMin,\n                        offerData.borrowDurationMax,\n                        offerData.borrowRate\n                    ),\n                    abi.encode(\n                        offerData.currency,\n                        offerData.lendAsset,\n                        offerData.nonce,\n                        offerData.nonceMaxTimes,\n                        offerData.deadline,\n                        offerData.strategy,\n                        keccak256(offerData.params)\n                    )\n                )\n            );\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n                    0xf0cf7ce475272740cae17eb3cadd6d254800be81c53f84a2f273b99036471c62, // keccak256(\"OpenSkyBespokeMarket\")\n                    0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\")) for versionId = 1\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    function validateOfferCommon(\n        mapping(address => mapping(uint256 => BespokeTypes.NonceInfo)) storage _nonce,\n        mapping(address => uint256) storage minNonce,\n        BespokeTypes.Offer memory offerData,\n        bytes32 offerHash,\n        uint256 amount,\n        uint256 duration,\n        bytes32 DOMAIN_SEPARATOR,\n        IOpenSkyBespokeSettings BESPOKE_SETTINGS //,\n    ) public view {\n        // check nonce\n        require(\n            !_nonce[offerData.signer][offerData.nonce].invalid && offerData.nonce >= minNonce[offerData.signer],\n            'BM_TAKE_OFFER_NONCE_INVALID'\n        );\n        require(offerData.nonceMaxTimes >= 1, 'BM_TAKE_OFFER_NONCE_MAX_TIMES_INVALIDE');\n\n        require(\n            _nonce[offerData.signer][offerData.nonce].usedTimes < offerData.nonceMaxTimes,\n            'BM_TAKE_OFFER_NONCE_EXHAUST'\n        );\n\n        if (_nonce[offerData.signer][offerData.nonce].offerHash != 0) {\n            require(\n                _nonce[offerData.signer][offerData.nonce].offerHash == offerHash,\n                'BM_TAKE_OFFER_NONCE_USED_BY_OTHER_OFFER'\n            );\n        }\n\n        require(BESPOKE_SETTINGS.isCurrencyWhitelisted(offerData.currency), 'BM_TAKE_BORROW_CURRENCY_NOT_IN_WHITELIST');\n\n        require(\n            !BESPOKE_SETTINGS.isWhitelistOn() || BESPOKE_SETTINGS.inWhitelist(offerData.tokenAddress),\n            'BM_TAKE_BORROW_NFT_NOT_IN_WHITELIST'\n        );\n\n        require(block.timestamp <= offerData.deadline, 'BM_TAKE_BORROW_SIGNING_EXPIRATION');\n\n        (uint256 minBorrowDuration, uint256 maxBorrowDuration, ) = BESPOKE_SETTINGS.getBorrowDurationConfig(\n            offerData.tokenAddress\n        );\n\n        // check borrow duration\n        require(\n            offerData.borrowDurationMin <= offerData.borrowDurationMax &&\n                offerData.borrowDurationMin >= minBorrowDuration &&\n                offerData.borrowDurationMax <= maxBorrowDuration,\n            'BM_TAKE_BORROW_OFFER_DURATION_NOT_ALLOWED'\n        );\n\n        require(\n            duration > 0 && duration >= offerData.borrowDurationMin && duration <= offerData.borrowDurationMax,\n            'BM_TAKE_BORROW_TAKER_DURATION_NOT_ALLOWED'\n        );\n\n        // check borrow amount\n        require(\n            offerData.borrowAmountMin > 0 && offerData.borrowAmountMin <= offerData.borrowAmountMax,\n            'BM_TAKE_BORROW_OFFER_AMOUNT_NOT_ALLOWED'\n        );\n\n        require(\n            amount >= offerData.borrowAmountMin && amount <= offerData.borrowAmountMax,\n            'BM_TAKE_BORROW_SUPPLY_AMOUNT_NOT_ALLOWED'\n        );\n        require(\n            SignatureChecker.verify(\n                offerHash,\n                offerData.signer,\n                offerData.v,\n                offerData.r,\n                offerData.s,\n                DOMAIN_SEPARATOR\n            ),\n            'BM_TAKE_BORROW_SIGNATURE_INVALID'\n        );\n    }\n\n    function createLoan(\n        mapping(uint256 => BespokeTypes.LoanData) storage _loans,\n        BespokeTypes.Offer memory offerData,\n        uint256 loanId,\n        uint256 supplyAmount,\n        uint256 supplyDuration,\n        address nftManager,\n        uint256 tokenId,\n        IOpenSkyBespokeSettings BESPOKE_SETTINGS\n    ) public {\n        uint256 borrowRateRay = uint256(offerData.borrowRate).rayDiv(10000);\n        (, , uint256 overdueDuration) = BESPOKE_SETTINGS.getBorrowDurationConfig(offerData.tokenAddress);\n\n        BespokeTypes.LoanData memory loan = BespokeTypes.LoanData({\n            tokenAddress: offerData.tokenAddress,\n            tokenId: tokenId,\n            tokenAmount: offerData.tokenAmount,\n            nftManager: nftManager,\n            borrower: offerData.offerType == BespokeTypes.OfferType.BORROW ? offerData.signer : msg.sender,\n            lender: offerData.offerType == BespokeTypes.OfferType.BORROW ? msg.sender : offerData.signer,\n            amount: supplyAmount,\n            borrowRate: uint128(borrowRateRay),\n            interestPerSecond: uint128(MathUtils.calculateBorrowInterestPerSecond(borrowRateRay, supplyAmount)),\n            currency: offerData.currency,\n            lendAsset: offerData.lendAsset,\n            reserveFactor: BESPOKE_SETTINGS.reserveFactor(),\n            overdueLoanFeeFactor: BESPOKE_SETTINGS.overdueLoanFeeFactor(),\n            borrowDuration: uint40(supplyDuration),\n            borrowBegin: uint40(block.timestamp),\n            borrowOverdueTime: uint40(block.timestamp + supplyDuration),\n            liquidatableTime: uint40(block.timestamp + supplyDuration + overdueDuration),\n            isProrated: offerData.isProrated,\n            autoConvertWhenRepay: offerData.autoConvertWhenRepay,\n            status: BespokeTypes.LoanStatus.BORROWING\n        });\n\n        _loans[loanId] = loan;\n    }\n\n    function getLoanStatus(BespokeTypes.LoanData memory loan) public view returns (BespokeTypes.LoanStatus) {\n        BespokeTypes.LoanStatus status = loan.status;\n        if (status == BespokeTypes.LoanStatus.BORROWING) {\n            if (loan.liquidatableTime < block.timestamp) {\n                status = BespokeTypes.LoanStatus.LIQUIDATABLE;\n            } else if (loan.borrowOverdueTime < block.timestamp) {\n                status = BespokeTypes.LoanStatus.OVERDUE;\n            }\n        }\n        return status;\n    }\n\n    function getLoanDataWithStatus(BespokeTypes.LoanData memory loan)\n        public\n        view\n        returns (BespokeTypes.LoanData memory)\n    {\n        loan.status = getLoanStatus(loan);\n        return loan;\n    }\n\n    function getLoanParties(IOpenSkyBespokeSettings BESPOKE_SETTINGS, uint256 loanId)\n        public\n        view\n        returns (address borrower, address lender)\n    {\n        lender = IERC721(BESPOKE_SETTINGS.lendLoanAddress()).ownerOf(loanId);\n        borrower = IERC721(BESPOKE_SETTINGS.borrowLoanAddress()).ownerOf(loanId);\n    }\n\n    function getBorrowInterest(BespokeTypes.LoanData memory loan) public view returns (uint256) {\n        uint256 endTime = block.timestamp < loan.borrowOverdueTime\n            ? (loan.isProrated ? block.timestamp : loan.borrowOverdueTime)\n            : loan.borrowOverdueTime;\n        return uint256(loan.interestPerSecond).rayMul(endTime -loan.borrowBegin);\n    }\n\n    // @dev principal + interest\n    function getBorrowBalance(BespokeTypes.LoanData memory loan) public view returns (uint256) {\n        return loan.amount + getBorrowInterest(loan);\n    }\n\n    function getPenalty(BespokeTypes.LoanData memory loan) public view returns (uint256) {\n        BespokeTypes.LoanData memory loan = getLoanDataWithStatus(loan);\n        uint256 penalty = 0;\n        if (loan.status == BespokeTypes.LoanStatus.OVERDUE) {\n            penalty = loan.amount.percentMul(loan.overdueLoanFeeFactor);\n        }\n        return penalty;\n    }\n\n    function calculateRepayAmountAndProtocolFee(BespokeTypes.LoanData memory loan)\n        public\n        view\n        returns (\n            uint256 total,\n            uint256 lenderAmount,\n            uint256 protocolFee\n        )\n    {\n        uint256 penalty = getPenalty(loan);\n        total = getBorrowBalance(loan) + penalty;\n        protocolFee = (getBorrowInterest(loan) + penalty).percentMul(loan.reserveFactor);\n        lenderAmount = total - protocolFee;\n    }\n\n    function burnLoanNft(\n        mapping(uint256 => BespokeTypes.LoanData) storage _loans,\n        uint256 tokenId,\n        IOpenSkyBespokeSettings BESPOKE_SETTINGS\n    ) public {\n        IOpenSkyBespokeLoanNFT(BESPOKE_SETTINGS.borrowLoanAddress()).burn(tokenId);\n        IOpenSkyBespokeLoanNFT(BESPOKE_SETTINGS.lendLoanAddress()).burn(tokenId);\n        delete _loans[tokenId];\n    }\n\n    function mintLoanNFT(\n        BespokeTypes.Counter storage _loanIdTracker,\n        address borrower,\n        address lender,\n        IOpenSkyBespokeSettings BESPOKE_SETTINGS\n    ) internal returns (uint256) {\n        _loanIdTracker._value = _loanIdTracker._value + 1;\n        uint256 tokenId = _loanIdTracker._value;\n\n        IOpenSkyBespokeLoanNFT(BESPOKE_SETTINGS.borrowLoanAddress()).mint(tokenId, borrower);\n        IOpenSkyBespokeLoanNFT(BESPOKE_SETTINGS.lendLoanAddress()).mint(tokenId, lender);\n\n        return tokenId;\n    }\n}\n"
    },
    "contracts/bespokemarket/interfaces/IOpenSkyBespokeLoanNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '../libraries/BespokeTypes.sol';\n\ninterface IOpenSkyBespokeLoanNFT is IERC721 {\n    event Mint(uint256 indexed tokenId, address indexed recipient);\n    event Burn(uint256 tokenId);\n    event SetLoanDescriptorAddress(address operator, address descriptorAddress);\n\n    function mint(uint256 tokenId, address account) external;\n\n    function burn(uint256 tokenId) external;\n\n    function getLoanData(uint256 tokenId) external returns (BespokeTypes.LoanData memory);\n}\n"
    },
    "contracts/bespokemarket/libraries/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\n\n/**\n * @title SignatureChecker\n * @notice This library allows verification of signatures for both EOAs and contracts.\n */\nlibrary SignatureChecker {\n    /**\n     * @notice Recovers the signer of a signature (for EOA)\n     * @param hash the hash containing the signed mesage\n     * @param v parameter (27 or 28). This prevents maleability since the public key recovery equation has two possible solutions.\n     * @param r parameter\n     * @param s parameter\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // https://ethereum.stackexchange.com/questions/83174/is-it-best-practice-to-check-signature-malleability-in-ecrecover\n        // https://crypto.iacr.org/2019/affevents/wac/medias/Heninger-BiasedNonceSense.pdf\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            'BM_SIGNATURE_INVALID_S_PARAMETER'\n        );\n\n        require(v == 27 || v == 28, 'BM_SIGNATURE_INVALID_V_PARAMETER');\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), 'BM_SIGNATURE_INVALID_SIGNER');\n\n        return signer;\n    }\n\n    /**\n     * @notice Returns whether the signer matches the signed message\n     * @param hash the hash containing the signed mesage\n     * @param signer the signer address to confirm message validity\n     * @param v parameter (27 or 28)\n     * @param r parameter\n     * @param s parameter\n     * @param domainSeparator paramer to prevent signature being executed in other chains and environments\n     * @return true --> if valid // false --> if invalid\n     */\n    function verify(\n        bytes32 hash,\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes32 domainSeparator\n    ) internal view returns (bool) {\n        // \\x19\\x01 is the standardized encoding prefix\n        // https://eips.ethereum.org/EIPS/eip-712#specification\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, hash));\n        if (Address.isContract(signer)) {\n            // 0x1626ba7e is the interfaceId for signature contracts (see IERC1271)\n            return IERC1271(signer).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e;\n        } else {\n            return recover(digest, v, r, s) == signer;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "contracts/bespokemarket/OpenSkyBespokeMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nimport './libraries/BespokeTypes.sol';\nimport './libraries/BespokeLogic.sol';\nimport './libraries/TakeLendOfferLogic.sol';\nimport './libraries/TakeBorrowOfferLogic.sol';\nimport './libraries/RepayLogic.sol';\nimport './libraries/ForecloseLogic.sol';\n\nimport '../interfaces/IOpenSkySettings.sol';\nimport '../interfaces/IACLManager.sol';\nimport './interfaces/IOpenSkyBespokeSettings.sol';\nimport './interfaces/IOpenSkyBespokeMarket.sol';\n\n/**\n * @title OpenSkyBespokeMarket contract\n * @author OpenSky Labs\n * @notice Main point of interaction with OpenSky protocol's bespoke market\n * - Users can:\n *   # takeBorrowOffer\n *   # takeLendOffer\n *   # repay\n *   # foreclose\n **/\ncontract OpenSkyBespokeMarket is Context, Pausable, ReentrancyGuard, IOpenSkyBespokeMarket {\n    using SafeERC20 for IERC20;\n\n    IOpenSkySettings public immutable SETTINGS;\n    IOpenSkyBespokeSettings public immutable BESPOKE_SETTINGS;\n\n    mapping(address => uint256) public minNonce;\n    mapping(address => mapping(uint256 => BespokeTypes.NonceInfo)) public _nonce;\n\n    BespokeTypes.Counter private _loanIdTracker;\n\n    mapping(uint256 => BespokeTypes.LoanData) internal _loans;\n\n    constructor(address SETTINGS_, address BESPOKE_SETTINGS_) Pausable() ReentrancyGuard() {\n        SETTINGS = IOpenSkySettings(SETTINGS_);\n        BESPOKE_SETTINGS = IOpenSkyBespokeSettings(BESPOKE_SETTINGS_);\n    }\n\n    /// @dev Only emergency admin can call functions marked by this modifier.\n    modifier onlyEmergencyAdmin() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isEmergencyAdmin(_msgSender()), 'BM_ACL_ONLY_EMERGENCY_ADMIN_CAN_CALL');\n        _;\n    }\n\n    modifier onlyAirdropOperator() {\n        IACLManager ACLManager = IACLManager(SETTINGS.ACLManagerAddress());\n        require(ACLManager.isAirdropOperator(_msgSender()), 'BM_ACL_ONLY_AIRDROP_OPERATOR_CAN_CALL');\n        _;\n    }\n\n    modifier checkLoanExists(uint256 loanId) {\n        require(_loans[loanId].amount > 0 && _loans[loanId].tokenAddress != address(0), 'BM_CHECK_LOAN_NOT_EXISTS');\n        _;\n    }\n\n    /// @dev Pause pool for emergency case, can only be called by emergency admin.\n    function pause() external onlyEmergencyAdmin {\n        _pause();\n    }\n\n    /// @dev Unpause pool for emergency case, can only be called by emergency admin.\n    function unpause() external onlyEmergencyAdmin {\n        _unpause();\n    }\n\n    /// @notice Cancel all pending offers for a sender\n    /// @param minNonce_ minimum user nonce\n    function cancelAllBorrowOffersForSender(uint256 minNonce_) external {\n        require(minNonce_ > minNonce[msg.sender], 'BM_CANCEL_NONCE_LOWER_THAN_CURRENT');\n        require(minNonce_ < minNonce[msg.sender] + 500000, 'BM_CANCEL_CANNOT_CANCEL_MORE');\n        minNonce[msg.sender] = minNonce_;\n\n        emit CancelAllOffers(msg.sender, minNonce_);\n    }\n\n    /// @param offerNonces array of borrowOffer nonces\n    function cancelMultipleBorrowOffers(uint256[] calldata offerNonces) external {\n        require(offerNonces.length > 0, 'BM_CANCEL_CANNOT_BE_EMPTY');\n\n        for (uint256 i = 0; i < offerNonces.length; i++) {\n            require(offerNonces[i] >= minNonce[msg.sender], 'BM_CANCEL_NONCE_LOWER_THAN_CURRENT');\n            _nonce[msg.sender][offerNonces[i]].invalid = true;\n        }\n\n        emit CancelMultipleOffers(msg.sender, offerNonces);\n    }\n\n    function isValidNonce(address account, uint256 nonce) external view returns (bool) {\n        return !_nonce[account][nonce].invalid && nonce >= minNonce[account];\n    }\n\n    /// @notice take an borrowing offer using ERC20 include ERC20\n    function takeBorrowOffer(\n        BespokeTypes.Offer memory offerData,\n        uint256 supplyAmount,\n        uint256 supplyDuration,\n        address lendAsset,\n        bool autoConvertWhenRepay //Only make sence when lend asset is different with borrow asset. eg. oToken,aToken etc.\n    ) public override whenNotPaused nonReentrant returns (uint256) {\n        return\n            TakeBorrowOfferLogic.executeTakeBorrowOffer(\n                _nonce,\n                minNonce,\n                _loans,\n                _loanIdTracker,\n                offerData,\n                BespokeTypes.TakeBorrowInfo({\n                    borrowAmount: supplyAmount,\n                    borrowDuration: supplyDuration,\n                    lendAsset: lendAsset,\n                    autoConvertWhenRepay: autoConvertWhenRepay\n                }),\n                BESPOKE_SETTINGS\n            );\n    }\n\n    function takeLendOffer(\n        BespokeTypes.Offer memory offerData,\n        uint256 tokenId,\n        uint256 borrowAmount,\n        uint256 borrowDuration,\n        address onBehalfOf,\n        bytes memory params\n    ) public override whenNotPaused nonReentrant returns (uint256) {\n        return\n            TakeLendOfferLogic.executeTakeLendOffer(\n                _nonce,\n                minNonce,\n                _loans,\n                _loanIdTracker,\n                offerData,\n                BespokeTypes.TakeLendInfo({\n                    borrowAmount: borrowAmount,\n                    borrowDuration: borrowDuration,\n                    tokenId: tokenId,\n                    onBehalfOf: onBehalfOf,\n                    params: params\n                }),\n                BESPOKE_SETTINGS\n            );\n    }\n\n    /// @notice Anyone can repay but only OpenSkyBorrowNFT owner receive collaterial\n    /// @notice Only OpenSkyLendNFT owner can recieve the payment\n    /// @notice This function is not pausable for safety\n    function repay(uint256 loanId) public override nonReentrant checkLoanExists(loanId) {\n        RepayLogic.repay(_loans, loanId, BESPOKE_SETTINGS, SETTINGS);\n    }\n\n    /// @notice anyone can trigger but only OpenSkyLendNFT owner can receive collaterial\n    function foreclose(uint256 loanId) public override whenNotPaused nonReentrant checkLoanExists(loanId) {\n        ForecloseLogic.foreclose(_loans, loanId, BESPOKE_SETTINGS);\n    }\n\n    function getLoanData(uint256 loanId) public view override returns (BespokeTypes.LoanData memory) {\n        return BespokeLogic.getLoanDataWithStatus(_loans[loanId]);\n    }\n\n    function getStatus(uint256 loanId) public view override returns (BespokeTypes.LoanStatus) {\n        return BespokeLogic.getLoanStatus(_loans[loanId]);\n    }\n\n    function getBorrowInterest(uint256 loanId) public view override returns (uint256) {\n        return BespokeLogic.getBorrowInterest(_loans[loanId]);\n    }\n\n    // @dev principal + interest\n    function getBorrowBalance(uint256 loanId) public view override returns (uint256) {\n        return BespokeLogic.getBorrowBalance(_loans[loanId]);\n    }\n\n    function getPenalty(uint256 loanId) public view override returns (uint256) {\n        return BespokeLogic.getPenalty(_loans[loanId]);\n    }\n\n    /// @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n    /// direct transfers to the contract address.\n    /// @param token token to transfer\n    /// @param to recipient of the transfer\n    /// @param amount amount to send\n    function emergencyTokenTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyEmergencyAdmin {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    receive() external payable {\n        revert('BM_RECEIVE_NOT_ALLOWED');\n    }\n\n    fallback() external payable {\n        revert('BM_FALLBACK_NOT_ALLOWED');\n    }\n}\n"
    },
    "contracts/bespokemarket/libraries/TakeLendOfferLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../interfaces/IOpenSkyBespokeSettings.sol';\nimport '../interfaces/IOpenSkyBespokeLendOfferStrategy.sol';\nimport '../interfaces/ITransferAdapterCurrency.sol';\nimport '../interfaces/ITransferAdapterNFT.sol';\n\nimport './BespokeLogic.sol';\nimport './BespokeTypes.sol';\n\nlibrary TakeLendOfferLogic {\n    using SafeERC20 for IERC20;\n\n    event TakeLendOffer(\n        bytes32 offerHash,\n        uint256 indexed loanId,\n        address indexed lender,\n        address indexed borrower,\n        address onBehalfOf,\n        uint256 nonce,\n        uint256 nonceOrder\n    );\n\n    struct TakeLendOfferLocalVars {\n        bytes32 offerHash;\n        bytes32 domainSeparator;\n        address nftManager;\n        address currencyTransferAdapter;\n        uint256 loanId;\n    }\n\n    function executeTakeLendOffer(\n        mapping(address => mapping(uint256 => BespokeTypes.NonceInfo)) storage _nonce,\n        mapping(address => uint256) storage minNonce,\n        mapping(uint256 => BespokeTypes.LoanData) storage _loans,\n        BespokeTypes.Counter storage _loanIdTracker,\n        BespokeTypes.Offer memory offerData,\n        BespokeTypes.TakeLendInfo memory params,\n        IOpenSkyBespokeSettings BESPOKE_SETTINGS\n    ) public returns (uint256) {\n        TakeLendOfferLocalVars memory vars;\n\n        vars.offerHash = BespokeLogic.hashOffer(offerData);\n        vars.domainSeparator = BespokeLogic.getDomainSeparator();\n\n        require(offerData.offerType == BespokeTypes.OfferType.LEND, 'BM_TAKE_OFFER_INVALID_OFFER_TYPE');\n\n        // comment validation\n        BespokeLogic.validateOfferCommon(\n            _nonce,\n            minNonce,\n            offerData,\n            vars.offerHash,\n            params.borrowAmount,\n            params.borrowDuration,\n            vars.domainSeparator,\n            BESPOKE_SETTINGS\n        );\n\n        //validate strategy\n        require(offerData.strategy != address(0), 'BM_TAKE_LEND_STRATEGY_EMPTY');\n\n        require(BESPOKE_SETTINGS.isStrategyWhitelisted(offerData.strategy), 'BM_TAKE_LEND_STRATEGY_NOT_IN_WHITE_LIST');\n\n        IOpenSkyBespokeLendOfferStrategy(offerData.strategy).validate(\n            offerData,\n            BespokeTypes.TakeLendInfoForStrategy({taker: msg.sender, tokenId: params.tokenId, params: params.params})\n        );\n\n        // update nonce\n        _nonce[offerData.signer][offerData.nonce].usedTimes++;\n        if (_nonce[offerData.signer][offerData.nonce].offerHash == 0) {\n            _nonce[offerData.signer][offerData.nonce].offerHash = vars.offerHash;\n        }\n        if (_nonce[offerData.signer][offerData.nonce].usedTimes >= offerData.nonceMaxTimes) {\n            _nonce[offerData.signer][offerData.nonce].invalid = true;\n        }\n        vars.nftManager = BESPOKE_SETTINGS.getNftTransferAdapter(offerData.tokenAddress);\n\n        require(vars.nftManager != address(0), 'BM_TRANSFER_NFT_ADAPTER_NOT_AVAILABLE');\n        ITransferAdapterNFT(vars.nftManager).transferCollateralIn(\n            offerData.tokenAddress,\n            msg.sender,\n            params.tokenId,\n            offerData.tokenAmount\n        );\n\n        vars.currencyTransferAdapter = BESPOKE_SETTINGS.getCurrencyTransferAdapter(offerData.lendAsset);\n        IERC20(offerData.lendAsset).safeTransferFrom(offerData.signer, address(this), params.borrowAmount);\n        IERC20(offerData.lendAsset).approve(vars.currencyTransferAdapter, params.borrowAmount);\n\n        ITransferAdapterCurrency(vars.currencyTransferAdapter).transferOnLend(\n            offerData.lendAsset,\n            address(this),\n            params.onBehalfOf,\n            params.borrowAmount,\n            offerData\n        );\n\n        // mint loanNft\n        vars.loanId = BespokeLogic.mintLoanNFT(_loanIdTracker, params.onBehalfOf, offerData.signer, BESPOKE_SETTINGS);\n        // create loan\n        BespokeLogic.createLoan(\n            _loans,\n            offerData,\n            vars.loanId,\n            params.borrowAmount,\n            params.borrowDuration,\n            vars.nftManager,\n            params.tokenId,\n            BESPOKE_SETTINGS\n        );\n\n        emit TakeLendOffer(\n            vars.offerHash,\n            vars.loanId,\n            offerData.signer,\n            msg.sender,\n            params.onBehalfOf,\n            offerData.nonce,\n            _nonce[offerData.signer][offerData.nonce].usedTimes\n        );\n        return vars.loanId;\n    }\n}\n"
    },
    "contracts/bespokemarket/libraries/TakeBorrowOfferLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../interfaces/IOpenSkyBespokeSettings.sol';\nimport '../interfaces/ITransferAdapterCurrency.sol';\nimport '../interfaces/ITransferAdapterNFT.sol';\n\nimport './BespokeTypes.sol';\nimport './BespokeLogic.sol';\n\nlibrary TakeBorrowOfferLogic {\n    using SafeERC20 for IERC20;\n\n    event TakeBorrowOffer(\n        bytes32 offerHash,\n        uint256 indexed loanId,\n        address indexed lender,\n        address indexed borrower,\n        uint256 nonce\n    );\n\n    struct TakeBorrowOfferLocalVars {\n        bytes32 offerHash;\n        bytes32 domainSeparator;\n        address nftManager;\n        address currencyTransferAdapter;\n        uint256 loanId;\n    }\n\n    function executeTakeBorrowOffer(\n        mapping(address => mapping(uint256 => BespokeTypes.NonceInfo)) storage _nonce,\n        mapping(address => uint256) storage minNonce,\n        mapping(uint256 => BespokeTypes.LoanData) storage _loans,\n        BespokeTypes.Counter storage _loanIdTracker,\n        BespokeTypes.Offer memory offerData,\n        BespokeTypes.TakeBorrowInfo memory params,\n        IOpenSkyBespokeSettings BESPOKE_SETTINGS\n    ) public returns (uint256) {\n        TakeBorrowOfferLocalVars memory vars;\n        vars.offerHash = BespokeLogic.hashOffer(offerData);\n        vars.domainSeparator = BespokeLogic.getDomainSeparator();\n\n        require(offerData.offerType == BespokeTypes.OfferType.BORROW, 'BM_TAKE_BORROW_OFFER_INVALID_OFFER_TYPE');\n\n        // For a borrower who created a borrow offer:\n        // 1.No need to care what lender use to lend or what lender will get when loan repaid.\n        // 2.So field 'autoConvertWhenRepay' and 'lendAsset' of offer data should be kept default value, and will be determined by lender/taker.\n        require(\n            offerData.autoConvertWhenRepay == false,\n            'BM_TAKE_BORROW_OFFER_INVALID_FIELD_VALUE_AUTO_CONVERT_WHENR_EPAY'\n        );\n        require(offerData.lendAsset == address(0), 'BM_TAKE_BORROW_OFFER_INVALID_FIELD_VALUE_LEND_ASSET');\n\n        // Borrower offer can only be used once by design\n        require(offerData.nonceMaxTimes == 1, 'BM_TAKE_BORROW_OFFER_INVALID_FIELD_VALUE_NONCE_MAX_TIMES');\n        \n        require(offerData.strategy == address(0), 'BM_BORROW_OFFER_STRATEGY_SHOULD_BE_ZERO');\n\n\n        // Comment validation\n        BespokeLogic.validateOfferCommon(\n            _nonce,\n            minNonce,\n            offerData,\n            vars.offerHash,\n            params.borrowAmount,\n            params.borrowDuration,\n            vars.domainSeparator,\n            BESPOKE_SETTINGS\n        );\n\n        // Overwrite default value from lender/taker after common validation\n        offerData.autoConvertWhenRepay = params.autoConvertWhenRepay;\n        offerData.lendAsset = params.lendAsset;\n\n        // prevents replay\n        _nonce[offerData.signer][offerData.nonce].invalid = true;\n\n        vars.nftManager = BESPOKE_SETTINGS.getNftTransferAdapter(offerData.tokenAddress);\n        require(vars.nftManager != address(0), 'BM_TRANSFER_NFT_ADAPTER_NOT_AVAILABLE');\n        ITransferAdapterNFT(vars.nftManager).transferCollateralIn(\n            offerData.tokenAddress,\n            offerData.signer,\n            offerData.tokenId,\n            offerData.tokenAmount\n        );\n\n        vars.currencyTransferAdapter = BESPOKE_SETTINGS.getCurrencyTransferAdapter(offerData.lendAsset);\n        IERC20(offerData.lendAsset).safeTransferFrom(msg.sender, address(this), params.borrowAmount);\n        IERC20(offerData.lendAsset).approve(vars.currencyTransferAdapter, params.borrowAmount);\n        ITransferAdapterCurrency(vars.currencyTransferAdapter).transferOnLend(\n            offerData.lendAsset,\n            address(this),\n            offerData.signer,\n            params.borrowAmount,\n            offerData\n        );\n\n        vars.loanId = BespokeLogic.mintLoanNFT(_loanIdTracker, offerData.signer, msg.sender, BESPOKE_SETTINGS);\n\n        BespokeLogic.createLoan(\n            _loans,\n            offerData,\n            vars.loanId,\n            params.borrowAmount,\n            params.borrowDuration,\n            vars.nftManager,\n            offerData.tokenId,\n            BESPOKE_SETTINGS\n        );\n\n        emit TakeBorrowOffer(vars.offerHash, vars.loanId, msg.sender, offerData.signer, offerData.nonce);\n        return vars.loanId;\n    }\n}\n"
    },
    "contracts/bespokemarket/libraries/RepayLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../../interfaces/IOpenSkySettings.sol';\n\nimport '../interfaces/IOpenSkyBespokeSettings.sol';\nimport '../interfaces/ITransferAdapterCurrency.sol';\nimport '../interfaces/ITransferAdapterNFT.sol';\n\nimport './BespokeTypes.sol';\nimport './BespokeLogic.sol';\n\nlibrary RepayLogic {\n    using SafeERC20 for IERC20;\n\n    event Repay(uint256 indexed loanId, address indexed operator, address indexed receiver);\n\n    function repay(\n        mapping(uint256 => BespokeTypes.LoanData) storage _loans,\n        uint256 loanId,\n        IOpenSkyBespokeSettings BESPOKE_SETTINGS,\n        IOpenSkySettings SETTINGS\n    ) public {\n        BespokeTypes.LoanData memory loanData = BespokeLogic.getLoanDataWithStatus(_loans[loanId]);\n        require(\n            loanData.status == BespokeTypes.LoanStatus.BORROWING || loanData.status == BespokeTypes.LoanStatus.OVERDUE,\n            'BM_REPAY_STATUS_ERROR'\n        );\n\n        (address borrower, address lender) = BespokeLogic.getLoanParties(BESPOKE_SETTINGS, loanId);\n\n        (uint256 repayTotal, uint256 lenderAmount, uint256 protocolFee) = BespokeLogic\n            .calculateRepayAmountAndProtocolFee(loanData);\n        address currencyTransferAdapter = BESPOKE_SETTINGS.getCurrencyTransferAdapter(loanData.lendAsset);\n\n        IERC20(loanData.currency).safeTransferFrom(msg.sender, address(this), lenderAmount);\n        IERC20(loanData.currency).approve(currencyTransferAdapter, lenderAmount);\n        ITransferAdapterCurrency(currencyTransferAdapter).transferOnRepay(\n            loanData.lendAsset,\n            address(this),\n            lender,\n            lenderAmount,\n            loanData\n        );\n\n        // protocol income\n        if (protocolFee > 0) {\n            IERC20(loanData.currency).safeTransferFrom(msg.sender, SETTINGS.daoVaultAddress(), protocolFee);\n        }\n\n        ITransferAdapterNFT(loanData.nftManager).transferCollateralOut(\n            loanData.tokenAddress,\n            borrower,\n            loanData.tokenId,\n            loanData.tokenAmount\n        );\n\n        BespokeLogic.burnLoanNft(_loans, loanId, BESPOKE_SETTINGS);\n\n        emit Repay(loanId, msg.sender, borrower);\n    }\n}\n"
    },
    "contracts/bespokemarket/libraries/ForecloseLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../interfaces/IOpenSkyBespokeSettings.sol';\nimport '../interfaces/ITransferAdapterNFT.sol';\n\nimport './BespokeTypes.sol';\nimport './BespokeLogic.sol';\n\nlibrary ForecloseLogic {\n    event Foreclose(uint256 indexed loanId, address indexed operator, address indexed receiver);\n\n    function foreclose(\n        mapping(uint256 => BespokeTypes.LoanData) storage _loans,\n        uint256 loanId,\n        IOpenSkyBespokeSettings BESPOKE_SETTINGS\n    ) public {\n        BespokeTypes.LoanData memory loanData = BespokeLogic.getLoanDataWithStatus(_loans[loanId]);\n        require(loanData.status == BespokeTypes.LoanStatus.LIQUIDATABLE, 'BM_FORECLOSE_STATUS_ERROR');\n\n        (, address lender) = BespokeLogic.getLoanParties(BESPOKE_SETTINGS, loanId);\n        \n        ITransferAdapterNFT(loanData.nftManager).transferCollateralOutOnForeclose(\n            loanData.tokenAddress,\n            lender,\n            loanData.tokenId,\n            loanData.tokenAmount\n        );\n\n        BespokeLogic.burnLoanNft(_loans, loanId, BESPOKE_SETTINGS);\n\n        emit Foreclose(loanId, msg.sender, lender);\n    }\n}\n"
    },
    "contracts/bespokemarket/interfaces/IOpenSkyBespokeLendOfferStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../libraries/BespokeTypes.sol';\n\ninterface IOpenSkyBespokeLendOfferStrategy {\n    function validate(BespokeTypes.Offer memory offerData, BespokeTypes.TakeLendInfoForStrategy memory takeInfo)\n        external\n        view;\n}\n"
    },
    "contracts/bespokemarket/interfaces/ITransferAdapterCurrency.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../libraries/BespokeTypes.sol';\n\ninterface ITransferAdapterCurrency {\n    function transferOnLend(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        BespokeTypes.Offer memory offerData\n    ) external;\n\n    function transferOnRepay(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        BespokeTypes.LoanData memory loanData\n    ) external;\n}\n"
    },
    "contracts/bespokemarket/transferAdaptersCurrency/TransferAdapterOToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../../interfaces/IOpenSkySettings.sol';\nimport '../../interfaces/IOpenSkyPool.sol';\n\nimport '../interfaces/IOpenSkyBespokeSettings.sol';\nimport '../interfaces/ITransferAdapterCurrency.sol';\n\ncontract TransferAdapterOToken is Context, Ownable, ITransferAdapterCurrency {\n    using SafeERC20 for IERC20;\n\n    // oToken address => reserveId\n    mapping(address => uint256) public getReserveId;\n\n    IOpenSkySettings public immutable SETTINGS;\n    IOpenSkyBespokeSettings public immutable BESPOKE_SETTINGS;\n\n    event SetOTokenToReserveIdMap(address oToken, uint256 reserveId);\n    event UnsetOTokenToReserveIdMap(address oToken);\n\n    constructor(address settingsAddress_, address bespokeSettings_) {\n        SETTINGS = IOpenSkySettings(settingsAddress_);\n        BESPOKE_SETTINGS = IOpenSkyBespokeSettings(bespokeSettings_);\n    }\n\n    modifier onlyMarket() {\n        require(_msgSender() == BESPOKE_SETTINGS.marketAddress(), 'BM_ACL_ONLY_BESPOKR_MARKET_CAN_CALL');\n        _;\n    }\n\n    function transferOnLend(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        BespokeTypes.Offer memory offerData\n    ) external onlyMarket {\n        require(offerData.lendAsset == asset, 'BM_TRANSFER_ADAPTER_OTOKEN_ASSET_NOT_MATCH');\n\n        uint256 reserveId = getReserveId[asset];\n        require(reserveId > 0, 'BM_TRANSFER_ADAPTER_OTOKEN_RESERVEID_NOT_CONFIGURED');\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId);\n\n        // validate oToken=>reserveId\n        require(asset == reserve.oTokenAddress, 'BM_TRANSFER_ADAPTER_OTOKEN_OTOKEN_ASSET_NOT_MATCH');\n        // lend underlyingAsset/currency using oToken\n        require(offerData.currency == reserve.underlyingAsset, 'BM_TRANSFER_ADAPTER_OTOKEN_UNDERLYING_NOT_MATCH');\n\n        uint256 oTokenBalance = IERC20(asset).balanceOf(from);\n        uint256 availableLiquidity = IOpenSkyPool(SETTINGS.poolAddress()).getAvailableLiquidity(reserveId);\n        require(oTokenBalance >= amount, 'BM_TRANSFER_ADAPTER_OTOKEN_NOT_ENOUGH');\n        require(availableLiquidity >= amount, 'BM_TRANSFER_ADAPTER_OTOKEN_POOL_LIQUIDITY_NOT_ENOUGH');\n\n        IERC20(reserve.oTokenAddress).safeTransferFrom(from, address(this), amount);\n        // withdraw underlying to borrower\n        IOpenSkyPool(SETTINGS.poolAddress()).withdraw(reserveId, amount, to);\n    }\n\n    //@dev only accept underlying to repay\n    function transferOnRepay(\n        address asset, // should be oToken\n        address from,\n        address to,\n        uint256 amount,\n        BespokeTypes.LoanData memory loanData\n    ) external onlyMarket {\n        require(loanData.lendAsset == asset, 'BM_TRANSFER_ADAPTER_OTOKEN_ASSET_NOT_MATCH');\n\n        uint256 reserveId = getReserveId[asset];\n        require(reserveId > 0, 'BM_TRANSFER_ADAPTER_OTOKEN_RESERVEID_NOT_CONFIGURED');\n\n        // oToken balance\n        DataTypes.ReserveData memory reserve = IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId);\n\n        // validate oToken=>reserveId\n        require(asset == reserve.oTokenAddress, 'BM_TRANSFER_ADAPTER_OTOKEN_ASSET_NOT_MATCH');\n        // lend underlyingAsset/currency using oToken\n        require(loanData.currency == reserve.underlyingAsset, 'BM_TRANSFER_ADAPTER_OTOKEN_UNDERLYING_NOT_MATCH');\n\n        // convert to lend asset\n        if (loanData.autoConvertWhenRepay) {\n            IERC20(reserve.underlyingAsset).safeTransferFrom(from, address(this), amount);\n            IERC20(reserve.underlyingAsset).approve(SETTINGS.poolAddress(), amount);\n            IOpenSkyPool(SETTINGS.poolAddress()).deposit(reserveId, amount, to, 0);\n        } else {\n            IERC20(reserve.underlyingAsset).safeTransferFrom(from, to, amount);\n        }\n    }\n\n    // reserveId should be configured for every oToken added to currency whitelist\n    function setOTokenToReserveIdMap(address oToken, uint256 reserveId) external onlyOwner {\n        require(\n            IOpenSkyPool(SETTINGS.poolAddress()).getReserveData(reserveId).oTokenAddress == oToken,\n            'BM_TRANSFER_ADAPTER_OTOKEN_SET_RESERVE_NOT_MATCH'\n        );\n        getReserveId[oToken] = reserveId;\n        emit SetOTokenToReserveIdMap(oToken, reserveId);\n    }\n\n    function unsetOTokenToReserveIdMap(address oToken) external onlyOwner {\n        getReserveId[oToken] = 0;\n        emit UnsetOTokenToReserveIdMap(oToken);\n    }\n}\n"
    },
    "contracts/bespokemarket/transferAdaptersCurrency/TransferAdapterCurrencyDefault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../interfaces/IOpenSkyBespokeSettings.sol';\nimport '../interfaces/ITransferAdapterCurrency.sol';\n\ncontract TransferAdapterCurrencyDefault is Context, ITransferAdapterCurrency {\n    using SafeERC20 for IERC20;\n\n    IOpenSkyBespokeSettings public immutable BESPOKE_SETTINGS;\n\n    constructor(address bespokeSettings_) {\n        BESPOKE_SETTINGS = IOpenSkyBespokeSettings(bespokeSettings_);\n    }\n\n    modifier onlyMarket() {\n        require(_msgSender() == BESPOKE_SETTINGS.marketAddress(), 'BM_ACL_ONLY_BESPOKR_MARKET_CAN_CALL');\n        _;\n    }\n\n    function transferOnLend(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        BespokeTypes.Offer memory offerData\n    ) external onlyMarket {\n        // asset match rule\n        require(offerData.lendAsset == asset, 'BM_TRANSFER_ON_LEND_ASSET_NOT_MATCH');\n        require(offerData.currency == offerData.lendAsset, 'BM_TRANSFER_ON_LEND_PAIR_NOT_SUPPORTED');\n\n        IERC20(asset).safeTransferFrom(from, to, amount);\n    }\n\n    function transferOnRepay(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        BespokeTypes.LoanData memory loanData\n    ) external onlyMarket {\n        // asset match rule\n        require(loanData.lendAsset == asset, 'BM_TRANSFER_ADAPTER_ASSET_NOT_MATCH');\n        require(loanData.currency == loanData.lendAsset, 'BM_TRANSFER_ADAPTER_PAIR_NOT_SUPPORTED');\n\n        IERC20(asset).safeTransferFrom(from, to, amount);\n    }\n}\n"
    },
    "contracts/bespokemarket/OpenSkyBespokeSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/introspection/IERC165.sol';\n\nimport '../interfaces/IACLManager.sol';\nimport './interfaces/IOpenSkyBespokeSettings.sol';\nimport './libraries/BespokeTypes.sol';\n\ncontract OpenSkyBespokeSettings is Ownable, IOpenSkyBespokeSettings {\n    uint256 public constant MAX_RESERVE_FACTOR = 3000;\n\n    address public immutable ACLManagerAddress;\n\n    // nft whitelist\n    bool public override isWhitelistOn = false;\n    // nftAddress=>data\n    mapping(address => BespokeTypes.WhitelistInfo) internal _whitelist;\n\n    // currency whitelist\n    mapping(address => bool) public _currencyWhitelist;\n\n    // currency transfer adapter\n    mapping(address => address) public _currencyTransferAdapters;\n\n    // one-time initialization\n    address public override marketAddress;\n    address public override borrowLoanAddress;\n    address public override lendLoanAddress;\n\n    // governance factors\n    uint256 public override reserveFactor = 500;\n    uint256 public override overdueLoanFeeFactor = 100;\n\n    uint256 public override minBorrowDuration = 30 minutes;\n    uint256 public override maxBorrowDuration = 60 days;\n    uint256 public override overdueDuration = 2 days;\n\n    // nft transfer adapter config\n    // ERC721 interfaceID\n    bytes4 public constant INTERFACE_ID_ERC721 = 0x80ac58cd;\n    // ERC1155 interfaceID\n    bytes4 public constant INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    // Address of the transfer manager contract for ERC721 tokens\n    address public TRANSFER_ERC721;\n\n    // Address of the transfer manager contract for ERC1155 tokens\n    address public TRANSFER_ERC1155;\n\n    // Address of the transfer manager contract for ERC20 tokens\n    address public TRANSFER_CURRENCY;\n\n    mapping(address => address) public _transferAdapters;\n\n    // strategy white list\n    mapping(address => bool) public _strategyWhitelist;\n\n    modifier onlyGovernance() {\n        IACLManager ACLManager = IACLManager(ACLManagerAddress);\n        require(ACLManager.isGovernance(_msgSender()), 'BM_ACL_ONLY_GOVERNANCE_CAN_CALL');\n        _;\n    }\n    modifier onlyWhenNotInitialized(address address_) {\n        require(address_ == address(0));\n        _;\n    }\n\n    constructor(address _ACLManagerAddress) Ownable() {\n        ACLManagerAddress = _ACLManagerAddress;\n    }\n\n    // OpenSkyBespokeMarket address\n    function initMarketAddress(address address_) external onlyOwner onlyWhenNotInitialized(marketAddress) {\n        require(address_ != address(0));\n        marketAddress = address_;\n        emit InitMarketAddress(msg.sender, address_);\n    }\n\n    function initLoanAddress(address borrowLoanAddress_, address lendLoanAddress_)\n        external\n        onlyOwner\n        onlyWhenNotInitialized(borrowLoanAddress)\n        onlyWhenNotInitialized(lendLoanAddress)\n    {\n        require(borrowLoanAddress_ != address(0) && lendLoanAddress_ != address(0));\n        borrowLoanAddress = borrowLoanAddress_;\n        lendLoanAddress = lendLoanAddress_;\n        emit InitLoanAddress(msg.sender, borrowLoanAddress_, lendLoanAddress_);\n    }\n\n    function setMinBorrowDuration(uint256 factor) external onlyGovernance {\n        require(minBorrowDuration > 0);\n        minBorrowDuration = factor;\n        emit SetMinBorrowDuration(msg.sender, factor);\n    }\n\n    function setMaxBorrowDuration(uint256 factor) external onlyGovernance {\n        require(maxBorrowDuration > 0);\n        maxBorrowDuration = factor;\n        emit SetMaxBorrowDuration(msg.sender, factor);\n    }\n\n    function setOverdueDuration(uint256 factor) external onlyGovernance {\n        overdueDuration = factor;\n        emit SetOverdueDuration(msg.sender, factor);\n    }\n\n    function setReserveFactor(uint256 factor) external onlyGovernance {\n        require(factor <= MAX_RESERVE_FACTOR);\n        reserveFactor = factor;\n        emit SetReserveFactor(msg.sender, factor);\n    }\n\n    function setOverdueLoanFeeFactor(uint256 factor) external onlyGovernance {\n        overdueLoanFeeFactor = factor;\n        emit SetOverdueLoanFeeFactor(msg.sender, factor);\n    }\n\n    function openWhitelist() external onlyGovernance {\n        isWhitelistOn = true;\n        emit OpenWhitelist(msg.sender);\n    }\n\n    function closeWhitelist() external onlyGovernance {\n        isWhitelistOn = false;\n        emit CloseWhitelist(msg.sender);\n    }\n\n    function addToWhitelist(\n        address nft,\n        uint256 minBorrowDuration,\n        uint256 maxBorrowDuration,\n        uint256 overdueDuration\n    ) external onlyGovernance {\n        require(nft != address(0));\n        require(minBorrowDuration <= maxBorrowDuration);\n        _whitelist[nft] = BespokeTypes.WhitelistInfo({\n            enabled: true,\n            minBorrowDuration: minBorrowDuration,\n            maxBorrowDuration: maxBorrowDuration,\n            overdueDuration: overdueDuration\n        });\n        emit AddToWhitelist(msg.sender, nft);\n    }\n\n    function removeFromWhitelist(address nft) external onlyGovernance {\n        if (_whitelist[nft].enabled) {\n            _whitelist[nft].enabled = false;\n            emit RemoveFromWhitelist(msg.sender, nft);\n        }\n    }\n\n    function inWhitelist(address nft) public view override returns (bool) {\n        require(nft != address(0));\n        return !isWhitelistOn || _whitelist[nft].enabled;\n    }\n\n    function getWhitelistDetail(address nft) public view override returns (BespokeTypes.WhitelistInfo memory) {\n        return _whitelist[nft];\n    }\n\n    function getBorrowDurationConfig(address nftAddress)\n        public\n        view\n        override\n        returns (\n            uint256 minBorrowDuration_,\n            uint256 maxBorrowDuration_,\n            uint256 overdueDuration_\n        )\n    {\n        if (isWhitelistOn && inWhitelist(nftAddress)) {\n            BespokeTypes.WhitelistInfo memory info = getWhitelistDetail(nftAddress);\n            minBorrowDuration_ = info.minBorrowDuration;\n            maxBorrowDuration_ = info.maxBorrowDuration;\n            overdueDuration_ = info.overdueDuration;\n        } else {\n            minBorrowDuration_ = minBorrowDuration;\n            maxBorrowDuration_ = maxBorrowDuration;\n            overdueDuration_ = overdueDuration;\n        }\n    }\n\n    // currency whitelist\n    function addCurrency(address currency) external onlyGovernance {\n        require(currency != address(0));\n        if (_currencyWhitelist[currency] != true) {\n            _currencyWhitelist[currency] = true;\n        }\n        emit AddCurrency(msg.sender, currency);\n    }\n\n    function removeCurrency(address currency) external onlyGovernance {\n        require(currency != address(0));\n        delete _currencyWhitelist[currency];\n        emit RemoveCurrency(msg.sender, currency);\n    }\n\n    function isCurrencyWhitelisted(address currency) external view override returns (bool) {\n        return _currencyWhitelist[currency];\n    }\n\n    function initDefaultCurrencyTransferAdapter(address currencyDefaultAdapter)\n        external\n        onlyWhenNotInitialized(TRANSFER_CURRENCY)\n        onlyOwner\n    {\n        require(currencyDefaultAdapter != address(0));\n        TRANSFER_CURRENCY = currencyDefaultAdapter;\n        emit InitDefaultCurrencyTransferAdapter(currencyDefaultAdapter);\n    }\n\n    function addCurrencyTransferAdapter(address currency, address adapterAddress) external onlyGovernance {\n        require(currency != address(0) && adapterAddress != address(0));\n        _currencyTransferAdapters[currency] = adapterAddress;\n        emit AddCurrencyTransferAdapter(msg.sender, currency, adapterAddress);\n    }\n\n    function removeCurrencyTransferAdapter(address currency) external onlyGovernance {\n        delete _currencyTransferAdapters[currency];\n        emit RemoveCurrencyTransferAdapter(msg.sender, currency);\n    }\n\n    function getCurrencyTransferAdapter(address currency) external view returns (address adapter) {\n        adapter = _currencyTransferAdapters[currency];\n        if (adapter == address(0)) {\n            adapter = TRANSFER_CURRENCY;\n        }\n        return adapter;\n    }\n\n    //Nft Transfer Adapters\n    function initDefaultNftTransferAdapters(address ERC721Default, address ERC1155Default)\n        external\n        onlyWhenNotInitialized(TRANSFER_ERC721)\n        onlyWhenNotInitialized(TRANSFER_ERC1155)\n        onlyOwner\n    {\n        require(ERC721Default != address(0) && ERC1155Default != address(0));\n\n        TRANSFER_ERC721 = ERC721Default;\n        TRANSFER_ERC1155 = ERC1155Default;\n\n        emit InitDefaultNftTransferAdapter(ERC721Default, ERC1155Default);\n    }\n\n    // nft transfer adapter\n    function addNftTransferAdapter(address nftAddress, address adapterAddress) external onlyGovernance {\n        require(nftAddress != address(0) && adapterAddress != address(0));\n        _transferAdapters[nftAddress] = adapterAddress;\n        emit AddNftTransferAdapter(msg.sender, nftAddress, adapterAddress);\n    }\n\n    function removeNftTransferAdapter(address nftAddress) external onlyGovernance {\n        delete _transferAdapters[nftAddress];\n        emit RemoveNftTransferAdapter(msg.sender, nftAddress);\n    }\n\n    function getNftTransferAdapter(address nftAddress) external view returns (address adapter) {\n        adapter = _transferAdapters[nftAddress];\n        if (adapter == address(0)) {\n            if (IERC165(nftAddress).supportsInterface(INTERFACE_ID_ERC721)) {\n                adapter = TRANSFER_ERC721;\n            } else if (IERC165(nftAddress).supportsInterface(INTERFACE_ID_ERC1155)) {\n                adapter = TRANSFER_ERC1155;\n            }\n        }\n        return adapter;\n    }\n\n    // lend offer strategy\n    function addStrategy(address address_) external onlyGovernance {\n        require(address_ != address(0));\n        if (_strategyWhitelist[address_] != true) {\n            _strategyWhitelist[address_] = true;\n        }\n        emit AddStrategy(msg.sender, address_);\n    }\n\n    function removeStrategy(address address_) external onlyGovernance {\n        require(address_ != address(0));\n        delete _strategyWhitelist[address_];\n        emit RemoveStrategy(msg.sender, address_);\n    }\n\n    function isStrategyWhitelisted(address address_) external view override returns (bool) {\n        return _strategyWhitelist[address_];\n    }\n}\n"
    },
    "contracts/bespokemarket/OpenSkyBespokeLoanNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\n\nimport './libraries/BespokeTypes.sol';\n\nimport '../interfaces/IOpenSkyNFTDescriptor.sol';\nimport './interfaces/IOpenSkyBespokeSettings.sol';\nimport './interfaces/IOpenSkyBespokeLoanNFT.sol';\nimport './interfaces/IOpenSkyBespokeMarket.sol';\n\n/**\n * @title OpenSkyBespokeLoanNFT contract\n * @author OpenSky Labs\n * @notice When a loan created, both lender and borrower will receive an NFT as receipt which represents the corresponding rights and interest\n **/\ncontract OpenSkyBespokeLoanNFT is Context, Ownable, ERC721, IOpenSkyBespokeLoanNFT {\n    IOpenSkyBespokeSettings public immutable BESPOKE_SETTINGS;\n\n    address public loanDescriptorAddress;\n\n    modifier onlyMarket() {\n        require(_msgSender() == BESPOKE_SETTINGS.marketAddress(), 'BM_ACL_ONLY_BESPOKR_MARKET_CAN_CALL');\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address bespokeSettings_\n    ) Ownable() ERC721(name, symbol) {\n        BESPOKE_SETTINGS = IOpenSkyBespokeSettings(bespokeSettings_);\n    }\n\n    function setLoanDescriptorAddress(address address_) external onlyOwner {\n        require(address_ != address(0));\n        loanDescriptorAddress = address_;\n        emit SetLoanDescriptorAddress(_msgSender(), address_);\n    }\n\n    function mint(uint256 tokenId, address account) external override onlyMarket {\n        _safeMint(account, tokenId);\n        emit Mint(tokenId, account);\n    }\n\n    function burn(uint256 tokenId) external onlyMarket {\n        _burn(tokenId);\n        emit Burn(tokenId);\n    }\n\n    function getLoanData(uint256 tokenId) public returns (BespokeTypes.LoanData memory) {\n        return IOpenSkyBespokeMarket(BESPOKE_SETTINGS.marketAddress()).getLoanData(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (loanDescriptorAddress != address(0)) {\n            return IOpenSkyNFTDescriptor(loanDescriptorAddress).tokenURI(tokenId);\n        } else {\n            return '';\n        }\n    }\n}\n"
    },
    "contracts/liquidation/OpenSkyDutchAuctionPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../interfaces/IOpenSkyDutchAuctionPriceOracle.sol\";\n\ncontract OpenSkyDutchAuctionPriceOracle is IOpenSkyDutchAuctionPriceOracle {\n    uint256 constant DURATION_ONE = 2 days;\n    uint256 constant DURATION_TWO = 3 days;\n    uint256 constant SPACING = 5 minutes; // price descend every 5 minutes\n\n    function calculatePrice(\n        uint256 startPrice,\n        uint256 endPrice,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 priceTime\n    ) public pure returns (uint256) {\n        uint256 spacingAmount = (endTime - startTime) / SPACING;\n        uint256 priceUint = (startPrice - endPrice) / spacingAmount;\n        uint256 currentIndex = (priceTime - startTime) / SPACING;\n        uint256 price = startPrice - currentIndex * priceUint;\n        return price;\n    }\n\n    function getPrice(uint256 reservePrice, uint256 startTime) external view override returns (uint256) {\n        // 10*loan => 3*loan=> 1.2*loan\n        uint256 startPrice = reservePrice * 10;\n        uint256 turningPrice = reservePrice * 3;\n        uint256 endPrice = (reservePrice * 12000) / 10000;\n        uint256 turnTime = startTime + DURATION_ONE;\n        uint256 endTime = turnTime + DURATION_TWO;\n\n        uint256 price = endPrice;\n\n        if (block.timestamp <= startTime) {\n            price = startPrice;\n        } else if (block.timestamp <= turnTime) {\n            // price = startPrice - ((block.timestamp - startTime) * (startPrice - turningPrice)) / DURATION_ONE;\n            price = calculatePrice(startPrice, turningPrice, startTime, turnTime, block.timestamp);\n        } else if (block.timestamp < endTime) {\n            // price = turningPrice - ((block.timestamp - turnTime) * (turningPrice - endPrice)) / DURATION_TWO;\n            price = calculatePrice(turningPrice, endPrice, turnTime, endTime, block.timestamp);\n        } else {\n            price = endPrice;\n        }\n        return price;\n    }\n}\n"
    },
    "contracts/configuration/ACLManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '../interfaces/IACLManager.sol';\n\ncontract ACLManager is IACLManager, AccessControl, Ownable {\n    bytes32 public constant POOL_ADMIN_ROLE = keccak256('POOL_ADMIN');\n    \n    bytes32 public constant EMERGENCY_ADMIN_ROLE = keccak256('EMERGENCY_ADMIN');\n\n    bytes32 public constant GOVERNANCE_ROLE = keccak256('GOVERNANCE');\n\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256('LIQUIDATOR');\n\n    bytes32 public constant LIQUIDATION_OPERATOR = keccak256('LIQUIDATION_OPERATOR');\n\n    bytes32 public constant AIRDROP_OPERATOR = keccak256('AIRDROP_OPERATOR');\n\n    constructor() Ownable() {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner());\n    }\n    \n    function addEmergencyAdmin(address admin) external override {\n        grantRole(EMERGENCY_ADMIN_ROLE, admin);\n    }\n\n    function isEmergencyAdmin(address admin) external view override returns (bool) {\n        return hasRole(EMERGENCY_ADMIN_ROLE, admin);\n    }\n\n    function removeEmergencyAdmin(address admin) external override {\n        revokeRole(EMERGENCY_ADMIN_ROLE, admin);\n    }\n\n    function addGovernance(address admin) external override {\n        grantRole(GOVERNANCE_ROLE, admin);\n    }\n\n    function isGovernance(address admin) external view override returns (bool) {\n        return hasRole(GOVERNANCE_ROLE, admin);\n    }\n\n    function removeGovernance(address admin) external override {\n        revokeRole(GOVERNANCE_ROLE, admin);\n    }\n\n    function addPoolAdmin(address poolAdmin) external override {\n        grantRole(POOL_ADMIN_ROLE, poolAdmin);\n    }\n\n    function isPoolAdmin(address poolAdmin) external view override returns (bool) {\n        return hasRole(POOL_ADMIN_ROLE, poolAdmin);\n    }\n\n    function removePoolAdmin(address poolAdmin) external override {\n        revokeRole(POOL_ADMIN_ROLE, poolAdmin);\n    }\n\n    function addLiquidationOperator(address address_) external override {\n        grantRole(LIQUIDATION_OPERATOR, address_);\n    }\n\n    function isLiquidationOperator(address address_) external view override returns (bool) {\n        return hasRole(LIQUIDATION_OPERATOR, address_);\n    }\n\n    function removeLiquidationOperator(address address_) external override {\n        revokeRole(LIQUIDATION_OPERATOR, address_);\n    }\n\n    function addAirdropOperator(address address_) external override {\n        grantRole(AIRDROP_OPERATOR, address_);\n    }\n\n    function isAirdropOperator(address address_) external view override returns (bool) {\n        return hasRole(AIRDROP_OPERATOR, address_);\n    }\n\n    function removeAirdropOperator(address address_) external override {\n        revokeRole(AIRDROP_OPERATOR, address_);\n    }\n    \n}\n"
    },
    "contracts/mocks/token/OpenSkyERC1155Mock.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\n\ncontract OpenSkyERC1155Mock is ERC1155 {\n    constructor(string memory uri) ERC1155(uri) {}\n\n    function setURI(string memory newuri) public {\n        _setURI(newuri);\n    }\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public {\n        _mint(to, id, value, data);\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public {\n        _mintBatch(to, ids, values, data);\n    }\n\n    function burn(\n        address owner,\n        uint256 id,\n        uint256 value\n    ) public {\n        _burn(owner, id, value);\n    }\n\n    function burnBatch(\n        address owner,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public {\n        _burnBatch(owner, ids, values);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/mocks/token/TestERC20.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract TestERC20 is Ownable, ERC20, ERC20Permit, ERC20Votes {\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) ERC20Permit(name) {\n        _mint(msg.sender, 20000* 10**18);\n    }\n\n    function mint(address dest, uint256 amount) external onlyOwner {\n        _mint(dest, amount);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._mint(to, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._burn(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/token/MintableERC20.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract MintableERC20 is ERC20 {\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {}\n    function mint(uint256 value) public returns (bool) {\n        _mint(_msgSender(), value);\n        return true;\n    }\n}\n"
    },
    "contracts/configuration/OpenSkySettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '../interfaces/IOpenSkySettings.sol';\nimport '../interfaces/IACLManager.sol';\nimport '../libraries/types/DataTypes.sol';\nimport '../libraries/helpers/Errors.sol';\n\ncontract OpenSkySettings is IOpenSkySettings, Ownable {\n    uint256 public constant MAX_RESERVE_FACTOR = 3000;\n\n    address public immutable ACLManagerAddress;\n\n    // nftAddress=>data\n    mapping(uint256 => mapping(address => DataTypes.WhitelistInfo)) internal _whitelist;\n\n    // liquidator contract whitelist\n    mapping(address => bool) internal _liquidators;\n\n    // one-time initialization factors\n    address public override poolAddress;\n    address public override loanAddress;\n    address public override vaultFactoryAddress;\n    address public override incentiveControllerAddress;\n    address public override wethGatewayAddress;\n    address public override punkGatewayAddress;\n    address public override daoVaultAddress;\n\n    // governance factors\n    address public override moneyMarketAddress;\n    address public override treasuryAddress;\n    address public override loanDescriptorAddress;\n    address public override nftPriceOracleAddress;\n    address public override interestRateStrategyAddress;\n\n    uint256 public override reserveFactor = 2000;\n    uint256 public override prepaymentFeeFactor = 0;\n    uint256 public override overdueLoanFeeFactor = 100;\n\n    constructor(address _ACLManagerAddress) Ownable() {\n        ACLManagerAddress = _ACLManagerAddress;\n    }\n\n    modifier onlyGovernance() {\n        IACLManager ACLManager = IACLManager(ACLManagerAddress);\n        require(ACLManager.isGovernance(_msgSender()), Errors.ACL_ONLY_GOVERNANCE_CAN_CALL);\n        _;\n    }\n\n    modifier onlyWhenNotInitialized(address address_) {\n        require(address_ == address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        _;\n    }\n\n    function initPoolAddress(address address_) external onlyOwner onlyWhenNotInitialized(poolAddress) {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        poolAddress = address_;\n        emit InitPoolAddress(msg.sender, address_);\n    }\n\n    function initLoanAddress(address address_) external onlyOwner onlyWhenNotInitialized(loanAddress) {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        loanAddress = address_;\n        emit InitLoanAddress(msg.sender, address_);\n    }\n\n    function initVaultFactoryAddress(address address_) external onlyOwner onlyWhenNotInitialized(vaultFactoryAddress) {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        vaultFactoryAddress = address_;\n        emit InitVaultFactoryAddress(msg.sender, address_);\n    }\n\n    function initIncentiveControllerAddress(address address_)\n        external\n        onlyOwner\n        onlyWhenNotInitialized(incentiveControllerAddress)\n    {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        incentiveControllerAddress = address_;\n        emit InitIncentiveControllerAddress(msg.sender, address_);\n    }\n\n    function initWETHGatewayAddress(address address_) external onlyOwner onlyWhenNotInitialized(wethGatewayAddress) {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        wethGatewayAddress = address_;\n        emit InitWETHGatewayAddress(msg.sender, address_);\n    }\n\n    function initPunkGatewayAddress(address address_) external onlyOwner onlyWhenNotInitialized(punkGatewayAddress) {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        punkGatewayAddress = address_;\n        emit InitPunkGatewayAddress(msg.sender, address_);\n    }\n\n    function initDaoVaultAddress(address address_) external onlyOwner onlyWhenNotInitialized(daoVaultAddress) {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        daoVaultAddress = address_;\n        emit InitDaoVaultAddress(msg.sender, address_);\n    }\n\n    // Only take effect when creating new reserve\n    function setMoneyMarketAddress(address address_) external onlyGovernance {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        moneyMarketAddress = address_;\n        emit SetMoneyMarketAddress(msg.sender, address_);\n    }\n\n    function setTreasuryAddress(address address_) external onlyGovernance {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        treasuryAddress = address_;\n        emit SetTreasuryAddress(msg.sender, address_);\n    }\n\n    function setLoanDescriptorAddress(address address_) external onlyGovernance {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        loanDescriptorAddress = address_;\n        emit SetLoanDescriptorAddress(msg.sender, address_);\n    }\n\n    function setNftPriceOracleAddress(address address_) external onlyGovernance {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        nftPriceOracleAddress = address_;\n        emit SetNftPriceOracleAddress(msg.sender, address_);\n    }\n\n    function setInterestRateStrategyAddress(address address_) external onlyGovernance {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        interestRateStrategyAddress = address_;\n        emit SetInterestRateStrategyAddress(msg.sender, address_);\n    }\n\n    function setReserveFactor(uint256 factor) external onlyGovernance {\n        require(factor <= MAX_RESERVE_FACTOR, Errors.SETTING_RESERVE_FACTOR_NOT_ALLOWED);\n        reserveFactor = factor;\n        emit SetReserveFactor(msg.sender, factor);\n    }\n\n    function setPrepaymentFeeFactor(uint256 factor) external onlyGovernance {\n        prepaymentFeeFactor = factor;\n        emit SetPrepaymentFeeFactor(msg.sender, factor);\n    }\n\n    function setOverdueLoanFeeFactor(uint256 factor) external onlyGovernance {\n        overdueLoanFeeFactor = factor;\n        emit SetOverdueLoanFeeFactor(msg.sender, factor);\n    }\n\n    function addToWhitelist(\n        uint256 reserveId,\n        address nft,\n        string memory name,\n        string memory symbol,\n        uint256 LTV,\n        uint256 minBorrowDuration,\n        uint256 maxBorrowDuration,\n        uint256 extendableDuration,\n        uint256 overdueDuration\n    ) external onlyGovernance {\n        require(reserveId > 0, Errors.SETTING_WHITELIST_INVALID_RESERVE_ID);\n        require(nft != address(0), Errors.SETTING_WHITELIST_NFT_ADDRESS_IS_ZERO);\n        require(minBorrowDuration <= maxBorrowDuration, Errors.SETTING_WHITELIST_NFT_DURATION_OUT_OF_ORDER);\n        require(bytes(name).length != 0, Errors.SETTING_WHITELIST_NFT_NAME_EMPTY);\n        require(bytes(symbol).length != 0, Errors.SETTING_WHITELIST_NFT_SYMBOL_EMPTY);\n        require(LTV > 0 && LTV <= 10000, Errors.SETTING_WHITELIST_NFT_LTV_NOT_ALLOWED);\n\n        _whitelist[reserveId][nft] = DataTypes.WhitelistInfo({\n            enabled: true,\n            name: name,\n            symbol: symbol,\n            LTV: LTV,\n            minBorrowDuration: minBorrowDuration,\n            maxBorrowDuration: maxBorrowDuration,\n            extendableDuration: extendableDuration,\n            overdueDuration: overdueDuration\n        });\n        emit AddToWhitelist(msg.sender, reserveId, nft);\n    }\n\n    function removeFromWhitelist(uint256 reserveId, address nft) external onlyGovernance {\n        if (_whitelist[reserveId][nft].enabled) {\n            _whitelist[reserveId][nft].enabled = false;\n            emit RemoveFromWhitelist(msg.sender, reserveId, nft);\n        }\n    }\n\n    function inWhitelist(uint256 reserveId, address nft) external view override returns (bool) {\n        return _whitelist[reserveId][nft].enabled;\n    }\n\n    function getWhitelistDetail(uint256 reserveId, address nft)\n        external\n        view\n        override\n        returns (DataTypes.WhitelistInfo memory)\n    {\n        return _whitelist[reserveId][nft];\n    }\n\n    // liquidator\n    function addLiquidator(address address_) external onlyGovernance {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        if (!_liquidators[address_]) {\n            _liquidators[address_] = true;\n            emit AddLiquidator(msg.sender, address_);\n        }\n    }\n\n    function removeLiquidator(address address_) external onlyGovernance {\n        require(address_ != address(0), Errors.SETTING_ZERO_ADDRESS_NOT_ALLOWED);\n        if (_liquidators[address_]) {\n            _liquidators[address_] = false;\n            emit RemoveLiquidator(msg.sender, address_);\n        }\n    }\n\n    function isLiquidator(address address_) external view override returns (bool) {\n        return _liquidators[address_];\n    }\n}\n"
    },
    "contracts/mocks/OpenSkyLoanMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../OpenSkyLoan.sol';\n\ncontract OpenSkyLoanMock is OpenSkyLoan {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _settings,\n        address _pool\n    ) OpenSkyLoan(name, symbol, _settings, _pool) {}\n\n    function setPoolAddress(address pool) external {\n        _pool = pool;\n    }\n\n    function poolAddress() external view returns (address) {\n        return _pool;\n    }\n \n    function updateStatus(uint256 tokenId, DataTypes.LoanStatus status) external {\n        _updateStatus(tokenId, status);\n    }\n}\n"
    },
    "contracts/mocks/OpenSkyPoolMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../OpenSkyPool.sol';\nimport '../interfaces/IOpenSkyMoneyMarket.sol';\n\ninterface IOpenSkyMoneyMarketUpdate {\n    function simulateInterestIncrease(address to) external payable;\n}\n\ncontract OpenSkyPoolMock is OpenSkyPool {\n    using ReserveLogic for DataTypes.ReserveData;\n\n    mapping(uint256 => uint256) public reserveNormalizedIncomes;\n\n    constructor(address settings_) OpenSkyPool(settings_) {}\n\n    function updateState(uint256 reserveId, uint256 additionalAmount) external {\n        reserves[reserveId].updateState(additionalAmount);\n    }\n\n    function calculateIncome(uint256 reserveId, uint256 additionalIncome)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return reserves[reserveId].calculateIncome(additionalIncome);\n    }\n\n    function updateInterestPerSecond(\n        uint256 reserveId,\n        uint256 amountToAdd,\n        uint256 amountToRemove\n    ) external {\n        reserves[reserveId].updateInterestPerSecond(amountToAdd, amountToRemove);\n    }\n\n    function updateLastMoneyMarketBalance(\n        uint256 reserveId,\n        uint256 amountToAdd,\n        uint256 amountToRemove\n    ) external {\n        reserves[reserveId].updateLastMoneyMarketBalance(amountToAdd, amountToRemove);\n    }\n\n    function updateMoneyMarketIncome(uint256 reserveId) external payable {\n        IOpenSkyMoneyMarketUpdate moneyMarket = IOpenSkyMoneyMarketUpdate(reserves[reserveId].moneyMarketAddress);\n        moneyMarket.simulateInterestIncrease{value: msg.value}(reserves[reserveId].oTokenAddress);\n    }\n\n    function getMoneyMarketDelta(uint256 reserveId) public view returns (uint256) {\n        return reserves[reserveId].getMoneyMarketDelta();\n    }\n\n    function getBorrowingInterestDelta(uint256 reserveId) public view returns (uint256) {\n        return reserves[reserveId].getBorrowingInterestDelta();\n    }\n\n    function setReserveNormalizedIncome(uint256 reserveId, uint128 normalizedIncome) public {\n        reserves[reserveId].lastSupplyIndex = normalizedIncome;\n    }\n\n    function getReserveNormalizedIncome(uint256 reserveId) public view override returns (uint256) {\n        return\n            reserveNormalizedIncomes[reserveId] > 0\n                ? reserveNormalizedIncomes[reserveId]\n                : reserves[reserveId].getNormalizedIncome();\n        //return reserveNormalizedIncomes[reserveId] > 0 ? reserveNormalizedIncomes[reserveId] : super.getReserveNormalizedIncome(reserveId);\n    }\n}\n"
    },
    "contracts/bespokemarket/offerStrategies/StrategyTokenId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '../libraries/BespokeTypes.sol';\n\ncontract StrategyTokenId {\n    function validate(BespokeTypes.Offer memory offerData, BespokeTypes.TakeLendInfoForStrategy memory takeInfo)\n        external\n        view\n    {\n        require(offerData.nonceMaxTimes == 1, 'BM_STRATEGY_TOKEN_ID_NONCE_MAXTIMES_INVALID');\n        require(offerData.tokenId == takeInfo.tokenId, 'BM_STRATEGY_TOKEN_ID_NOT_MATCH');\n    }\n}\n"
    },
    "contracts/bespokemarket/offerStrategies/StrategyPrivate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '../libraries/BespokeTypes.sol';\n\ncontract StrategyPrivate {\n    function validate(BespokeTypes.Offer memory offerData, BespokeTypes.TakeLendInfoForStrategy memory takeInfo)\n        external\n        view\n    {\n        address targetBorrower = abi.decode(offerData.params, (address));\n\n        require(offerData.nonceMaxTimes == 1, 'BM_STRATEGY_PRIVATE_NONCEMAXTIMES_INVALID');\n\n        require(offerData.tokenId == takeInfo.tokenId, 'BM_STRATEGY_PRIVATE_TOKEN_ID_NOT_MATCH');\n\n        require(targetBorrower == takeInfo.taker, 'BM_STRATEGY_PRIVATE_ACCOUNT_NOT_MATCH');\n    }\n}\n"
    },
    "contracts/bespokemarket/offerStrategies/StrategyByAttribute.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\n\nimport '../libraries/BespokeTypes.sol';\n\ncontract StrategyByAttribute {\n    function validate(BespokeTypes.Offer memory offerData, BespokeTypes.TakeLendInfoForStrategy memory takeInfo)\n        external\n        view\n    {\n        // Precomputed merkleRoot (that contains the tokenIds that match a common characteristic)\n        bytes32 merkleRoot = abi.decode(offerData.params, (bytes32));\n\n        // MerkleProof + indexInTree + tokenId\n        bytes32[] memory merkleProof = abi.decode(takeInfo.params, (bytes32[]));\n\n        // Compute the node\n        bytes32 node = keccak256(abi.encodePacked(takeInfo.tokenId));\n\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'BM_STRATEGY_BY_ATTRIBUTE_FAILED');\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/bespokemarket/offerStrategies/StrategyAnyInSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '../libraries/BespokeTypes.sol';\n\ncontract StrategyAnyInSet {\n    function validate(BespokeTypes.Offer memory offerData, BespokeTypes.TakeLendInfoForStrategy memory takeInfo)\n        external\n        view\n    {\n        uint256[] memory tokenIds = abi.decode(takeInfo.params, (uint256[]));\n\n        bool inSet = false;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if (tokenIds[i] == takeInfo.tokenId) {\n                inSet = true;\n                break;\n            }\n        }\n\n        require(inSet, 'BM_STRATEGY_ANYINSET_FAILED');\n    }\n}\n"
    },
    "contracts/bespokemarket/offerStrategies/StrategyAnyInCollection.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport '../libraries/BespokeTypes.sol';\n\ncontract StrategyAnyInCollection {\n    function validate(BespokeTypes.Offer memory offerData, BespokeTypes.TakeLendInfoForStrategy memory takeInfo)\n        external\n        view\n    {\n        // Do nothing\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}