{
  "language": "Solidity",
  "sources": {
    "contracts/incentives/base/BaseIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\nimport {SafeMath} from '../lib/SafeMath.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {VersionedInitializable} from '../utils/VersionedInitializable.sol';\nimport {DistributionManager} from './DistributionManager.sol';\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\n\n/**\n * @title BaseIncentivesController\n * @notice Abstract contract template to build Distributors contracts for ERC20 rewards to protocol participants\n * @author Aave\n **/\nabstract contract BaseIncentivesController is\nIAaveIncentivesController,\nVersionedInitializable,\nDistributionManager\n{\n    using SafeMath for uint256;\n\n    uint256 public constant REVISION = 1;\n\n    address public immutable override REWARD_TOKEN;\n\n    mapping(address => uint256) internal _usersUnclaimedRewards;\n\n    // this mapping allows whitelisted addresses to claim on behalf of others\n    // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n    mapping(address => address) internal _authorizedClaimers;\n\n    modifier onlyAuthorizedClaimers(address claimer, address user) {\n        require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\n        _;\n    }\n\n    constructor(IERC20 rewardToken, address emissionManager)\n    DistributionManager(emissionManager)\n    {\n        REWARD_TOKEN = address(rewardToken);\n    }\n\n    /// @inheritdoc IAaveIncentivesController\n    function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external\n    override\n    onlyEmissionManager\n    {\n        require(assets.length == emissionsPerSecond.length, 'INVALID_CONFIGURATION');\n\n        DistributionTypes.AssetConfigInput[] memory assetsConfig =\n                    new DistributionTypes.AssetConfigInput[](assets.length);\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(uint104(emissionsPerSecond[i]) == emissionsPerSecond[i], 'Index overflow at emissionsPerSecond');\n            assetsConfig[i].underlyingAsset = assets[i];\n            assetsConfig[i].emissionPerSecond = uint104(emissionsPerSecond[i]);\n            assetsConfig[i].totalStaked = _getTotalSupply(assets[i]);\n        }\n        _configureAssets(assetsConfig);\n    }\n\n    /// @inheritdoc IAaveIncentivesController\n    function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    override\n    returns (uint256)\n    {\n        uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n        DistributionTypes.UserStakeInput[] memory userState =\n                    new DistributionTypes.UserStakeInput[](assets.length);\n        for (uint256 i = 0; i < assets.length; i++) {\n            userState[i].underlyingAsset = assets[i];\n            (userState[i].stakedByUser, userState[i].totalStaked) = _getUserBalanceAndSupply(assets[i], user);\n        }\n        unclaimedRewards = unclaimedRewards.add(_getUnclaimedRewards(user, userState));\n        return unclaimedRewards;\n    }\n\n    /// @inheritdoc IAaveIncentivesController\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external override returns (uint256) {\n        require(to != address(0), 'INVALID_TO_ADDRESS');\n        return _claimRewards(assets, amount, msg.sender, msg.sender, to);\n    }\n\n    /// @inheritdoc IAaveIncentivesController\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n        require(user != address(0), 'INVALID_USER_ADDRESS');\n        require(to != address(0), 'INVALID_TO_ADDRESS');\n        return _claimRewards(assets, amount, msg.sender, user, to);\n    }\n\n    /// @inheritdoc IAaveIncentivesController\n    function claimRewardsToSelf(address[] calldata assets, uint256 amount)\n    external\n    override\n    returns (uint256)\n    {\n        return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender);\n    }\n\n    /// @inheritdoc IAaveIncentivesController\n    function setClaimer(address user, address caller) external override onlyEmissionManager {\n        _authorizedClaimers[user] = caller;\n        emit ClaimerSet(user, caller);\n    }\n\n    /// @inheritdoc IAaveIncentivesController\n    function getClaimer(address user) external view override returns (address) {\n        return _authorizedClaimers[user];\n    }\n\n    /// @inheritdoc IAaveIncentivesController\n    function getUserUnclaimedRewards(address _user) external view override returns (uint256) {\n        return _usersUnclaimedRewards[_user];\n    }\n\n    /**\n     * @dev returns the revision of the implementation contract\n   */\n    function getRevision() internal pure override returns (uint256) {\n        return REVISION;\n    }\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n    function _claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address claimer,\n        address user,\n        address to\n    ) internal returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n        if (amount > unclaimedRewards) {\n            DistributionTypes.UserStakeInput[] memory userState =\n                        new DistributionTypes.UserStakeInput[](assets.length);\n            for (uint256 i = 0; i < assets.length; i++) {\n                userState[i].underlyingAsset = assets[i];\n                (userState[i].stakedByUser, userState[i].totalStaked) = _getUserBalanceAndSupply(assets[i], user);\n            }\n\n            uint256 accruedRewards = _claimRewards(user, userState);\n            if (accruedRewards != 0) {\n                unclaimedRewards = unclaimedRewards.add(accruedRewards);\n                emit RewardsAccrued(user, accruedRewards);\n            }\n        }\n\n        if (unclaimedRewards == 0) {\n            return 0;\n        }\n\n        uint256 amountToClaim = amount > unclaimedRewards ? unclaimedRewards : amount;\n        _usersUnclaimedRewards[user] = unclaimedRewards - amountToClaim; // Safe due to the previous line\n\n        _transferRewards(to, amountToClaim);\n        emit RewardsClaimed(user, to, claimer, amountToClaim);\n\n        return amountToClaim;\n    }\n\n    /**\n     * @dev Abstract function to transfer rewards to the desired account\n   * @param to Account address to send the rewards\n   * @param amount Amount of rewards to transfer\n   */\n    function _transferRewards(address to, uint256 amount) internal virtual;\n\n    function _getUserBalanceAndSupply(address asset, address user) internal view virtual returns (uint256, uint256);\n\n    function _getTotalSupply(address asset) internal view virtual returns (uint256);\n\n    function handleAction(\n        address user,\n        uint256 totalSupply,\n        uint256 userBalance,\n        bytes calldata params\n    ) external virtual;\n}\n"
    },
    "contracts/incentives/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\n/// inspired by uniswap V3\nlibrary SafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns(uint256) {\n        // no need to check for division by zero - solidity already reverts\n        return x / y;\n    }\n}\n"
    },
    "contracts/incentives/lib/DistributionTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\nlibrary DistributionTypes {\n  struct AssetConfigInput {\n    uint104 emissionPerSecond;\n    uint256 totalStaked;\n    address underlyingAsset;\n  }\n\n  struct UserStakeInput {\n    address underlyingAsset;\n    uint256 stakedByUser;\n    uint256 totalStaked;\n  }\n}\n"
    },
    "contracts/incentives/utils/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\nabstract contract VersionedInitializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  uint256 internal lastInitializedRevision = 0;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    uint256 revision = getRevision();\n    require(revision > lastInitializedRevision, 'Contract instance has already been initialized');\n\n    lastInitializedRevision = revision;\n\n    _;\n  }\n\n  /// @dev returns the revision number of the contract.\n  /// Needs to be defined in the inherited class as a constant.\n  function getRevision() internal pure virtual returns (uint256);\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/incentives/base/DistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\nimport {SafeMath} from '../lib/SafeMath.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\n\n/**\n * @title DistributionManager\n * @notice Accounting contract to manage multiple staking distributions\n * @author Aave\n **/\ncontract DistributionManager is IAaveDistributionManager {\n  using SafeMath for uint256;\n\n  struct AssetData {\n    uint104 emissionPerSecond;\n    uint104 index;\n    uint40 lastUpdateTimestamp;\n    mapping(address => uint256) users;\n  }\n\n  address public immutable EMISSION_MANAGER;\n\n  uint8 public constant PRECISION = 18;\n\n  mapping(address => AssetData) public assets;\n\n  uint256 internal _distributionEnd;\n\n  modifier onlyEmissionManager() {\n    require(msg.sender == EMISSION_MANAGER, 'ONLY_EMISSION_MANAGER');\n    _;\n  }\n\n  constructor(address emissionManager) {\n    EMISSION_MANAGER = emissionManager;\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function setDistributionEnd(uint256 distributionEnd) external override onlyEmissionManager {\n    _distributionEnd = distributionEnd;\n    emit DistributionEndUpdated(distributionEnd);\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function getDistributionEnd() external view override returns (uint256) {\n    return _distributionEnd;\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function DISTRIBUTION_END() external view override returns (uint256) {\n    return _distributionEnd;\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function getUserAssetData(address user, address asset) public view override returns (uint256) {\n    return assets[asset].users[user];\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function getAssetData(address asset) public view override returns (uint256, uint256, uint256) {\n    return (assets[asset].index, assets[asset].emissionPerSecond, assets[asset].lastUpdateTimestamp);\n  }\n\n  /**\n   * @dev Configure the assets for a specific emission\n   * @param assetsConfigInput The array of each asset configuration\n   **/\n  function _configureAssets(DistributionTypes.AssetConfigInput[] memory assetsConfigInput)\n    internal\n  {\n    for (uint256 i = 0; i < assetsConfigInput.length; i++) {\n      AssetData storage assetConfig = assets[assetsConfigInput[i].underlyingAsset];\n\n      _updateAssetStateInternal(\n        assetsConfigInput[i].underlyingAsset,\n        assetConfig,\n        assetsConfigInput[i].totalStaked\n      );\n\n      assetConfig.emissionPerSecond = assetsConfigInput[i].emissionPerSecond;\n\n      emit AssetConfigUpdated(\n        assetsConfigInput[i].underlyingAsset,\n        assetsConfigInput[i].emissionPerSecond\n      );\n    }\n  }\n\n  /**\n   * @dev Updates the state of one distribution, mainly rewards index and timestamp\n   * @param asset The address of the asset being updated\n   * @param assetConfig Storage pointer to the distribution's config\n   * @param totalStaked Current total of staked assets for this distribution\n   * @return The new distribution index\n   **/\n  function _updateAssetStateInternal(\n    address asset,\n    AssetData storage assetConfig,\n    uint256 totalStaked\n  ) internal returns (uint256) {\n    uint256 oldIndex = assetConfig.index;\n    uint256 emissionPerSecond = assetConfig.emissionPerSecond;\n    uint128 lastUpdateTimestamp = assetConfig.lastUpdateTimestamp;\n\n    if (block.timestamp == lastUpdateTimestamp) {\n      return oldIndex;\n    }\n\n    uint256 newIndex =\n      _getAssetIndex(oldIndex, emissionPerSecond, lastUpdateTimestamp, totalStaked);\n\n    if (newIndex != oldIndex) {\n      require(uint104(newIndex) == newIndex, 'Index overflow');\n      //optimization: storing one after another saves one SSTORE\n      assetConfig.index = uint104(newIndex);\n      assetConfig.lastUpdateTimestamp = uint40(block.timestamp);\n      emit AssetIndexUpdated(asset, newIndex);\n    } else {\n      assetConfig.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    return newIndex;\n  }\n\n  /**\n   * @dev Updates the state of an user in a distribution\n   * @param user The user's address\n   * @param asset The address of the reference asset of the distribution\n   * @param stakedByUser Amount of tokens staked by the user in the distribution at the moment\n   * @param totalStaked Total tokens staked in the distribution\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _updateUserAssetInternal(\n    address user,\n    address asset,\n    uint256 stakedByUser,\n    uint256 totalStaked\n  ) internal returns (uint256) {\n    AssetData storage assetData = assets[asset];\n    uint256 userIndex = assetData.users[user];\n    uint256 accruedRewards = 0;\n\n    uint256 newIndex = _updateAssetStateInternal(asset, assetData, totalStaked);\n\n    if (userIndex != newIndex) {\n      if (stakedByUser != 0) {\n        accruedRewards = _getRewards(stakedByUser, newIndex, userIndex);\n      }\n\n      assetData.users[user] = newIndex;\n      emit UserIndexUpdated(user, asset, newIndex);\n    }\n\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Used by \"frontend\" stake contracts to update the data of an user when claiming rewards from there\n   * @param user The address of the user\n   * @param stakes List of structs of the user data related with his stake\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _claimRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\n    internal\n    returns (uint256)\n  {\n    uint256 accruedRewards = 0;\n\n    for (uint256 i = 0; i < stakes.length; i++) {\n      accruedRewards = accruedRewards.add(\n        _updateUserAssetInternal(\n          user,\n          stakes[i].underlyingAsset,\n          stakes[i].stakedByUser,\n          stakes[i].totalStaked\n        )\n      );\n    }\n\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Return the accrued rewards for an user over a list of distribution\n   * @param user The address of the user\n   * @param stakes List of structs of the user data related with his stake\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _getUnclaimedRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 accruedRewards = 0;\n\n    for (uint256 i = 0; i < stakes.length; i++) {\n      AssetData storage assetConfig = assets[stakes[i].underlyingAsset];\n      uint256 assetIndex =\n        _getAssetIndex(\n          assetConfig.index,\n          assetConfig.emissionPerSecond,\n          assetConfig.lastUpdateTimestamp,\n          stakes[i].totalStaked\n        );\n\n      accruedRewards = accruedRewards.add(\n        _getRewards(stakes[i].stakedByUser, assetIndex, assetConfig.users[user])\n      );\n    }\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Internal function for the calculation of user's rewards on a distribution\n   * @param principalUserBalance Amount staked by the user on a distribution\n   * @param reserveIndex Current index of the distribution\n   * @param userIndex Index stored for the user, representation his staking moment\n   * @return The rewards\n   **/\n  function _getRewards(\n    uint256 principalUserBalance,\n    uint256 reserveIndex,\n    uint256 userIndex\n  ) internal pure returns (uint256) {\n    return principalUserBalance.mul(reserveIndex.sub(userIndex)) / 10**uint256(PRECISION);\n  }\n\n  /**\n   * @dev Calculates the next value of an specific distribution index, with validations\n   * @param currentIndex Current index of the distribution\n   * @param emissionPerSecond Representing the total rewards distributed per second per asset unit, on the distribution\n   * @param lastUpdateTimestamp Last moment this distribution was updated\n   * @param totalBalance of tokens considered for the distribution\n   * @return The new index.\n   **/\n  function _getAssetIndex(\n    uint256 currentIndex,\n    uint256 emissionPerSecond,\n    uint128 lastUpdateTimestamp,\n    uint256 totalBalance\n  ) internal view returns (uint256) {\n    uint256 distributionEnd = _distributionEnd;\n    if (\n      emissionPerSecond == 0 ||\n      totalBalance == 0 ||\n      lastUpdateTimestamp == block.timestamp ||\n      lastUpdateTimestamp >= distributionEnd\n    ) {\n      return currentIndex;\n    }\n\n    uint256 currentTimestamp =\n      block.timestamp > distributionEnd ? distributionEnd : block.timestamp;\n    uint256 timeDelta = currentTimestamp.sub(lastUpdateTimestamp);\n    return\n      emissionPerSecond.mul(timeDelta).mul(10**uint256(PRECISION)).div(totalBalance).add(\n        currentIndex\n      );\n  }\n}\n"
    },
    "contracts/incentives/interfaces/IERC20.sol": {
      "content": "pragma solidity 0.8.10;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/incentives/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\n\ninterface IAaveIncentivesController is IAaveDistributionManager {\n  event RewardsAccrued(address indexed user, uint256 amount);\n\n  event RewardsClaimed(\n    address indexed user,\n    address indexed to,\n    address indexed claimer,\n    uint256 amount\n  );\n\n  event ClaimerSet(address indexed user, address indexed claimer);\n\n  /**\n   * @dev Whitelists an address to claim the rewards on behalf of another address\n   * @param user The address of the user\n   * @param claimer The address of the claimer\n   */\n  function setClaimer(address user, address claimer) external;\n\n  /**\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n   * @param user The address of the user\n   * @return The claimer address\n   */\n  function getClaimer(address user) external view returns (address);\n\n  /**\n   * @dev Configure assets for a certain rewards emission\n   * @param assets The assets to incentivize\n   * @param emissionsPerSecond The emission for each asset\n   */\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external;\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param asset The address of the user\n   * @param userBalance The balance of the user of the asset in the lending pool\n   * @param totalSupply The total supply of the asset in the lending pool\n   * @param params extra params\n   **/\n  function handleAction(\n    address asset,\n    uint256 userBalance,\n    uint256 totalSupply,\n    bytes calldata params\n  ) external;\n\n  /**\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n   * @param user The address of the user\n   * @return The rewards\n   **/\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Claims reward for an user to the desired address, on all the assets of the lending pool, accumulating the pending rewards\n   * @param amount Amount of rewards to claim\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Claims reward for msg.sender, on all the assets of the lending pool, accumulating the pending rewards\n   * @param amount Amount of rewards to claim\n   * @return Rewards claimed\n   **/\n  function claimRewardsToSelf(address[] calldata assets, uint256 amount) external returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @return the unclaimed user rewards\n   */\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function REWARD_TOKEN() external view returns (address);\n}\n"
    },
    "contracts/incentives/interfaces/IAaveDistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\n\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\n\ninterface IAaveDistributionManager {\n  \n  event AssetConfigUpdated(address indexed asset, uint256 emission);\n  event AssetIndexUpdated(address indexed asset, uint256 index);\n  event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\n  event DistributionEndUpdated(uint256 newDistributionEnd);\n\n  /**\n  * @dev Sets the end date for the distribution\n  * @param distributionEnd The end date timestamp\n  **/\n  function setDistributionEnd(uint256 distributionEnd) external;\n\n  /**\n  * @dev Gets the end date for the distribution\n  * @return The end of the distribution\n  **/\n  function getDistributionEnd() external view returns (uint256);\n\n  /**\n  * @dev for backwards compatibility with the previous DistributionManager used\n  * @return The end of the distribution\n  **/\n  function DISTRIBUTION_END() external view returns(uint256);\n\n   /**\n   * @dev Returns the data of an user on a distribution\n   * @param user Address of the user\n   * @param asset The address of the reference asset of the distribution\n   * @return The new index\n   **/\n   function getUserAssetData(address user, address asset) external view returns (uint256);\n\n   /**\n   * @dev Returns the configuration of the distribution for a certain asset\n   * @param asset The address of the reference asset of the distribution\n   * @return The asset index, the emission per second and the last updated timestamp\n   **/\n   function getAssetData(address asset) external view returns (uint256, uint256, uint256);\n}\n"
    },
    "contracts/incentives/OpenSkyPoolIncentivesControllerLender.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\nimport {IERC20} from './interfaces/IERC20.sol';\nimport {SafeERC20} from './lib/SafeERC20.sol';\nimport {SafeMath} from './lib/SafeMath.sol';\n\nimport {BaseIncentivesController} from './base/BaseIncentivesController.sol';\nimport {IScaledBalanceToken} from './interfaces/IScaledBalanceToken.sol';\n\n\ncontract OpenSkyPoolIncentivesControllerLender is\nBaseIncentivesController\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address internal _rewardsVault;\n    \n    event RewardsVaultUpdated(address indexed vault);\n\n    constructor(IERC20 rewardToken, address emissionManager)\n    BaseIncentivesController(rewardToken, emissionManager)\n    {}\n\n    /**\n     * @dev Initialize AaveIncentivesController\n   * @param rewardsVault rewards vault to pull ERC20 funds\n   **/\n    function initialize(address rewardsVault) external initializer {\n        require(rewardsVault != address(0));\n        _rewardsVault = rewardsVault;\n        emit RewardsVaultUpdated(_rewardsVault);\n    }\n\n    /**\n     * @dev returns the current rewards vault contract\n   * @return address\n   */\n    function getRewardsVault() external view returns (address) {\n        return _rewardsVault;\n    }\n\n    /**\n     * @dev update the rewards vault address, only allowed by the Rewards admin\n   * @param rewardsVault The address of the rewards vault\n   **/\n    function setRewardsVault(address rewardsVault) external onlyEmissionManager {\n        _rewardsVault = rewardsVault;\n        emit RewardsVaultUpdated(rewardsVault);\n    }\n\n    /// @inheritdoc BaseIncentivesController\n    function _transferRewards(address to, uint256 amount) internal override {\n        IERC20(REWARD_TOKEN).safeTransferFrom(_rewardsVault, to, amount);\n    }\n\n    function _getUserBalanceAndSupply(address asset, address user) internal view override returns (uint256, uint256) {\n        return IScaledBalanceToken(asset).getScaledUserBalanceAndSupply(user);\n    }\n\n    function _getTotalSupply(address asset) internal view override returns (uint256){\n        return IScaledBalanceToken(asset).scaledTotalSupply();\n    }\n\n    function handleAction(\n        address user,\n        uint256 totalSupply,\n        uint256 userBalance,\n        bytes calldata params //ignore\n    ) external override {\n        uint256 accruedRewards = _updateUserAssetInternal(user, msg.sender, userBalance, totalSupply);\n        if (accruedRewards != 0) {\n            _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n            emit RewardsAccrued(user, accruedRewards);\n        }\n    }\n}\n"
    },
    "contracts/incentives/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {SafeMath} from './SafeMath.sol';\nimport {Address} from './Address.sol';\n\n/**\n * @title SafeERC20\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\n * Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      'SafeERC20: approve from non-zero to non-zero allowance'\n    );\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = address(token).call(data);\n    require(success, 'SafeERC20: low-level call failed');\n\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\n    }\n  }\n}\n"
    },
    "contracts/incentives/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\ninterface IScaledBalanceToken {\n  /**\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   **/\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled balance and the scaled total supply\n   **/\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @dev Returns the scaled total supply of the token. Represents sum(debt/index)\n   * @return The scaled total supply\n   **/\n  function scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/incentives/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @dev Collection of functions related to the address type\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n}\n"
    },
    "contracts/incentives/OpenSkyPoolIncentivesControllerBorrower.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\n\nimport {IERC20} from './interfaces/IERC20.sol';\nimport {SafeERC20} from './lib/SafeERC20.sol';\nimport {SafeMath} from './lib/SafeMath.sol';\n\nimport {BaseIncentivesController} from './base/BaseIncentivesController.sol';\nimport {IScaledBalanceToken} from './interfaces/IScaledBalanceToken.sol';\n\nimport {IOpenSky} from './interfaces/IOpenSky.sol';\n\ncontract OpenSkyPoolIncentivesControllerBorrower is\nBaseIncentivesController\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address internal _rewardsVault;\n\n    address public OPENSKY_SETTINGS;\n    \n    event RewardsVaultUpdated(address indexed vault);\n    event PoolSettingsUpdated(address indexed settings);\n\n    modifier onlyOpenSkyLoanCanCall() {\n        require(IOpenSky(OPENSKY_SETTINGS).loanAddress() == msg.sender, 'UNAUTHORIZED');\n        _;\n    }\n\n    constructor(IERC20 rewardToken, address emissionManager)\n    BaseIncentivesController(rewardToken, emissionManager)\n    {}\n\n    /**\n     * @dev Initialize AaveIncentivesController\n   * @param rewardsVault rewards vault to pull ERC20 funds\n   **/\n    function initialize(address rewardsVault, address OPENSKY_SETTINGS_) external initializer {\n        require(rewardsVault != address(0));\n        require(OPENSKY_SETTINGS_ != address(0));\n        \n        _rewardsVault = rewardsVault;\n        OPENSKY_SETTINGS= OPENSKY_SETTINGS_;\n        emit RewardsVaultUpdated(_rewardsVault);\n        emit PoolSettingsUpdated(OPENSKY_SETTINGS_);\n    }\n\n    /**\n     * @dev returns the current rewards vault contract\n   * @return address\n   */\n    function getRewardsVault() external view returns (address) {\n        return _rewardsVault;\n    }\n\n    /**\n     * @dev update the rewards vault address, only allowed by the Rewards admin\n   * @param rewardsVault The address of the rewards vault\n   **/\n    function setRewardsVault(address rewardsVault) external onlyEmissionManager {\n        _rewardsVault = rewardsVault;\n        emit RewardsVaultUpdated(rewardsVault);\n    }\n\n    /// @inheritdoc BaseIncentivesController\n    function _transferRewards(address to, uint256 amount) internal override {\n        IERC20(REWARD_TOKEN).safeTransferFrom(_rewardsVault, to, amount);\n    }\n\n    function getOpenSkyLoanAddress(address asset) internal view returns (uint256, address){\n        uint256 reserveId = IOpenSky(asset).reserveId();\n        address loanAddress = IOpenSky(OPENSKY_SETTINGS).loanAddress();\n        return (reserveId, loanAddress);\n    }\n\n    function _getUserBalanceAndSupply(address asset, address user) internal view override returns (uint256, uint256) {\n        (uint256 reserveId, address loanAddress) = getOpenSkyLoanAddress(asset);\n        return (IOpenSky(loanAddress).userBorrows(reserveId, user), IOpenSky(loanAddress).totalBorrows(reserveId));\n    }\n\n    function _getTotalSupply(address asset) internal view override returns (uint256){\n        (uint256 reserveId, address loanAddress) = getOpenSkyLoanAddress(asset);\n        return IOpenSky(loanAddress).totalBorrows(reserveId);\n    }\n\n    // customize for OpenSkyLoan\n    function handleAction(\n        address user,\n        uint256 totalSupply,\n        uint256 userBalance,\n        bytes calldata params //uint256 reserveId\n    ) external override onlyOpenSkyLoanCanCall{\n        uint256 reserveId = abi.decode(params,(uint256));\n        // get oTokenAddress\n        address poolAddress = IOpenSky(OPENSKY_SETTINGS).poolAddress();\n        address oTokenAddress = IOpenSky(poolAddress).getReserveData(reserveId).oTokenAddress;\n        \n        uint256 accruedRewards = _updateUserAssetInternal(user, oTokenAddress, userBalance, totalSupply);\n        if (accruedRewards != 0) {\n            _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n            emit RewardsAccrued(user, accruedRewards);\n        }\n    }\n}\n"
    },
    "contracts/incentives/interfaces/IOpenSky.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n    \ninterface IOpenSky {\n    struct ReserveData {\n        uint256 reserveId;\n        address underlyingAsset;\n        address oTokenAddress;\n        address moneyMarketAddress;\n        uint128 lastSupplyIndex;\n        uint256 borrowingInterestPerSecond;\n        uint256 lastMoneyMarketBalance;\n        uint40 lastUpdateTimestamp;\n        uint256 totalBorrows;\n        address interestModelAddress;\n        uint256 treasuryFactor;\n        bool isMoneyMarketOn;\n    }\n    \n    //oToken\n    function SETTINGS() external view returns (address);\n\n    function reserveId() external view returns (uint256);\n\n    //settings\n    function loanAddress() external view returns (address);\n\n    function poolAddress() external view returns (address);\n\n    //loan\n    function totalBorrows(uint256 reserveId) external view returns (uint256);\n\n    function userBorrows(uint256 reserveId, address account) external view returns (uint256);\n\n    //pool\n    function getReserveData(uint256 reserveId) external view returns (ReserveData memory);\n\n}\n"
    },
    "contracts/incentives/OpenSkyBespokeIncentivesControllerLender.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\n\nimport {IERC20} from './interfaces/IERC20.sol';\nimport {SafeERC20} from './lib/SafeERC20.sol';\nimport {SafeMath} from './lib/SafeMath.sol';\n\nimport {BaseIncentivesController} from './base/BaseIncentivesController.sol';\nimport {IScaledBalanceToken} from './interfaces/IScaledBalanceToken.sol';\n\nimport {IOpenSkyBespoke} from './interfaces/IOpenSkyBespoke.sol';\n\ncontract OpenSkyBespokeIncentivesControllerLender is\nBaseIncentivesController\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address internal _rewardsVault;\n    address public OPENSKY_BESPOKE_MARKET;\n\n    event RewardsVaultUpdated(address indexed vault);\n    event BespokeMarketUpdated(address indexed BespokeAddress);\n\n    modifier onlyBespokeMarketCanCall() {\n        require(OPENSKY_BESPOKE_MARKET == msg.sender, 'UNAUTHORIZED');\n        _;\n    }\n\n    constructor(IERC20 rewardToken, address emissionManager)\n    BaseIncentivesController(rewardToken, emissionManager)\n    {}\n\n    /**\n     * @dev Initialize AaveIncentivesController\n   * @param rewardsVault rewards vault to pull ERC20 funds\n   **/\n    function initialize(address rewardsVault, address OPENSKY_BESPOKE_MARKET_) external initializer {\n        require(rewardsVault != address(0));\n        require(OPENSKY_BESPOKE_MARKET_ != address(0));\n\n        _rewardsVault = rewardsVault;\n        OPENSKY_BESPOKE_MARKET = OPENSKY_BESPOKE_MARKET_; \n        emit RewardsVaultUpdated(_rewardsVault);\n        emit BespokeMarketUpdated(OPENSKY_BESPOKE_MARKET_);\n    }\n\n    /**\n     * @dev returns the current rewards vault contract\n   * @return address\n   */\n    function getRewardsVault() external view returns (address) {\n        return _rewardsVault;\n    }\n\n    /**\n     * @dev update the rewards vault address, only allowed by the Rewards admin\n   * @param rewardsVault The address of the rewards vault\n   **/\n    function setRewardsVault(address rewardsVault) external onlyEmissionManager {\n        _rewardsVault = rewardsVault;\n        emit RewardsVaultUpdated(rewardsVault);\n    }\n\n    /// @inheritdoc BaseIncentivesController\n    function _transferRewards(address to, uint256 amount) internal override {\n        IERC20(REWARD_TOKEN).safeTransferFrom(_rewardsVault, to, amount);\n    }\n    \n    function _getUserBalanceAndSupply(address asset, address user) internal view override returns (uint256, uint256) {\n        \n        return (\n            IOpenSkyBespoke(OPENSKY_BESPOKE_MARKET).userLend(asset, user),\n            IOpenSkyBespoke(OPENSKY_BESPOKE_MARKET).totalLend(asset)\n        );\n    }\n\n    function _getTotalSupply(address asset) internal view override returns (uint256){\n        return IOpenSkyBespoke(OPENSKY_BESPOKE_MARKET).totalLend(asset);\n    }\n\n    // customize\n    function handleAction(\n        address user,\n        uint256 totalSupply,\n        uint256 userBalance,\n        bytes calldata params //address currency\n    ) external override onlyBespokeMarketCanCall{\n        address currency = abi.decode(params,(address));\n        uint256 accruedRewards = _updateUserAssetInternal(user, currency, userBalance, totalSupply);\n        if (accruedRewards != 0) {\n            _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n            emit RewardsAccrued(user, accruedRewards);\n        }\n    }\n}\n"
    },
    "contracts/incentives/interfaces/IOpenSkyBespoke.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\ninterface IOpenSkyBespoke {\n\n    //settings\n    function marketAddress() external view returns (address);\n\n    // market\n    function totalBorrow(address currency) external view returns (uint256);\n    function userBorrow(address currency, address account) external view returns (uint256);\n    function totalLend(address currency) external view returns (uint256);\n    function userLend(address currency, address account) external view returns (uint256);\n    \n}\n"
    },
    "contracts/incentives/OpenSkyBespokeIncentivesControllerBorrower.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\n\nimport {IERC20} from './interfaces/IERC20.sol';\nimport {SafeERC20} from './lib/SafeERC20.sol';\nimport {SafeMath} from './lib/SafeMath.sol';\n\nimport {BaseIncentivesController} from './base/BaseIncentivesController.sol';\nimport {IScaledBalanceToken} from './interfaces/IScaledBalanceToken.sol';\n\nimport {IOpenSkyBespoke} from './interfaces/IOpenSkyBespoke.sol';\n\ncontract OpenSkyBespokeIncentivesControllerBorrower is\nBaseIncentivesController\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address internal _rewardsVault;\n    address public OPENSKY_BESPOKE_MARKET;\n\n    event RewardsVaultUpdated(address indexed vault);\n    event BespokeMarketUpdated(address indexed BespokeAddress);\n\n\n    modifier onlyBespokeMarketCanCall() {\n        require(OPENSKY_BESPOKE_MARKET == msg.sender, 'UNAUTHORIZED');\n        _;\n    }\n\n    constructor(IERC20 rewardToken, address emissionManager)\n    BaseIncentivesController(rewardToken, emissionManager)\n    {}\n\n    /**\n     * @dev Initialize AaveIncentivesController\n   * @param rewardsVault rewards vault to pull ERC20 funds\n   **/\n    function initialize(address rewardsVault, address OPENSKY_BESPOKE_MARKET_) external initializer {\n        require(rewardsVault != address(0));\n        require(OPENSKY_BESPOKE_MARKET_ != address(0));\n\n        _rewardsVault = rewardsVault;\n        OPENSKY_BESPOKE_MARKET = OPENSKY_BESPOKE_MARKET_; // TODO event?\n        emit RewardsVaultUpdated(_rewardsVault);\n        emit BespokeMarketUpdated(OPENSKY_BESPOKE_MARKET_);\n    }\n\n    /**\n     * @dev returns the current rewards vault contract\n   * @return address\n   */\n    function getRewardsVault() external view returns (address) {\n        return _rewardsVault;\n    }\n\n    /**\n   * @dev update the rewards vault address, only allowed by the Rewards admin\n   * @param rewardsVault The address of the rewards vault\n   **/\n    function setRewardsVault(address rewardsVault) external onlyEmissionManager {\n        _rewardsVault = rewardsVault;\n        emit RewardsVaultUpdated(rewardsVault);\n    }\n\n    /// @inheritdoc BaseIncentivesController\n    function _transferRewards(address to, uint256 amount) internal override {\n        IERC20(REWARD_TOKEN).safeTransferFrom(_rewardsVault, to, amount);\n    }\n\n    function _getUserBalanceAndSupply(address asset, address user) internal view override returns (uint256, uint256) {\n\n        return (\n            IOpenSkyBespoke(OPENSKY_BESPOKE_MARKET).userBorrow(asset, user),\n            IOpenSkyBespoke(OPENSKY_BESPOKE_MARKET).totalBorrow(asset)\n        );\n    }\n\n    function _getTotalSupply(address asset) internal view override returns (uint256){\n        return IOpenSkyBespoke(OPENSKY_BESPOKE_MARKET).totalBorrow(asset);\n    }\n\n    // customize\n    function handleAction(\n        address user,\n        uint256 totalSupply,\n        uint256 userBalance,\n        bytes calldata params   //address currency\n    ) external override onlyBespokeMarketCanCall{\n        address currency = abi.decode(params,(address));\n        uint256 accruedRewards = _updateUserAssetInternal(user, currency, userBalance, totalSupply);\n        if (accruedRewards != 0) {\n            _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n            emit RewardsAccrued(user, accruedRewards);\n        }\n    }\n}\n"
    },
    "contracts/incentives/mocks/ATokenMock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.10;\n\n\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {IAToken} from '../interfaces/IAToken.sol';\n\ncontract ATokenMock is IAToken {\n  IAaveIncentivesController public _aic;\n  uint256 internal _userBalance;\n  uint256 internal _totalSupply;\n\n  // hack to be able to test event from EI properly\n  event RewardsAccrued(address indexed user, uint256 amount);\n\n  // hack to be able to test event from Distribution manager properly\n  event AssetConfigUpdated(address indexed asset, uint256 emission);\n  event AssetIndexUpdated(address indexed asset, uint256 index);\n  event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\n\n  constructor(IAaveIncentivesController aic) public {\n    _aic = aic;\n  }\n\n  function handleActionOnAic(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external {\n    _aic.handleAction(user, totalSupply, userBalance, '');\n  }\n\n  function doubleHandleActionOnAic(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external {\n    _aic.handleAction(user, totalSupply, userBalance, '');\n    _aic.handleAction(user, totalSupply, userBalance, '');\n  }\n\n  function setUserBalanceAndSupply(uint256 userBalance, uint256 totalSupply) public {\n    _userBalance = userBalance;\n    _totalSupply = totalSupply;\n  }\n\n  function getScaledUserBalanceAndSupply(address user)\n    external\n    view\n    override\n    returns (uint256, uint256)\n  {\n    return (_userBalance, _totalSupply);\n  }\n\n  function scaledTotalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function cleanUserState() external {\n    _userBalance = 0;\n    _totalSupply = 0;\n  }\n}\n"
    },
    "contracts/incentives/interfaces/IAToken.sol": {
      "content": "pragma solidity 0.8.10;\n\ninterface IAToken {\n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}